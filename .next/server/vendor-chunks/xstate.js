"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xstate";
exports.ids = ["vendor-chunks/xstate"];
exports.modules = {

/***/ "(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/xstate/actors/dist/xstate-actors.development.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyActor: () => (/* binding */ createEmptyActor),\n/* harmony export */   fromCallback: () => (/* binding */ fromCallback),\n/* harmony export */   fromEventObservable: () => (/* binding */ fromEventObservable),\n/* harmony export */   fromObservable: () => (/* binding */ fromObservable),\n/* harmony export */   fromPromise: () => (/* binding */ fromPromise),\n/* harmony export */   fromTransition: () => (/* binding */ fromTransition)\n/* harmony export */ });\n/* harmony import */ var _dist_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/raise-13a60c49.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-13a60c49.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\n\nconst instanceStates = /* #__PURE__ */new WeakMap();\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromCallback(callback) {\n  const logic = {\n    config: callback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system,\n        emit\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === _dist_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        instanceStates.delete(actorScope.self);\n        callbackState.receivers?.clear();\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case _dist_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case _dist_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\n\nconst controllerMap = new WeakMap();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case _dist_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          {\n            controllerMap.get(scope.self)?.abort();\n            controllerMap.delete(scope.self);\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal,\n        emit\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return (0,_dist_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(emptyLogic);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtHO0FBQzVDOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQWtEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsU0FBUyxtQkFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEMsU0FBUyxrREFBa0Q7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QixzRUFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQyxTQUFTLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUMsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0VBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0VBQXdFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0VBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsU0FBUywwQkFBMEI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBa0Q7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0VBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUywwRUFBVztBQUNwQjs7QUFFNEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdmVkaWFuLW5ld3Nyb29tLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9hY3RvcnMvZGlzdC94c3RhdGUtYWN0b3JzLmRldmVsb3BtZW50LmVzbS5qcz83MDViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFggYXMgWFNUQVRFX1NUT1AsIGMgYXMgY3JlYXRlQWN0b3IgfSBmcm9tICcuLi8uLi9kaXN0L3JhaXNlLTEzYTYwYzQ5LmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21UcmFuc2l0aW9uYC5cbiAqXG4gKiBUaGUgdHlwZSBvZiBgc2VsZmAgd2l0aGluIHRoZSBhY3RvcidzIGxvZ2ljLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIGZyb21UcmFuc2l0aW9uLFxuICogICBjcmVhdGVBY3RvcixcbiAqICAgdHlwZSBBbnlBY3RvclN5c3RlbVxuICogfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIC8vKiBUaGUgYWN0b3IncyBzdG9yZWQgY29udGV4dC5cbiAqIHR5cGUgQ29udGV4dCA9IHtcbiAqICAgLy8gVGhlIGN1cnJlbnQgY291bnQuXG4gKiAgIGNvdW50OiBudW1iZXI7XG4gKiAgIC8vIFRoZSBhbW91bnQgdG8gaW5jcmVhc2UgYGNvdW50YCBieS5cbiAqICAgc3RlcDogbnVtYmVyO1xuICogfTtcbiAqIC8vIFRoZSBldmVudHMgdGhlIGFjdG9yIHJlY2VpdmVzLlxuICogdHlwZSBFdmVudCA9IHsgdHlwZTogJ2luY3JlbWVudCcgfTtcbiAqIC8vIFRoZSBhY3RvcidzIGlucHV0LlxuICogdHlwZSBJbnB1dCA9IHsgc3RlcD86IG51bWJlciB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgaW5jcmVtZW50cyBgY291bnRgIGJ5IGBzdGVwYCB3aGVuIGl0IHJlY2VpdmVzIGFuIGV2ZW50IG9mXG4gKiAvLyB0eXBlIGBpbmNyZW1lbnRgLlxuICogY29uc3QgbG9naWMgPSBmcm9tVHJhbnNpdGlvbjxDb250ZXh0LCBFdmVudCwgQW55QWN0b3JTeXN0ZW0sIElucHV0PihcbiAqICAgKHN0YXRlLCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICogICAgIGFjdG9yU2NvcGUuc2VsZjtcbiAqICAgICAvLyAgICAgICAgIF4/IFRyYW5zaXRpb25BY3RvclJlZjxDb250ZXh0LCBFdmVudD5cbiAqXG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdpbmNyZW1lbnQnKSB7XG4gKiAgICAgICByZXR1cm4ge1xuICogICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICAgY291bnQ6IHN0YXRlLmNvdW50ICsgc3RhdGUuc3RlcFxuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIHN0YXRlO1xuICogICB9LFxuICogICAoeyBpbnB1dCwgc2VsZiB9KSA9PiB7XG4gKiAgICAgc2VsZjtcbiAqICAgICAvLyBePyBUcmFuc2l0aW9uQWN0b3JSZWY8Q29udGV4dCwgRXZlbnQ+XG4gKlxuICogICAgIHJldHVybiB7XG4gKiAgICAgICBjb3VudDogMCxcbiAqICAgICAgIHN0ZXA6IGlucHV0LnN0ZXAgPz8gMVxuICogICAgIH07XG4gKiAgIH1cbiAqICk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBzdGVwOiAxMCB9IH0pO1xuICogLy8gICAgXj8gVHJhbnNpdGlvbkFjdG9yUmVmPENvbnRleHQsIEV2ZW50PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbVRyYW5zaXRpb259XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFjdG9yIGxvZ2ljIGdpdmVuIGEgdHJhbnNpdGlvbiBmdW5jdGlvbiBhbmQgaXRzIGluaXRpYWwgc3RhdGUuXG4gKlxuICogQSDigJx0cmFuc2l0aW9uIGZ1bmN0aW9u4oCdIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgY3VycmVudCBgc3RhdGVgIGFuZFxuICogcmVjZWl2ZWQgYGV2ZW50YCBvYmplY3QgYXMgYXJndW1lbnRzLCBhbmQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSwgc2ltaWxhciB0b1xuICogYSByZWR1Y2VyLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gdHJhbnNpdGlvbiBsb2dpYyAo4oCcdHJhbnNpdGlvbiBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIFJlY2VpdmUgZXZlbnRzXG4gKiAtIEVtaXQgc25hcHNob3RzIG9mIGl0cyBzdGF0ZVxuICpcbiAqIFRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9u4oCZcyBgc3RhdGVgIGlzIHVzZWQgYXMgaXRzIHRyYW5zaXRpb24gYWN0b3LigJlzXG4gKiBgY29udGV4dGAuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBcInN0YXRlXCIgZm9yIGEgdHJhbnNpdGlvbiBmdW5jdGlvbiBpcyBwcm92aWRlZCBieSB0aGUgaW5pdGlhbFxuICogc3RhdGUgYXJndW1lbnQsIGFuZCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIFN0YXRlIG9iamVjdCBvZiBhbiBhY3RvciBvciBhXG4gKiBzdGF0ZSB3aXRoaW4gYSBtYWNoaW5lIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgdHJhbnNpdGlvbkxvZ2ljID0gZnJvbVRyYW5zaXRpb24oXG4gKiAgIChzdGF0ZSwgZXZlbnQpID0+IHtcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2luY3JlbWVudCcpIHtcbiAqICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgICBjb3VudDogc3RhdGUuY291bnQgKyAxXG4gKiAgICAgICB9O1xuICogICAgIH1cbiAqICAgICByZXR1cm4gc3RhdGU7XG4gKiAgIH0sXG4gKiAgIHsgY291bnQ6IDAgfVxuICogKTtcbiAqXG4gKiBjb25zdCB0cmFuc2l0aW9uQWN0b3IgPSBjcmVhdGVBY3Rvcih0cmFuc2l0aW9uTG9naWMpO1xuICogdHJhbnNpdGlvbkFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICogfSk7XG4gKiB0cmFuc2l0aW9uQWN0b3Iuc3RhcnQoKTtcbiAqIC8vID0+IHtcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAqIC8vICAgY29udGV4dDogeyBjb3VudDogMCB9LFxuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqXG4gKiB0cmFuc2l0aW9uQWN0b3Iuc2VuZCh7IHR5cGU6ICdpbmNyZW1lbnQnIH0pO1xuICogLy8gPT4ge1xuICogLy8gICBzdGF0dXM6ICdhY3RpdmUnLFxuICogLy8gICBjb250ZXh0OiB7IGNvdW50OiAxIH0sXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRyYW5zaXRpb24gVGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gdXNlZCB0byBkZXNjcmliZSB0aGUgdHJhbnNpdGlvblxuICogICBsb2dpYy4gSXQgc2hvdWxkIHJldHVybiB0aGUgbmV4dCBzdGF0ZSBnaXZlbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgZXZlbnQuXG4gKiAgIEl0IHJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICpcbiAqICAgLSBgc3RhdGVgIC0gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiAgIC0gYGV2ZW50YCAtIHRoZSByZWNlaXZlZCBldmVudC5cbiAqICAgLSBgYWN0b3JTY29wZWAgLSB0aGUgYWN0b3Igc2NvcGUgb2JqZWN0LCB3aXRoIHByb3BlcnRpZXMgbGlrZSBgc2VsZmAgYW5kXG4gKiAgICAgICBgc3lzdGVtYC5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbENvbnRleHQgVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24sIGVpdGhlciBhblxuICogICBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSwgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgc3RhdGUgb2JqZWN0LlxuICogICBJZiBhIGZ1bmN0aW9uLCBpdCB3aWxsIHJlY2VpdmUgYXMgaXRzIG9ubHkgYXJndW1lbnQgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiAgIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gdGhlIGBpbnB1dGAgcHJvdmlkZWQgdG8gaXRzIHBhcmVudCB0cmFuc2l0aW9uIGFjdG9yLlxuICogICAtIGBzZWxmYCAtIGEgcmVmZXJlbmNlIHRvIGl0cyBwYXJlbnQgdHJhbnNpdGlvbiBhY3Rvci5cbiAqXG4gKiBAcmV0dXJucyBBY3RvciBsb2dpY1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvaW5wdXQgfCBJbnB1dCBkb2NzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgaW5wdXQgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21UcmFuc2l0aW9uKHRyYW5zaXRpb24sIGluaXRpYWxDb250ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgY29uZmlnOiB0cmFuc2l0aW9uLFxuICAgIHRyYW5zaXRpb246IChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICBjb250ZXh0OiB0cmFuc2l0aW9uKHNuYXBzaG90LmNvbnRleHQsIGV2ZW50LCBhY3RvclNjb3BlKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgY29udGV4dDogdHlwZW9mIGluaXRpYWxDb250ZXh0ID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbENvbnRleHQoe1xuICAgICAgICAgIGlucHV0XG4gICAgICAgIH0pIDogaW5pdGlhbENvbnRleHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdFxuICB9O1xufVxuXG5jb25zdCBpbnN0YW5jZVN0YXRlcyA9IC8qICNfX1BVUkVfXyAqL25ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tQ2FsbGJhY2tgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUNhbGxiYWNrLCBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogLy8gVGhlIGV2ZW50cyB0aGUgYWN0b3IgcmVjZWl2ZXMuXG4gKiB0eXBlIEV2ZW50ID0geyB0eXBlOiAnc29tZUV2ZW50JyB9O1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBuYW1lOiBzdHJpbmcgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGxvZ3Mgd2hlbmV2ZXIgaXQgcmVjZWl2ZXMgYW4gZXZlbnQgb2YgdHlwZSBgc29tZUV2ZW50YC5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbUNhbGxiYWNrPEV2ZW50LCBJbnB1dD4oKHsgc2VsZiwgaW5wdXQsIHJlY2VpdmUgfSkgPT4ge1xuICogICBzZWxmO1xuICogICAvLyBePyBDYWxsYmFja0FjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqXG4gKiAgIHJlY2VpdmUoKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdzb21lRXZlbnQnKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhgJHtpbnB1dC5uYW1lfTogcmVjZWl2ZWQgXCJzb21lRXZlbnRcIiBldmVudGApO1xuICogICAgICAgLy8gbG9ncyAnbXlBY3RvcjogcmVjZWl2ZWQgXCJzb21lRXZlbnRcIiBldmVudCdcbiAqICAgICB9XG4gKiAgIH0pO1xuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBuYW1lOiAnbXlBY3RvcicgfSB9KTtcbiAqIC8vICAgIF4/IENhbGxiYWNrQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbUNhbGxiYWNrfVxuICovXG5cbi8qKlxuICogQW4gYWN0b3IgbG9naWMgY3JlYXRvciB3aGljaCByZXR1cm5zIGNhbGxiYWNrIGxvZ2ljIGFzIGRlZmluZWQgYnkgYSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFVzZWZ1bCBmb3Igc3Vic2NyaXB0aW9uLWJhc2VkIG9yIG90aGVyIGZyZWUtZm9ybSBsb2dpYyB0aGF0IGNhbiBzZW5kIGV2ZW50c1xuICogYmFjayB0byB0aGUgcGFyZW50IGFjdG9yLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gY2FsbGJhY2sgbG9naWMgKOKAnGNhbGxiYWNrIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gUmVjZWl2ZSBldmVudHMgdmlhIHRoZSBgcmVjZWl2ZWAgZnVuY3Rpb25cbiAqIC0gU2VuZCBldmVudHMgdG8gdGhlIHBhcmVudCBhY3RvciB2aWEgdGhlIGBzZW5kQmFja2AgZnVuY3Rpb25cbiAqXG4gKiBDYWxsYmFjayBhY3RvcnMgYXJlIGEgYml0IGRpZmZlcmVudCBmcm9tIG90aGVyIGFjdG9ycyBpbiB0aGF0IHRoZXk6XG4gKlxuICogLSBEbyBub3Qgd29yayB3aXRoIGBvbkRvbmVgXG4gKiAtIERvIG5vdCBwcm9kdWNlIGEgc25hcHNob3QgdXNpbmcgYC5nZXRTbmFwc2hvdCgpYFxuICogLSBEbyBub3QgZW1pdCB2YWx1ZXMgd2hlbiB1c2VkIHdpdGggYC5zdWJzY3JpYmUoKWBcbiAqIC0gQ2FuIG5vdCBiZSBzdG9wcGVkIHdpdGggYC5zdG9wKClgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBjYWxsYmFja0xvZ2ljID0gZnJvbUNhbGxiYWNrKCh7IHNlbmRCYWNrLCByZWNlaXZlIH0pID0+IHtcbiAqICAgbGV0IGxvY2tTdGF0dXMgPSAndW5sb2NrZWQnO1xuICpcbiAqICAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICogICAgIGlmIChsb2NrU3RhdHVzID09PSAnbG9ja2VkJykge1xuICogICAgICAgcmV0dXJuO1xuICogICAgIH1cbiAqICAgICBzZW5kQmFjayhldmVudCk7XG4gKiAgIH07XG4gKlxuICogICByZWNlaXZlKChldmVudCkgPT4ge1xuICogICAgIGlmIChldmVudC50eXBlID09PSAnbG9jaycpIHtcbiAqICAgICAgIGxvY2tTdGF0dXMgPSAnbG9ja2VkJztcbiAqICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICd1bmxvY2snKSB7XG4gKiAgICAgICBsb2NrU3RhdHVzID0gJ3VubG9ja2VkJztcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICpcbiAqICAgcmV0dXJuICgpID0+IHtcbiAqICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gKiAgIH07XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB1c2VkIHRvIGRlc2NyaWJlIHRoZSBjYWxsYmFjayBsb2dpY1xuICogICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYHJlY2VpdmVgIC0gQSBmdW5jdGlvbiB0aGF0IGNhbiBzZW5kIGV2ZW50cyBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3I7IHRoZVxuICogICAgICAgbGlzdGVuZXIgaXMgdGhlbiBjYWxsZWQgd2hlbmV2ZXIgZXZlbnRzIGFyZSByZWNlaXZlZCBieSB0aGUgY2FsbGJhY2tcbiAqICAgICAgIGFjdG9yXG4gKiAgIC0gYHNlbmRCYWNrYCAtIEEgZnVuY3Rpb24gdGhhdCBjYW4gc2VuZCBldmVudHMgYmFjayB0byB0aGUgcGFyZW50IGFjdG9yXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIGNhbGxiYWNrIGFjdG9yXG4gKiAgIC0gYHNlbGZgIC0gVGhlIHBhcmVudCBhY3RvciBvZiB0aGUgY2FsbGJhY2sgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIGNhbGxiYWNrIGFjdG9yIGJlbG9uZ3MgVGhlIGNhbGxiYWNrXG4gKiAgICAgICBmdW5jdGlvbiBjYW4gKG9wdGlvbmFsbHkpIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZFxuICogICAgICAgd2hlbiB0aGUgYWN0b3IgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcmV0dXJucyBDYWxsYmFjayBsb2dpY1xuICogQHNlZSB7QGxpbmsgQ2FsbGJhY2tMb2dpY0Z1bmN0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIGl0cyBvYmplY3QgYXJndW1lbnRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2lucHV0IHwgSW5wdXQgZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGlucHV0IGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBmcm9tQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBjYWxsYmFjayxcbiAgICBzdGFydDogKHN0YXRlLCBhY3RvclNjb3BlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGYsXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgZW1pdFxuICAgICAgfSA9IGFjdG9yU2NvcGU7XG4gICAgICBjb25zdCBjYWxsYmFja1N0YXRlID0ge1xuICAgICAgICByZWNlaXZlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZGlzcG9zZTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgaW5zdGFuY2VTdGF0ZXMuc2V0KHNlbGYsIGNhbGxiYWNrU3RhdGUpO1xuICAgICAgY2FsbGJhY2tTdGF0ZS5kaXNwb3NlID0gY2FsbGJhY2soe1xuICAgICAgICBpbnB1dDogc3RhdGUuaW5wdXQsXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgc2VuZEJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoc2VsZi5nZXRTbmFwc2hvdCgpLnN0YXR1cyA9PT0gJ3N0b3BwZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZi5fcGFyZW50LCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWNlaXZlOiBsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnMgPz89IG5ldyBTZXQoKTtcbiAgICAgICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICB9LFxuICAgICAgICBlbWl0XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRyYW5zaXRpb246IChzdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrU3RhdGUgPSBpbnN0YW5jZVN0YXRlcy5nZXQoYWN0b3JTY29wZS5zZWxmKTtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBYU1RBVEVfU1RPUCkge1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBzdGF0dXM6ICdzdG9wcGVkJyxcbiAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGluc3RhbmNlU3RhdGVzLmRlbGV0ZShhY3RvclNjb3BlLnNlbGYpO1xuICAgICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycz8uY2xlYXIoKTtcbiAgICAgICAgY2FsbGJhY2tTdGF0ZS5kaXNwb3NlPy4oKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnM/LmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIoZXZlbnQpKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdFxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX05FWFQgPSAneHN0YXRlLm9ic2VydmFibGUubmV4dCc7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUiA9ICd4c3RhdGUub2JzZXJ2YWJsZS5lcnJvcic7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURSA9ICd4c3RhdGUub2JzZXJ2YWJsZS5jb21wbGV0ZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tT2JzZXJ2YWJsZWAgb3IgYGZyb21FdmVudE9ic2VydmFibGVgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbU9ic2VydmFibGUsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogLy8gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIG9ic2VydmVkIGJ5IHRoZSBhY3RvcidzIGxvZ2ljLlxuICogdHlwZSBDb250ZXh0ID0gbnVtYmVyO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBwZXJpb2Q/OiBudW1iZXIgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IG9ic2VydmVzIGEgbnVtYmVyIGluY3JlbWVudGVkIGV2ZXJ5IGBpbnB1dC5wZXJpb2RgXG4gKiAvLyBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDFfMDAwKS5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbU9ic2VydmFibGU8Q29udGV4dCwgSW5wdXQ+KCh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gT2JzZXJ2YWJsZUFjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqXG4gKiAgIHJldHVybiBpbnRlcnZhbChpbnB1dC5wZXJpb2QgPz8gMV8wMDApO1xuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBwZXJpb2Q6IDJfMDAwIH0gfSk7XG4gKiAvLyAgICBePyBPYnNlcnZhYmxlQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbU9ic2VydmFibGV9XG4gKiBAc2VlIHtAbGluayBmcm9tRXZlbnRPYnNlcnZhYmxlfVxuICovXG5cbi8qKlxuICogT2JzZXJ2YWJsZSBhY3RvciBsb2dpYyBpcyBkZXNjcmliZWQgYnkgYW4gb2JzZXJ2YWJsZSBzdHJlYW0gb2YgdmFsdWVzLiBBY3RvcnNcbiAqIGNyZWF0ZWQgZnJvbSBvYnNlcnZhYmxlIGxvZ2ljICjigJxvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgdGhlIG9ic2VydmFibGXigJlzIGVtaXR0ZWQgdmFsdWVcbiAqXG4gKiBUaGUgb2JzZXJ2YWJsZeKAmXMgZW1pdHRlZCB2YWx1ZSBpcyB1c2VkIGFzIGl0cyBvYnNlcnZhYmxlIGFjdG9y4oCZcyBgY29udGV4dGAuXG4gKlxuICogU2VuZGluZyBldmVudHMgdG8gb2JzZXJ2YWJsZSBhY3RvcnMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tT2JzZXJ2YWJsZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBsb2dpYyA9IGZyb21PYnNlcnZhYmxlKChvYmopID0+IGludGVydmFsKDEwMDApKTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljKTtcbiAqXG4gKiBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90LmNvbnRleHQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc3RhcnQoKTtcbiAqIC8vIEF0IGV2ZXJ5IHNlY29uZDpcbiAqIC8vIExvZ3MgMFxuICogLy8gTG9ncyAxXG4gKiAvLyBMb2dzIDJcbiAqIC8vIC4uLlxuICogYGBgXG4gKlxuICogQHBhcmFtIG9ic2VydmFibGVDcmVhdG9yIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIG9ic2VydmFibGUuIEl0IHJlY2VpdmVzXG4gKiAgIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIG9ic2VydmFibGUgYWN0b3IgYmVsb25nc1xuICpcbiAqICAgSXQgc2hvdWxkIHJldHVybiBhIHtAbGluayBTdWJzY3JpYmFibGV9LCB3aGljaCBpcyBjb21wYXRpYmxlIHdpdGggYW4gUnhKU1xuICogICBPYnNlcnZhYmxlLCBhbHRob3VnaCBSeEpTIGlzIG5vdCByZXF1aXJlZCB0byBjcmVhdGUgdGhlbS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnhqcy5kZXZ9IGZvciBkb2N1bWVudGF0aW9uIG9uIFJ4SlMgT2JzZXJ2YWJsZSBhbmQgb2JzZXJ2YWJsZSBjcmVhdG9ycy5cbiAqIEBzZWUge0BsaW5rIFN1YnNjcmliYWJsZX0gaW50ZXJmYWNlIGluIFhTdGF0ZSwgd2hpY2ggaXMgYmFzZWQgb24gYW5kIGNvbXBhdGlibGUgd2l0aCBSeEpTIE9ic2VydmFibGUuXG4gKi9cbmZ1bmN0aW9uIGZyb21PYnNlcnZhYmxlKG9ic2VydmFibGVDcmVhdG9yKSB7XG4gIC8vIFRPRE86IGFkZCBldmVudCB0eXBlc1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IG9ic2VydmFibGVDcmVhdG9yLFxuICAgIHRyYW5zaXRpb246IChzbmFwc2hvdCwgZXZlbnQpID0+IHtcbiAgICAgIGlmIChzbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX05FWFQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmV3U25hcHNob3QgPSB7XG4gICAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgICBjb250ZXh0OiBldmVudC5kYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc25hcHNob3QuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlQ3JlYXRvcih7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9ORVhULFxuICAgICAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUixcbiAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogKHtcbiAgICAgIF9zdWJzY3JpcHRpb24sXG4gICAgICAuLi5zdGF0ZVxuICAgIH0pID0+IHN0YXRlLFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc3RhdGUgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZXZlbnQgb2JzZXJ2YWJsZSBsb2dpYyB0aGF0IGxpc3RlbnMgdG8gYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiBldmVudCBvYmplY3RzLlxuICpcbiAqIEV2ZW50IG9ic2VydmFibGUgYWN0b3IgbG9naWMgaXMgZGVzY3JpYmVkIGJ5IGFuIG9ic2VydmFibGUgc3RyZWFtIG9mXG4gKiB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvdHJhbnNpdGlvbnMjZXZlbnQtb2JqZWN0cyB8IGV2ZW50IG9iamVjdHN9LlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBldmVudCBvYnNlcnZhYmxlIGxvZ2ljICjigJxldmVudCBvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gSW1wbGljaXRseSBzZW5kIGV2ZW50cyB0byBpdHMgcGFyZW50IGFjdG9yXG4gKiAtIEVtaXQgc25hcHNob3RzIG9mIGl0cyBlbWl0dGVkIGV2ZW50IG9iamVjdHNcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBldmVudCBvYnNlcnZhYmxlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIGZyb21FdmVudE9ic2VydmFibGUsXG4gKiAgIFN1YnNjcmliYWJsZSxcbiAqICAgRXZlbnRPYmplY3QsXG4gKiAgIGNyZWF0ZU1hY2hpbmUsXG4gKiAgIGNyZWF0ZUFjdG9yXG4gKiB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBtb3VzZUNsaWNrTG9naWMgPSBmcm9tRXZlbnRPYnNlcnZhYmxlKFxuICogICAoKSA9PiBmcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgJ2NsaWNrJykgYXMgU3Vic2NyaWJhYmxlPEV2ZW50T2JqZWN0PlxuICogKTtcbiAqXG4gKiBjb25zdCBjYW52YXNNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGludm9rZToge1xuICogICAgIC8vIFdpbGwgc2VuZCBtb3VzZSBgY2xpY2tgIGV2ZW50cyB0byB0aGUgY2FudmFzIGFjdG9yXG4gKiAgICAgc3JjOiBtb3VzZUNsaWNrTG9naWNcbiAqICAgfVxuICogfSk7XG4gKlxuICogY29uc3QgY2FudmFzQWN0b3IgPSBjcmVhdGVBY3RvcihjYW52YXNNYWNoaW5lKTtcbiAqIGNhbnZhc0FjdG9yLnN0YXJ0KCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGF6eU9ic2VydmFibGUgQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiAgIGV2ZW50IG9iamVjdHMuIEl0IHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogICBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgZXZlbnQgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIGV2ZW50IG9ic2VydmFibGUgYWN0b3IgYmVsb25ncy5cbiAqXG4gKiAgIEl0IHNob3VsZCByZXR1cm4gYSB7QGxpbmsgU3Vic2NyaWJhYmxlfSwgd2hpY2ggaXMgY29tcGF0aWJsZSB3aXRoIGFuIFJ4SlNcbiAqICAgT2JzZXJ2YWJsZSwgYWx0aG91Z2ggUnhKUyBpcyBub3QgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIGZyb21FdmVudE9ic2VydmFibGUobGF6eU9ic2VydmFibGUpIHtcbiAgLy8gVE9ETzogZXZlbnQgdHlwZXNcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBsYXp5T2JzZXJ2YWJsZSxcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBsYXp5T2JzZXJ2YWJsZSh7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuX3BhcmVudCkge1xuICAgICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLl9wYXJlbnQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfRVJST1IsXG4gICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6ICh7XG4gICAgICBfc3Vic2NyaXB0aW9uLFxuICAgICAgLi4uc25hcHNob3RcbiAgICB9KSA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+ICh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgWFNUQVRFX1BST01JU0VfUkVTT0xWRSA9ICd4c3RhdGUucHJvbWlzZS5yZXNvbHZlJztcbmNvbnN0IFhTVEFURV9QUk9NSVNFX1JFSkVDVCA9ICd4c3RhdGUucHJvbWlzZS5yZWplY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbVByb21pc2VgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbVByb21pc2UsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyBUaGUgYWN0b3IncyByZXNvbHZlZCBvdXRwdXRcbiAqIHR5cGUgT3V0cHV0ID0gc3RyaW5nO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBtZXNzYWdlOiBzdHJpbmcgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGZldGNoZXMgdGhlIHVybCBvZiBhbiBpbWFnZSBvZiBhIGNhdCBzYXlpbmcgYGlucHV0Lm1lc3NhZ2VgLlxuICogY29uc3QgbG9naWMgPSBmcm9tUHJvbWlzZTxPdXRwdXQsIElucHV0Pihhc3luYyAoeyBpbnB1dCwgc2VsZiB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICpcbiAqICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoKFxuICogICAgIGBodHRwczovL2NhdGFhcy5jb20vY2F0L3NheXMvJHtpbnB1dC5tZXNzYWdlfWBcbiAqICAgKTtcbiAqICAgY29uc3QgdXJsID0gYXdhaXQgZGF0YS5qc29uKCk7XG4gKiAgIHJldHVybiB1cmw7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IG1lc3NhZ2U6ICdoZWxsbyB3b3JsZCcgfSB9KTtcbiAqIC8vICAgIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbVByb21pc2V9XG4gKi9cblxuY29uc3QgY29udHJvbGxlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQW4gYWN0b3IgbG9naWMgY3JlYXRvciB3aGljaCByZXR1cm5zIHByb21pc2UgbG9naWMgYXMgZGVmaW5lZCBieSBhbiBhc3luY1xuICogcHJvY2VzcyB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYWZ0ZXIgc29tZSB0aW1lLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gcHJvbWlzZSBhY3RvciBsb2dpYyAo4oCccHJvbWlzZSBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIEVtaXQgdGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBwcm9taXNlXG4gKiAtIE91dHB1dCB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIHByb21pc2VcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBwcm9taXNlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHByb21pc2VMb2dpYyA9IGZyb21Qcm9taXNlKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZXhhbXBsZS5jb20vLi4uJykudGhlbigoZGF0YSkgPT5cbiAqICAgICBkYXRhLmpzb24oKVxuICogICApO1xuICpcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHByb21pc2VBY3RvciA9IGNyZWF0ZUFjdG9yKHByb21pc2VMb2dpYyk7XG4gKiBwcm9taXNlQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqIHByb21pc2VBY3Rvci5zdGFydCgpO1xuICogLy8gPT4ge1xuICogLy8gICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJ1xuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqXG4gKiAvLyBBZnRlciBwcm9taXNlIHJlc29sdmVzXG4gKiAvLyA9PiB7XG4gKiAvLyAgIG91dHB1dDogeyAuLi4gfSxcbiAqIC8vICAgc3RhdHVzOiAnZG9uZScsXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHByb21pc2VDcmVhdG9yIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGFuZCBhY2NlcHRzIGFuXG4gKiAgIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIHByb21pc2UgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yIG9mIHRoZSBwcm9taXNlIGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBwcm9taXNlIGFjdG9yIGJlbG9uZ3NcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZUNyZWF0b3IpIHtcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBwcm9taXNlQ3JlYXRvcixcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50LCBzY29wZSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgWFNUQVRFX1BST01JU0VfUkVTT0xWRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgICAgICAgb3V0cHV0OiByZXNvbHZlZFZhbHVlLFxuICAgICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfUFJPTUlTRV9SRUpFQ1Q6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250cm9sbGVyTWFwLmdldChzY29wZS5zZWxmKT8uYWJvcnQoKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXJNYXAuZGVsZXRlKHNjb3BlLnNlbGYpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIC8vIFRPRE86IGRldGVybWluZSBob3cgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhpcyBzbyB0aGF0IHByb21pc2VzXG4gICAgICAvLyBjYW4gYmUgcmVzdGFydGVkIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnRyb2xsZXJNYXAuc2V0KHNlbGYsIGNvbnRyb2xsZXIpO1xuICAgICAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb21pc2VDcmVhdG9yKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGVtaXRcbiAgICAgIH0pKTtcbiAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXJNYXAuZGVsZXRlKHNlbGYpO1xuICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICB0eXBlOiBYU1RBVEVfUFJPTUlTRV9SRVNPTFZFLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlXG4gICAgICAgIH0pO1xuICAgICAgfSwgZXJyb3JEYXRhID0+IHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXJNYXAuZGVsZXRlKHNlbGYpO1xuICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICB0eXBlOiBYU1RBVEVfUFJPTUlTRV9SRUpFQ1QsXG4gICAgICAgICAgZGF0YTogZXJyb3JEYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3RcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG5jb25zdCBlbXB0eUxvZ2ljID0gZnJvbVRyYW5zaXRpb24oXyA9PiB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUFjdG9yKCkge1xuICByZXR1cm4gY3JlYXRlQWN0b3IoZW1wdHlMb2dpYyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVtcHR5QWN0b3IsIGZyb21DYWxsYmFjaywgZnJvbUV2ZW50T2JzZXJ2YWJsZSwgZnJvbU9ic2VydmFibGUsIGZyb21Qcm9taXNlLCBmcm9tVHJhbnNpdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dev/dist/xstate-dev.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devToolsAdapter: () => (/* binding */ devToolsAdapter),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   registerService: () => (/* binding */ registerService)\n/* harmony export */ });\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  {\n    console.warn('XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues');\n  }\n}\nfunction getDevTools() {\n  const w = getGlobal();\n  if (w.__xstate__) {\n    return w.__xstate__;\n  }\n  return undefined;\n}\nfunction registerService(service) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n}\nconst devToolsAdapter = service => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RCIsInNvdXJjZXMiOlsid2VicGFjazovL2F2ZWRpYW4tbmV3c3Jvb20vLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzP2E4ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9nbG9iYWxUaGlzXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHtcbiAgICBjb25zb2xlLndhcm4oJ1hTdGF0ZSBjb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3QgaW4gdGhpcyBlbnZpcm9ubWVudC4gUGxlYXNlIGxldCB0aGUgbWFpbnRhaW5lcnMga25vdyBhbmQgcmFpc2UgYW4gaXNzdWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3N0YXRlbHlhaS94c3RhdGUvaXNzdWVzJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERldlRvb2xzKCkge1xuICBjb25zdCB3ID0gZ2V0R2xvYmFsKCk7XG4gIGlmICh3Ll9feHN0YXRlX18pIHtcbiAgICByZXR1cm4gdy5fX3hzdGF0ZV9fO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZWdpc3RlclNlcnZpY2Uoc2VydmljZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGV2VG9vbHMgPSBnZXREZXZUb29scygpO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufVxuY29uc3QgZGV2VG9vbHNBZGFwdGVyID0gc2VydmljZSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZXZUb29scyA9IGdldERldlRvb2xzKCk7XG4gIGlmIChkZXZUb29scykge1xuICAgIGRldlRvb2xzLnJlZ2lzdGVyKHNlcnZpY2UpO1xuICB9XG59O1xuXG5leHBvcnQgeyBkZXZUb29sc0FkYXB0ZXIsIGdldEdsb2JhbCwgcmVnaXN0ZXJTZXJ2aWNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/StateMachine-d0e98d09.development.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/xstate/dist/StateMachine-d0e98d09.development.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ StateMachine),\n/* harmony export */   a: () => (/* binding */ StateNode)\n/* harmony export */ });\n/* harmony import */ var _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-13a60c49.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-13a60c49.development.esm.js\");\n/* harmony import */ var _assign_541a432d_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assign-541a432d.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-541a432d.development.esm.js\");\n\n\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\n\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(/** The raw config used to create the machine. */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */\n    this.key = void 0;\n    /** The unique ID of the state node. */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */\n    this.type = void 0;\n    /** The string path from the root machine node to this node. */\n    this.path = void 0;\n    /** The child state nodes. */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /** The action(s) to be executed upon entering the state node. */\n    this.entry = void 0;\n    /** The action(s) to be executed upon exiting the state node. */\n    this.exit = void 0;\n    /** The parent state node. */\n    this.parent = void 0;\n    /** The root machine node. */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.S);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.entry).slice();\n    this.exit = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(this);\n    if (this.config.always) {\n      this.always = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.config.always).map(t => (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(this, _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.N, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  get invoke() {\n    return memo(this, 'invoke', () => (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)(this.id, i);\n      const sourceName = typeof src === 'string' ? src : `xstate.invoke.${(0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: sourceName,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: sourceName,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /** The mapping of events to transitions. */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.B)(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const keys = Object.keys(Object.fromEntries(this.transitions));\n    const events = new Set(keys.filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\n\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(/** The raw config used to create the machine. */\n  config, implementations) {\n    this.config = config;\n    /** The machine's own version. */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n    if (!('output' in this.root) && Object.values(this.states).some(state => state.type === 'final' && 'output' in state)) {\n      console.warn('Missing `machine.output` declaration (top-level final state with output detected)');\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.root, config.value);\n    const nodeSet = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)((0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)(this.root, resolvedStateValue));\n    return (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.G)(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(snapshot, event, actorScope, []).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(snapshot, event, actorScope, []).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.I)(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.J)(preInitial, initEvent, actorScope, [(0,_assign_541a432d_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(assignment)], internalQueue, undefined);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.K)(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.L)([{\n      target: [...(0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Q)(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T)(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    function resolveHistoryReferencedState(root, referenced) {\n      if (referenced instanceof StateNode) {\n        return referenced;\n      }\n      try {\n        return root.machine.getStateNodeById(referenced.id);\n      } catch {\n        {\n          console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n        }\n      }\n    }\n    function reviveHistoryValue(root, historyValue) {\n      if (!historyValue || typeof historyValue !== 'object') {\n        return {};\n      }\n      const revived = {};\n      for (const key in historyValue) {\n        const arr = historyValue[key];\n        for (const item of arr) {\n          const resolved = resolveHistoryReferencedState(root, item);\n          if (!resolved) {\n            continue;\n          }\n          revived[key] ??= [];\n          revived[key].push(resolved);\n        }\n      }\n      return revived;\n    }\n    const revivedHistoryValue = reviveHistoryValue(this.root, snapshot.historyValue);\n    const restoredSnapshot = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)({\n      ...snapshot,\n      children,\n      _nodes: Array.from((0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)((0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)(this.root, snapshot.value))),\n      historyValue: revivedHistoryValue\n    }, this);\n    const seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (const key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.$) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvU3RhdGVNYWNoaW5lLWQwZTk4ZDA5LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStzQjtBQUM1b0I7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUVBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4RUFBOEUsUUFBUSxnQkFBZ0IsWUFBWSw0QkFBNEIsSUFBSTtBQUNsSjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFPO0FBQ3hCLGdCQUFnQixxRUFBTztBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUVBQWlCO0FBQ3hDO0FBQ0Esb0JBQW9CLHFFQUF1Qiw4QkFBOEIscUVBQWdCLE9BQU8saUVBQVU7QUFDMUc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RCxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLGNBQWMscUVBQVM7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxxRUFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNENBQTRDLHFFQUFjO0FBQzFELDBFQUEwRSxxRUFBYyxhQUFhO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0RBQWtELHFFQUFxQjtBQUN2RTtBQUNBO0FBQ0EsdUNBQXVDLHFFQUF1QjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsU0FBUyxxRUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFFQUFhO0FBQzdDLFFBQVE7QUFDUjtBQUNBLG9EQUFvRCxnQkFBZ0IsVUFBVSxTQUFTLDJCQUEyQixVQUFVLG1CQUFtQixRQUFRLE1BQU0sWUFBWTtBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsNkNBQTZDO0FBQzdDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IscUVBQWlCO0FBQ2hELG9CQUFvQixxRUFBZ0IsQ0FBQyxxRUFBYTtBQUNsRCxXQUFXLHFFQUFxQjtBQUNoQztBQUNBLG1DQUFtQztBQUNuQyxrQkFBa0I7QUFDbEIsY0FBYyxxRUFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQVM7QUFDcEI7QUFDQTtBQUNBLFdBQVcscUVBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLHFFQUFxQjtBQUM1QyxzRUFBc0U7QUFDdEU7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsYUFBYSxxRUFBd0IscUNBQXFDLHNFQUFNO0FBQ2hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFFQUFlLFNBQVM7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQixxRUFBUztBQUMvQixrQkFBa0IscUVBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU0sRUFBRSxxRUFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLHFFQUFXO0FBQ2hDO0FBQ0EsNEJBQTRCLHFFQUFTO0FBQ3JDO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLCtCQUErQixRQUFRO0FBQ25HO0FBQ0EsV0FBVyxxRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUVBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUVBQXFCO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUIscUVBQWdCLENBQUMscUVBQWE7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlFQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXZlZGlhbi1uZXdzcm9vbS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC9TdGF0ZU1hY2hpbmUtZDBlOThkMDkuZGV2ZWxvcG1lbnQuZXNtLmpzP2NiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUyBhcyBTVEFURV9ERUxJTUlURVIsIHEgYXMgbWFwVmFsdWVzLCB0IGFzIHRvQXJyYXksIHUgYXMgZm9ybWF0VHJhbnNpdGlvbnMsIHYgYXMgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXksIHcgYXMgZm9ybWF0VHJhbnNpdGlvbiwgTiBhcyBOVUxMX0VWRU5ULCB4IGFzIGV2YWx1YXRlR3VhcmQsIHkgYXMgY3JlYXRlSW52b2tlSWQsIHogYXMgZ2V0RGVsYXllZFRyYW5zaXRpb25zLCBCIGFzIGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uLCBDIGFzIGdldENhbmRpZGF0ZXMsIEQgYXMgcmVzb2x2ZVN0YXRlVmFsdWUsIEUgYXMgZ2V0QWxsU3RhdGVOb2RlcywgZyBhcyBnZXRTdGF0ZU5vZGVzLCBGIGFzIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCwgRyBhcyBpc0luRmluYWxTdGF0ZSwgSCBhcyBtYWNyb3N0ZXAsIEkgYXMgdHJhbnNpdGlvbk5vZGUsIEogYXMgcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0LCBLIGFzIGNyZWF0ZUluaXRFdmVudCwgTCBhcyBtaWNyb3N0ZXAsIE0gYXMgZ2V0SW5pdGlhbFN0YXRlTm9kZXMsIE8gYXMgdG9TdGF0ZVBhdGgsIFAgYXMgaXNTdGF0ZUlkLCBRIGFzIGdldFN0YXRlTm9kZUJ5UGF0aCwgUiBhcyBnZXRQZXJzaXN0ZWRTbmFwc2hvdCwgVCBhcyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yLCBjIGFzIGNyZWF0ZUFjdG9yLCAkIGFzICQkQUNUT1JfVFlQRSB9IGZyb20gJy4vcmFpc2UtMTNhNjBjNDkuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi9hc3NpZ24tNTQxYTQzMmQuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWVtbyhvYmplY3QsIGtleSwgZm4pIHtcbiAgbGV0IG1lbW9pemVkRGF0YSA9IGNhY2hlLmdldChvYmplY3QpO1xuICBpZiAoIW1lbW9pemVkRGF0YSkge1xuICAgIG1lbW9pemVkRGF0YSA9IHtcbiAgICAgIFtrZXldOiBmbigpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQob2JqZWN0LCBtZW1vaXplZERhdGEpO1xuICB9IGVsc2UgaWYgKCEoa2V5IGluIG1lbW9pemVkRGF0YSkpIHtcbiAgICBtZW1vaXplZERhdGFba2V5XSA9IGZuKCk7XG4gIH1cbiAgcmV0dXJuIG1lbW9pemVkRGF0YVtrZXldO1xufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fTtcbmNvbnN0IHRvU2VyaWFsaXphYmxlQWN0aW9uID0gYWN0aW9uID0+IHtcbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFjdGlvblxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoJ3Jlc29sdmUnIGluIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogYWN0aW9uLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhY3Rpb24ubmFtZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFjdGlvbjtcbn07XG5jbGFzcyBTdGF0ZU5vZGUge1xuICBjb25zdHJ1Y3RvcigvKiogVGhlIHJhdyBjb25maWcgdXNlZCB0byBjcmVhdGUgdGhlIG1hY2hpbmUuICovXG4gIGNvbmZpZywgb3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBrZXkgb2YgdGhlIHN0YXRlIG5vZGUsIHdoaWNoIHJlcHJlc2VudHMgaXRzIGxvY2F0aW9uIGluIHRoZVxuICAgICAqIG92ZXJhbGwgc3RhdGUgdmFsdWUuXG4gICAgICovXG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHN0YXRlIG5vZGU6XG4gICAgICpcbiAgICAgKiAtIGAnYXRvbWljJ2AgLSBubyBjaGlsZCBzdGF0ZSBub2Rlc1xuICAgICAqIC0gYCdjb21wb3VuZCdgIC0gbmVzdGVkIGNoaWxkIHN0YXRlIG5vZGVzIChYT1IpXG4gICAgICogLSBgJ3BhcmFsbGVsJ2AgLSBvcnRob2dvbmFsIG5lc3RlZCBjaGlsZCBzdGF0ZSBub2RlcyAoQU5EKVxuICAgICAqIC0gYCdoaXN0b3J5J2AgLSBoaXN0b3J5IHN0YXRlIG5vZGVcbiAgICAgKiAtIGAnZmluYWwnYCAtIGZpbmFsIHN0YXRlIG5vZGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBzdHJpbmcgcGF0aCBmcm9tIHRoZSByb290IG1hY2hpbmUgbm9kZSB0byB0aGlzIG5vZGUuICovXG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgY2hpbGQgc3RhdGUgbm9kZXMuICovXG4gICAgdGhpcy5zdGF0ZXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgaGlzdG9yeSBvbiB0aGlzIHN0YXRlIG5vZGUuIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0gYCdzaGFsbG93J2AgLSByZWNhbGxzIG9ubHkgdG9wLWxldmVsIGhpc3RvcmljYWwgc3RhdGUgdmFsdWVcbiAgICAgKiAtIGAnZGVlcCdgIC0gcmVjYWxscyBoaXN0b3JpY2FsIHN0YXRlIHZhbHVlIGF0IGFsbCBsZXZlbHNcbiAgICAgKi9cbiAgICB0aGlzLmhpc3RvcnkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBhY3Rpb24ocykgdG8gYmUgZXhlY3V0ZWQgdXBvbiBlbnRlcmluZyB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmVudHJ5ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgYWN0aW9uKHMpIHRvIGJlIGV4ZWN1dGVkIHVwb24gZXhpdGluZyB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmV4aXQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBwYXJlbnQgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHJvb3QgbWFjaGluZSBub2RlLiAqL1xuICAgIHRoaXMubWFjaGluZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgbWV0YSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0YXRlIG5vZGUsIHdoaWNoIHdpbGwgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBTdGF0ZSBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgZGF0YSBzZW50IHdpdGggdGhlIFwieHN0YXRlLmRvbmUuc3RhdGUuX2lkX1wiIGV2ZW50IGlmIHRoaXMgaXMgYVxuICAgICAqIGZpbmFsIHN0YXRlIG5vZGUuXG4gICAgICovXG4gICAgdGhpcy5vdXRwdXQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIHRoaXMgc3RhdGUgbm9kZSBhcHBlYXJzLiBDb3JyZXNwb25kcyB0byB0aGUgaW1wbGljaXQgZG9jdW1lbnRcbiAgICAgKiBvcmRlci5cbiAgICAgKi9cbiAgICB0aGlzLm9yZGVyID0gLTE7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWx3YXlzID0gdm9pZCAwO1xuICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5fcGFyZW50O1xuICAgIHRoaXMua2V5ID0gb3B0aW9ucy5fa2V5O1xuICAgIHRoaXMubWFjaGluZSA9IG9wdGlvbnMuX21hY2hpbmU7XG4gICAgdGhpcy5wYXRoID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wYXRoLmNvbmNhdCh0aGlzLmtleSkgOiBbXTtcbiAgICB0aGlzLmlkID0gdGhpcy5jb25maWcuaWQgfHwgW3RoaXMubWFjaGluZS5pZCwgLi4udGhpcy5wYXRoXS5qb2luKFNUQVRFX0RFTElNSVRFUik7XG4gICAgdGhpcy50eXBlID0gdGhpcy5jb25maWcudHlwZSB8fCAodGhpcy5jb25maWcuc3RhdGVzICYmIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLnN0YXRlcykubGVuZ3RoID8gJ2NvbXBvdW5kJyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgPyAnaGlzdG9yeScgOiAnYXRvbWljJyk7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHRoaXMuY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMub3JkZXIgPSB0aGlzLm1hY2hpbmUuaWRNYXAuc2l6ZTtcbiAgICB0aGlzLm1hY2hpbmUuaWRNYXAuc2V0KHRoaXMuaWQsIHRoaXMpO1xuICAgIHRoaXMuc3RhdGVzID0gdGhpcy5jb25maWcuc3RhdGVzID8gbWFwVmFsdWVzKHRoaXMuY29uZmlnLnN0YXRlcywgKHN0YXRlQ29uZmlnLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IG5ldyBTdGF0ZU5vZGUoc3RhdGVDb25maWcsIHtcbiAgICAgICAgX3BhcmVudDogdGhpcyxcbiAgICAgICAgX2tleToga2V5LFxuICAgICAgICBfbWFjaGluZTogdGhpcy5tYWNoaW5lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGU7XG4gICAgfSkgOiBFTVBUWV9PQkpFQ1Q7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAhdGhpcy5jb25maWcuaW5pdGlhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbml0aWFsIHN0YXRlIHNwZWNpZmllZCBmb3IgY29tcG91bmQgc3RhdGUgbm9kZSBcIiMke3RoaXMuaWR9XCIuIFRyeSBhZGRpbmcgeyBpbml0aWFsOiBcIiR7T2JqZWN0LmtleXModGhpcy5zdGF0ZXMpWzBdfVwiIH0gdG8gdGhlIHN0YXRlIGNvbmZpZy5gKTtcbiAgICB9XG5cbiAgICAvLyBIaXN0b3J5IGNvbmZpZ1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuY29uZmlnLmhpc3RvcnkgPT09IHRydWUgPyAnc2hhbGxvdycgOiB0aGlzLmNvbmZpZy5oaXN0b3J5IHx8IGZhbHNlO1xuICAgIHRoaXMuZW50cnkgPSB0b0FycmF5KHRoaXMuY29uZmlnLmVudHJ5KS5zbGljZSgpO1xuICAgIHRoaXMuZXhpdCA9IHRvQXJyYXkodGhpcy5jb25maWcuZXhpdCkuc2xpY2UoKTtcbiAgICB0aGlzLm1ldGEgPSB0aGlzLmNvbmZpZy5tZXRhO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy50eXBlID09PSAnZmluYWwnIHx8ICF0aGlzLnBhcmVudCA/IHRoaXMuY29uZmlnLm91dHB1dCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRhZ3MgPSB0b0FycmF5KGNvbmZpZy50YWdzKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gZm9ybWF0VHJhbnNpdGlvbnModGhpcyk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmFsd2F5cykge1xuICAgICAgdGhpcy5hbHdheXMgPSB0b1RyYW5zaXRpb25Db25maWdBcnJheSh0aGlzLmNvbmZpZy5hbHdheXMpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24odGhpcywgTlVMTF9FVkVOVCwgdCkpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLnN0YXRlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZXNba2V5XS5faW5pdGlhbGl6ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRoZSB3ZWxsLXN0cnVjdHVyZWQgc3RhdGUgbm9kZSBkZWZpbml0aW9uLiAqL1xuICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5tYWNoaW5lLnZlcnNpb24sXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBpbml0aWFsOiB0aGlzLmluaXRpYWwgPyB7XG4gICAgICAgIHRhcmdldDogdGhpcy5pbml0aWFsLnRhcmdldCxcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBhY3Rpb25zOiB0aGlzLmluaXRpYWwuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgICBldmVudFR5cGU6IG51bGwsXG4gICAgICAgIHJlZW50ZXI6IGZhbHNlLFxuICAgICAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmluaXRpYWwudGFyZ2V0Lm1hcCh0ID0+IGAjJHt0LmlkfWApLFxuICAgICAgICAgIHNvdXJjZTogYCMke3RoaXMuaWR9YCxcbiAgICAgICAgICBhY3Rpb25zOiB0aGlzLmluaXRpYWwuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgICAgIGV2ZW50VHlwZTogbnVsbFxuICAgICAgICB9KVxuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIHN0YXRlczogbWFwVmFsdWVzKHRoaXMuc3RhdGVzLCBzdGF0ZSA9PiB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kZWZpbml0aW9uO1xuICAgICAgfSksXG4gICAgICBvbjogdGhpcy5vbixcbiAgICAgIHRyYW5zaXRpb25zOiBbLi4udGhpcy50cmFuc2l0aW9ucy52YWx1ZXMoKV0uZmxhdCgpLm1hcCh0ID0+ICh7XG4gICAgICAgIC4uLnQsXG4gICAgICAgIGFjdGlvbnM6IHQuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pXG4gICAgICB9KSksXG4gICAgICBlbnRyeTogdGhpcy5lbnRyeS5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgZXhpdDogdGhpcy5leGl0Lm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICBtZXRhOiB0aGlzLm1ldGEsXG4gICAgICBvcmRlcjogdGhpcy5vcmRlciB8fCAtMSxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBpbnZva2U6IHRoaXMuaW52b2tlLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICB0YWdzOiB0aGlzLnRhZ3NcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuXG4gIC8qKiBUaGUgbG9naWMgaW52b2tlZCBhcyBhY3RvcnMgYnkgdGhpcyBzdGF0ZSBub2RlLiAqL1xuICBnZXQgaW52b2tlKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdpbnZva2UnLCAoKSA9PiB0b0FycmF5KHRoaXMuY29uZmlnLmludm9rZSkubWFwKChpbnZva2VDb25maWcsIGkpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3JjLFxuICAgICAgICBzeXN0ZW1JZFxuICAgICAgfSA9IGludm9rZUNvbmZpZztcbiAgICAgIGNvbnN0IHJlc29sdmVkSWQgPSBpbnZva2VDb25maWcuaWQgPz8gY3JlYXRlSW52b2tlSWQodGhpcy5pZCwgaSk7XG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBgeHN0YXRlLmludm9rZS4ke2NyZWF0ZUludm9rZUlkKHRoaXMuaWQsIGkpfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbnZva2VDb25maWcsXG4gICAgICAgIHNyYzogc291cmNlTmFtZSxcbiAgICAgICAgaWQ6IHJlc29sdmVkSWQsXG4gICAgICAgIHN5c3RlbUlkOiBzeXN0ZW1JZCxcbiAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9uRG9uZSxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAuLi5pbnZva2VEZWZWYWx1ZXNcbiAgICAgICAgICB9ID0gaW52b2tlQ29uZmlnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pbnZva2VEZWZWYWx1ZXMsXG4gICAgICAgICAgICB0eXBlOiAneHN0YXRlLmludm9rZScsXG4gICAgICAgICAgICBzcmM6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICBpZDogcmVzb2x2ZWRJZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqIFRoZSBtYXBwaW5nIG9mIGV2ZW50cyB0byB0cmFuc2l0aW9ucy4gKi9cbiAgZ2V0IG9uKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9ucztcbiAgICAgIHJldHVybiBbLi4udHJhbnNpdGlvbnNdLmZsYXRNYXAoKFtkZXNjcmlwdG9yLCB0XSkgPT4gdC5tYXAodCA9PiBbZGVzY3JpcHRvciwgdF0pKS5yZWR1Y2UoKG1hcCwgW2Rlc2NyaXB0b3IsIHRyYW5zaXRpb25dKSA9PiB7XG4gICAgICAgIG1hcFtkZXNjcmlwdG9yXSA9IG1hcFtkZXNjcmlwdG9yXSB8fCBbXTtcbiAgICAgICAgbWFwW2Rlc2NyaXB0b3JdLnB1c2godHJhbnNpdGlvbik7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9LCB7fSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGFmdGVyKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdkZWxheWVkVHJhbnNpdGlvbnMnLCAoKSA9PiBnZXREZWxheWVkVHJhbnNpdGlvbnModGhpcykpO1xuICB9XG4gIGdldCBpbml0aWFsKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdpbml0aWFsJywgKCkgPT4gZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24odGhpcywgdGhpcy5jb25maWcuaW5pdGlhbCkpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZXh0KHNuYXBzaG90LCBldmVudCkge1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgIGxldCBzZWxlY3RlZFRyYW5zaXRpb247XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IG1lbW8odGhpcywgYGNhbmRpZGF0ZXMtJHtldmVudFR5cGV9YCwgKCkgPT4gZ2V0Q2FuZGlkYXRlcyh0aGlzLCBldmVudFR5cGUpKTtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGd1YXJkXG4gICAgICB9ID0gY2FuZGlkYXRlO1xuICAgICAgY29uc3QgcmVzb2x2ZWRDb250ZXh0ID0gc25hcHNob3QuY29udGV4dDtcbiAgICAgIGxldCBndWFyZFBhc3NlZCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ3VhcmRQYXNzZWQgPSAhZ3VhcmQgfHwgZXZhbHVhdGVHdWFyZChndWFyZCwgcmVzb2x2ZWRDb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGd1YXJkVHlwZSA9IHR5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IHR5cGVvZiBndWFyZCA9PT0gJ29iamVjdCcgPyBndWFyZC50eXBlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBldmFsdWF0ZSBndWFyZCAke2d1YXJkVHlwZSA/IGAnJHtndWFyZFR5cGV9JyBgIDogJyd9aW4gdHJhbnNpdGlvbiBmb3IgZXZlbnQgJyR7ZXZlbnRUeXBlfScgaW4gc3RhdGUgbm9kZSAnJHt0aGlzLmlkfSc6XFxuJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZFBhc3NlZCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goLi4uY2FuZGlkYXRlLmFjdGlvbnMpO1xuICAgICAgICBzZWxlY3RlZFRyYW5zaXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRUcmFuc2l0aW9uID8gW3NlbGVjdGVkVHJhbnNpdGlvbl0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKiogQWxsIHRoZSBldmVudCB0eXBlcyBhY2NlcHRlZCBieSB0aGlzIHN0YXRlIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cy4gKi9cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnZXZlbnRzJywgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGF0ZXNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgZXZlbnRzID0gbmV3IFNldCh0aGlzLm93bkV2ZW50cyk7XG4gICAgICBpZiAoc3RhdGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGVJZCBvZiBPYmplY3Qua2V5cyhzdGF0ZXMpKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXNbc3RhdGVJZF07XG4gICAgICAgICAgaWYgKHN0YXRlLnN0YXRlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBzdGF0ZS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgZXZlbnRzLmFkZChgJHtldmVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsIHRoZSBldmVudHMgdGhhdCBoYXZlIHRyYW5zaXRpb25zIGRpcmVjdGx5IGZyb20gdGhpcyBzdGF0ZSBub2RlLlxuICAgKlxuICAgKiBFeGNsdWRlcyBhbnkgaW5lcnQgZXZlbnRzLlxuICAgKi9cbiAgZ2V0IG93bkV2ZW50cygpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMudHJhbnNpdGlvbnMpKTtcbiAgICBjb25zdCBldmVudHMgPSBuZXcgU2V0KGtleXMuZmlsdGVyKGRlc2NyaXB0b3IgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbnMuZ2V0KGRlc2NyaXB0b3IpLnNvbWUodHJhbnNpdGlvbiA9PiAhKCF0cmFuc2l0aW9uLnRhcmdldCAmJiAhdHJhbnNpdGlvbi5hY3Rpb25zLmxlbmd0aCAmJiAhdHJhbnNpdGlvbi5yZWVudGVyKSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cyk7XG4gIH1cbn1cblxuY29uc3QgU1RBVEVfSURFTlRJRklFUiA9ICcjJztcbmNsYXNzIFN0YXRlTWFjaGluZSB7XG4gIGNvbnN0cnVjdG9yKC8qKiBUaGUgcmF3IGNvbmZpZyB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFjaGluZS4gKi9cbiAgY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAvKiogVGhlIG1hY2hpbmUncyBvd24gdmVyc2lvbi4gKi9cbiAgICB0aGlzLnZlcnNpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlbWFzID0gdm9pZCAwO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb25zID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9feHN0YXRlbm9kZSA9IHRydWU7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuaWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yb290ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5ldmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IGNvbmZpZy5pZCB8fCAnKG1hY2hpbmUpJztcbiAgICB0aGlzLmltcGxlbWVudGF0aW9ucyA9IHtcbiAgICAgIGFjdG9yczogaW1wbGVtZW50YXRpb25zPy5hY3RvcnMgPz8ge30sXG4gICAgICBhY3Rpb25zOiBpbXBsZW1lbnRhdGlvbnM/LmFjdGlvbnMgPz8ge30sXG4gICAgICBkZWxheXM6IGltcGxlbWVudGF0aW9ucz8uZGVsYXlzID8/IHt9LFxuICAgICAgZ3VhcmRzOiBpbXBsZW1lbnRhdGlvbnM/Lmd1YXJkcyA/PyB7fVxuICAgIH07XG4gICAgdGhpcy52ZXJzaW9uID0gdGhpcy5jb25maWcudmVyc2lvbjtcbiAgICB0aGlzLnNjaGVtYXMgPSB0aGlzLmNvbmZpZy5zY2hlbWFzO1xuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0SW5pdGlhbFNuYXBzaG90ID0gdGhpcy5nZXRJbml0aWFsU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldFBlcnNpc3RlZFNuYXBzaG90ID0gdGhpcy5nZXRQZXJzaXN0ZWRTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzdG9yZVNuYXBzaG90ID0gdGhpcy5yZXN0b3JlU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucm9vdCA9IG5ldyBTdGF0ZU5vZGUoY29uZmlnLCB7XG4gICAgICBfa2V5OiB0aGlzLmlkLFxuICAgICAgX21hY2hpbmU6IHRoaXNcbiAgICB9KTtcbiAgICB0aGlzLnJvb3QuX2luaXRpYWxpemUoKTtcbiAgICB0aGlzLnN0YXRlcyA9IHRoaXMucm9vdC5zdGF0ZXM7IC8vIFRPRE86IHJlbW92ZSFcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMucm9vdC5ldmVudHM7XG4gICAgaWYgKCEoJ291dHB1dCcgaW4gdGhpcy5yb290KSAmJiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGVzKS5zb21lKHN0YXRlID0+IHN0YXRlLnR5cGUgPT09ICdmaW5hbCcgJiYgJ291dHB1dCcgaW4gc3RhdGUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ01pc3NpbmcgYG1hY2hpbmUub3V0cHV0YCBkZWNsYXJhdGlvbiAodG9wLWxldmVsIGZpbmFsIHN0YXRlIHdpdGggb3V0cHV0IGRldGVjdGVkKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGltcGxlbWVudGF0aW9ucyBPcHRpb25zIChgYWN0aW9uc2AsIGBndWFyZHNgLCBgYWN0b3JzYCwgYGRlbGF5c2ApIHRvXG4gICAqICAgcmVjdXJzaXZlbHkgbWVyZ2Ugd2l0aCB0aGUgZXhpc3Rpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMgQSBuZXcgYFN0YXRlTWFjaGluZWAgaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgaW1wbGVtZW50YXRpb25zLlxuICAgKi9cbiAgcHJvdmlkZShpbXBsZW1lbnRhdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb25zLFxuICAgICAgZ3VhcmRzLFxuICAgICAgYWN0b3JzLFxuICAgICAgZGVsYXlzXG4gICAgfSA9IHRoaXMuaW1wbGVtZW50YXRpb25zO1xuICAgIHJldHVybiBuZXcgU3RhdGVNYWNoaW5lKHRoaXMuY29uZmlnLCB7XG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIC4uLmFjdGlvbnMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5hY3Rpb25zXG4gICAgICB9LFxuICAgICAgZ3VhcmRzOiB7XG4gICAgICAgIC4uLmd1YXJkcyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmd1YXJkc1xuICAgICAgfSxcbiAgICAgIGFjdG9yczoge1xuICAgICAgICAuLi5hY3RvcnMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5hY3RvcnNcbiAgICAgIH0sXG4gICAgICBkZWxheXM6IHtcbiAgICAgICAgLi4uZGVsYXlzLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuZGVsYXlzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzb2x2ZVN0YXRlKGNvbmZpZykge1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVWYWx1ZSA9IHJlc29sdmVTdGF0ZVZhbHVlKHRoaXMucm9vdCwgY29uZmlnLnZhbHVlKTtcbiAgICBjb25zdCBub2RlU2V0ID0gZ2V0QWxsU3RhdGVOb2RlcyhnZXRTdGF0ZU5vZGVzKHRoaXMucm9vdCwgcmVzb2x2ZWRTdGF0ZVZhbHVlKSk7XG4gICAgcmV0dXJuIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCh7XG4gICAgICBfbm9kZXM6IFsuLi5ub2RlU2V0XSxcbiAgICAgIGNvbnRleHQ6IGNvbmZpZy5jb250ZXh0IHx8IHt9LFxuICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgc3RhdHVzOiBpc0luRmluYWxTdGF0ZShub2RlU2V0LCB0aGlzLnJvb3QpID8gJ2RvbmUnIDogY29uZmlnLnN0YXR1cyB8fCAnYWN0aXZlJyxcbiAgICAgIG91dHB1dDogY29uZmlnLm91dHB1dCxcbiAgICAgIGVycm9yOiBjb25maWcuZXJyb3IsXG4gICAgICBoaXN0b3J5VmFsdWU6IGNvbmZpZy5oaXN0b3J5VmFsdWVcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHNuYXBzaG90IGdpdmVuIHRoZSBjdXJyZW50IGBzbmFwc2hvdGAgYW5kIHJlY2VpdmVkXG4gICAqIGBldmVudGAuIENhbGN1bGF0ZXMgYSBmdWxsIG1hY3Jvc3RlcCBmcm9tIGFsbCBtaWNyb3N0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0gc25hcHNob3QgVGhlIGN1cnJlbnQgc25hcHNob3RcbiAgICogQHBhcmFtIGV2ZW50IFRoZSByZWNlaXZlZCBldmVudFxuICAgKi9cbiAgdHJhbnNpdGlvbihzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpIHtcbiAgICByZXR1cm4gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgW10pLnNuYXBzaG90O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG5leHQgc3RhdGUgZ2l2ZW4gdGhlIGN1cnJlbnQgYHN0YXRlYCBhbmQgYGV2ZW50YC4gQ2FsY3VsYXRlc1xuICAgKiBhIG1pY3Jvc3RlcC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIFRoZSBjdXJyZW50IHN0YXRlXG4gICAqIEBwYXJhbSBldmVudCBUaGUgcmVjZWl2ZWQgZXZlbnRcbiAgICovXG4gIG1pY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpIHtcbiAgICByZXR1cm4gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgW10pLm1pY3Jvc3RhdGVzO1xuICB9XG4gIGdldFRyYW5zaXRpb25EYXRhKHNuYXBzaG90LCBldmVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTm9kZSh0aGlzLnJvb3QsIHNuYXBzaG90LnZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIHN0YXRlIF9iZWZvcmVfIGV2YWx1YXRpbmcgYW55IG1pY3Jvc3RlcHMuIFRoaXMgXCJwcmUtaW5pdGlhbFwiXG4gICAqIHN0YXRlIGlzIHByb3ZpZGVkIHRvIGluaXRpYWwgYWN0aW9ucyBleGVjdXRlZCBpbiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIGdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0XG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHByZUluaXRpYWwgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgY29udGV4dDogdHlwZW9mIGNvbnRleHQgIT09ICdmdW5jdGlvbicgJiYgY29udGV4dCA/IGNvbnRleHQgOiB7fSxcbiAgICAgIF9ub2RlczogW3RoaXMucm9vdF0sXG4gICAgICBjaGlsZHJlbjoge30sXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnXG4gICAgfSwgdGhpcyk7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBhc3NpZ25tZW50ID0gKHtcbiAgICAgICAgc3Bhd24sXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBzZWxmXG4gICAgICB9KSA9PiBjb250ZXh0KHtcbiAgICAgICAgc3Bhd24sXG4gICAgICAgIGlucHV0OiBldmVudC5pbnB1dCxcbiAgICAgICAgc2VsZlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KHByZUluaXRpYWwsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgW2Fzc2lnbihhc3NpZ25tZW50KV0sIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBwcmVJbml0aWFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgYFN0YXRlYCBpbnN0YW5jZSwgd2l0aCByZWZlcmVuY2UgdG8gYHNlbGZgIGFzIGFuXG4gICAqIGBBY3RvclJlZmAuXG4gICAqL1xuICBnZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpIHtcbiAgICBjb25zdCBpbml0RXZlbnQgPSBjcmVhdGVJbml0RXZlbnQoaW5wdXQpOyAvLyBUT0RPOiBmaXg7XG4gICAgY29uc3QgaW50ZXJuYWxRdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHByZUluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0UHJlSW5pdGlhbFN0YXRlKGFjdG9yU2NvcGUsIGluaXRFdmVudCwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gbWljcm9zdGVwKFt7XG4gICAgICB0YXJnZXQ6IFsuLi5nZXRJbml0aWFsU3RhdGVOb2Rlcyh0aGlzLnJvb3QpXSxcbiAgICAgIHNvdXJjZTogdGhpcy5yb290LFxuICAgICAgcmVlbnRlcjogdHJ1ZSxcbiAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgZXZlbnRUeXBlOiBudWxsLFxuICAgICAgdG9KU09OOiBudWxsIC8vIFRPRE86IGZpeFxuICAgIH1dLCBwcmVJbml0aWFsU3RhdGUsIGFjdG9yU2NvcGUsIGluaXRFdmVudCwgdHJ1ZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgY29uc3Qge1xuICAgICAgc25hcHNob3Q6IG1hY3JvU3RhdGVcbiAgICB9ID0gbWFjcm9zdGVwKG5leHRTdGF0ZSwgaW5pdEV2ZW50LCBhY3RvclNjb3BlLCBpbnRlcm5hbFF1ZXVlKTtcbiAgICByZXR1cm4gbWFjcm9TdGF0ZTtcbiAgfVxuICBzdGFydChzbmFwc2hvdCkge1xuICAgIE9iamVjdC52YWx1ZXMoc25hcHNob3QuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKGNoaWxkLmdldFNuYXBzaG90KCkuc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICBjaGlsZC5zdGFydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFN0YXRlTm9kZUJ5SWQoc3RhdGVJZCkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gdG9TdGF0ZVBhdGgoc3RhdGVJZCk7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gZnVsbFBhdGguc2xpY2UoMSk7XG4gICAgY29uc3QgcmVzb2x2ZWRTdGF0ZUlkID0gaXNTdGF0ZUlkKGZ1bGxQYXRoWzBdKSA/IGZ1bGxQYXRoWzBdLnNsaWNlKFNUQVRFX0lERU5USUZJRVIubGVuZ3RoKSA6IGZ1bGxQYXRoWzBdO1xuICAgIGNvbnN0IHN0YXRlTm9kZSA9IHRoaXMuaWRNYXAuZ2V0KHJlc29sdmVkU3RhdGVJZCk7XG4gICAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgc3RhdGUgbm9kZSAnIyR7cmVzb2x2ZWRTdGF0ZUlkfScgZG9lcyBub3QgZXhpc3Qgb24gbWFjaGluZSAnJHt0aGlzLmlkfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUsIHJlbGF0aXZlUGF0aCk7XG4gIH1cbiAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5kZWZpbml0aW9uO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uO1xuICB9XG4gIGdldFBlcnNpc3RlZFNuYXBzaG90KHNuYXBzaG90LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldFBlcnNpc3RlZFNuYXBzaG90KHNuYXBzaG90LCBvcHRpb25zKTtcbiAgfVxuICByZXN0b3JlU25hcHNob3Qoc25hcHNob3QsIF9hY3RvclNjb3BlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB7fTtcbiAgICBjb25zdCBzbmFwc2hvdENoaWxkcmVuID0gc25hcHNob3QuY2hpbGRyZW47XG4gICAgT2JqZWN0LmtleXMoc25hcHNob3RDaGlsZHJlbikuZm9yRWFjaChhY3RvcklkID0+IHtcbiAgICAgIGNvbnN0IGFjdG9yRGF0YSA9IHNuYXBzaG90Q2hpbGRyZW5bYWN0b3JJZF07XG4gICAgICBjb25zdCBjaGlsZFN0YXRlID0gYWN0b3JEYXRhLnNuYXBzaG90O1xuICAgICAgY29uc3Qgc3JjID0gYWN0b3JEYXRhLnNyYztcbiAgICAgIGNvbnN0IGxvZ2ljID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yKHRoaXMsIHNyYykgOiBzcmM7XG4gICAgICBpZiAoIWxvZ2ljKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgICAgaWQ6IGFjdG9ySWQsXG4gICAgICAgIHBhcmVudDogX2FjdG9yU2NvcGUuc2VsZixcbiAgICAgICAgc3luY1NuYXBzaG90OiBhY3RvckRhdGEuc3luY1NuYXBzaG90LFxuICAgICAgICBzbmFwc2hvdDogY2hpbGRTdGF0ZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBzeXN0ZW1JZDogYWN0b3JEYXRhLnN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIGNoaWxkcmVuW2FjdG9ySWRdID0gYWN0b3JSZWY7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUhpc3RvcnlSZWZlcmVuY2VkU3RhdGUocm9vdCwgcmVmZXJlbmNlZCkge1xuICAgICAgaWYgKHJlZmVyZW5jZWQgaW5zdGFuY2VvZiBTdGF0ZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZWQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcm9vdC5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQocmVmZXJlbmNlZC5pZCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHJlc29sdmUgU3RhdGVOb2RlIGZvciBpZDogJHtyZWZlcmVuY2VkLmlkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldml2ZUhpc3RvcnlWYWx1ZShyb290LCBoaXN0b3J5VmFsdWUpIHtcbiAgICAgIGlmICghaGlzdG9yeVZhbHVlIHx8IHR5cGVvZiBoaXN0b3J5VmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldml2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGhpc3RvcnlWYWx1ZSkge1xuICAgICAgICBjb25zdCBhcnIgPSBoaXN0b3J5VmFsdWVba2V5XTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUhpc3RvcnlSZWZlcmVuY2VkU3RhdGUocm9vdCwgaXRlbSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldml2ZWRba2V5XSA/Pz0gW107XG4gICAgICAgICAgcmV2aXZlZFtrZXldLnB1c2gocmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV2aXZlZDtcbiAgICB9XG4gICAgY29uc3QgcmV2aXZlZEhpc3RvcnlWYWx1ZSA9IHJldml2ZUhpc3RvcnlWYWx1ZSh0aGlzLnJvb3QsIHNuYXBzaG90Lmhpc3RvcnlWYWx1ZSk7XG4gICAgY29uc3QgcmVzdG9yZWRTbmFwc2hvdCA9IGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgX25vZGVzOiBBcnJheS5mcm9tKGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyh0aGlzLnJvb3QsIHNuYXBzaG90LnZhbHVlKSkpLFxuICAgICAgaGlzdG9yeVZhbHVlOiByZXZpdmVkSGlzdG9yeVZhbHVlXG4gICAgfSwgdGhpcyk7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiByZXZpdmVDb250ZXh0KGNvbnRleHRQYXJ0LCBjaGlsZHJlbikge1xuICAgICAgaWYgKHNlZW4uaGFzKGNvbnRleHRQYXJ0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWVuLmFkZChjb250ZXh0UGFydCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0UGFydCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHRQYXJ0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCd4c3RhdGUkJHR5cGUnIGluIHZhbHVlICYmIHZhbHVlLnhzdGF0ZSQkdHlwZSA9PT0gJCRBQ1RPUl9UWVBFKSB7XG4gICAgICAgICAgICBjb250ZXh0UGFydFtrZXldID0gY2hpbGRyZW5bdmFsdWUuaWRdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldml2ZUNvbnRleHQodmFsdWUsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXZpdmVDb250ZXh0KHJlc3RvcmVkU25hcHNob3QuY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIHJldHVybiByZXN0b3JlZFNuYXBzaG90O1xuICB9XG59XG5cbmV4cG9ydCB7IFN0YXRlTWFjaGluZSBhcyBTLCBTdGF0ZU5vZGUgYXMgYSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/StateMachine-d0e98d09.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/assign-541a432d.development.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/xstate/dist/assign-541a432d.development.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ assign)\n/* harmony export */ });\n/* harmony import */ var _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-13a60c49.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-13a60c49.development.esm.js\");\n\n\nfunction createSpawner(actorScope, {\n  machine,\n  context\n}, event, spawnedChildren) {\n  const spawn = (src, options) => {\n    if (typeof src === 'string') {\n      const logic = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T)(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(logic, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: typeof options?.input === 'function' ? options.input({\n          context,\n          event,\n          self: actorScope.self\n        }) : options?.input,\n        src,\n        systemId: options?.systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(src, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: options?.input,\n        src,\n        systemId: options?.systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\n\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\n  assignment\n}) {\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [(0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Z)(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  }), undefined, undefined];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nfunction assign(assignment) {\n  if (_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U) {\n    console.warn('Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function assign(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvYXNzaWduLTU0MWE0MzJkLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrTDs7QUFFbEw7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxvQkFBb0IscUVBQXNCO0FBQzFDO0FBQ0Esd0NBQXdDLElBQUksZ0NBQWdDLFdBQVc7QUFDdkY7QUFDQSx1QkFBdUIscUVBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QixxRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHlDQUF5QyxpRUFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxVQUFVLHFFQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRUFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2F2ZWRpYW4tbmV3c3Jvb20vLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvYXNzaWduLTU0MWE0MzJkLmRldmVsb3BtZW50LmVzbS5qcz84MDVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFkgYXMgUHJvY2Vzc2luZ1N0YXR1cywgVCBhcyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yLCBjIGFzIGNyZWF0ZUFjdG9yLCBaIGFzIGNsb25lTWFjaGluZVNuYXBzaG90LCBVIGFzIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiB9IGZyb20gJy4vcmFpc2UtMTNhNjBjNDkuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlU3Bhd25lcihhY3RvclNjb3BlLCB7XG4gIG1hY2hpbmUsXG4gIGNvbnRleHRcbn0sIGV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pIHtcbiAgY29uc3Qgc3Bhd24gPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb2dpYyA9IHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKTtcbiAgICAgIGlmICghbG9naWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3RvciBsb2dpYyAnJHtzcmN9JyBub3QgaW1wbGVtZW50ZWQgaW4gbWFjaGluZSAnJHttYWNoaW5lLmlkfSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgICAgaWQ6IG9wdGlvbnM/LmlkLFxuICAgICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgICAgc3luY1NuYXBzaG90OiBvcHRpb25zPy5zeW5jU25hcHNob3QsXG4gICAgICAgIGlucHV0OiB0eXBlb2Ygb3B0aW9ucz8uaW5wdXQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmlucHV0KHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgICAgICB9KSA6IG9wdGlvbnM/LmlucHV0LFxuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkOiBvcHRpb25zPy5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgICByZXR1cm4gYWN0b3JSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3Ioc3JjLCB7XG4gICAgICAgIGlkOiBvcHRpb25zPy5pZCxcbiAgICAgICAgcGFyZW50OiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogb3B0aW9ucz8uc3luY1NuYXBzaG90LFxuICAgICAgICBpbnB1dDogb3B0aW9ucz8uaW5wdXQsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IG9wdGlvbnM/LnN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RvclJlZjtcbiAgICB9XG4gIH07XG4gIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYWN0b3JSZWYgPSBzcGF3bihzcmMsIG9wdGlvbnMpOyAvLyBUT0RPOiBmaXggdHlwZXNcbiAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhY3RvclJlZi5zdGFydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3RvclJlZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzc2lnbihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGFzc2lnbm1lbnRcbn0pIHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIHVuZGVmaW5lZCBgY29udGV4dGAuIEVuc3VyZSB0aGF0IGBjb250ZXh0YCBpcyBkZWZpbmVkIGluIHRoZSBtYWNoaW5lIGNvbmZpZy4nKTtcbiAgfVxuICBjb25zdCBzcGF3bmVkQ2hpbGRyZW4gPSB7fTtcbiAgY29uc3QgYXNzaWduQXJncyA9IHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGV2ZW50OiBhY3Rpb25BcmdzLmV2ZW50LFxuICAgIHNwYXduOiBjcmVhdGVTcGF3bmVyKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLmV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH07XG4gIGxldCBwYXJ0aWFsVXBkYXRlID0ge307XG4gIGlmICh0eXBlb2YgYXNzaWdubWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcnRpYWxVcGRhdGUgPSBhc3NpZ25tZW50KGFzc2lnbkFyZ3MsIGFjdGlvblBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXNzaWdubWVudCkpIHtcbiAgICAgIGNvbnN0IHByb3BBc3NpZ25tZW50ID0gYXNzaWdubWVudFtrZXldO1xuICAgICAgcGFydGlhbFVwZGF0ZVtrZXldID0gdHlwZW9mIHByb3BBc3NpZ25tZW50ID09PSAnZnVuY3Rpb24nID8gcHJvcEFzc2lnbm1lbnQoYXNzaWduQXJncywgYWN0aW9uUGFyYW1zKSA6IHByb3BBc3NpZ25tZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCB1cGRhdGVkQ29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHNuYXBzaG90LmNvbnRleHQsIHBhcnRpYWxVcGRhdGUpO1xuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY29udGV4dDogdXBkYXRlZENvbnRleHQsXG4gICAgY2hpbGRyZW46IE9iamVjdC5rZXlzKHNwYXduZWRDaGlsZHJlbikubGVuZ3RoID8ge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICAuLi5zcGF3bmVkQ2hpbGRyZW5cbiAgICB9IDogc25hcHNob3QuY2hpbGRyZW5cbiAgfSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBtYWNoaW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGFzc2lnbiB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgY291bnRNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGNvbnRleHQ6IHtcbiAqICAgICBjb3VudDogMCxcbiAqICAgICBtZXNzYWdlOiAnJ1xuICogICB9LFxuICogICBvbjoge1xuICogICAgIGluYzoge1xuICogICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAqICAgICAgICAgY291bnQ6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5jb3VudCArIDFcbiAqICAgICAgIH0pXG4gKiAgICAgfSxcbiAqICAgICB1cGRhdGVNZXNzYWdlOiB7XG4gKiAgICAgICBhY3Rpb25zOiBhc3NpZ24oKHsgY29udGV4dCwgZXZlbnQgfSkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UudHJpbSgpXG4gKiAgICAgICAgIH07XG4gKiAgICAgICB9KVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXNzaWdubWVudCBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG8gdXBkYXRlLCBvclxuICogICBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG9cbiAqICAgdXBkYXRlLlxuICovXG5mdW5jdGlvbiBhc3NpZ24oYXNzaWdubWVudCkge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYGFzc2lnbigpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBhc3NpZ24oX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFzc2lnbi50eXBlID0gJ3hzdGF0ZS5hc3NpZ24nO1xuICBhc3NpZ24uYXNzaWdubWVudCA9IGFzc2lnbm1lbnQ7XG4gIGFzc2lnbi5yZXNvbHZlID0gcmVzb2x2ZUFzc2lnbjtcbiAgcmV0dXJuIGFzc2lnbjtcbn1cblxuZXhwb3J0IHsgYXNzaWduIGFzIGEgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/assign-541a432d.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/log-b8ca474e.development.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/xstate/dist/log-b8ca474e.development.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ SpecialTargets),\n/* harmony export */   a: () => (/* binding */ emit),\n/* harmony export */   b: () => (/* binding */ sendParent),\n/* harmony export */   e: () => (/* binding */ enqueueActions),\n/* harmony export */   f: () => (/* binding */ forwardTo),\n/* harmony export */   l: () => (/* binding */ log),\n/* harmony export */   s: () => (/* binding */ sendTo)\n/* harmony export */ });\n/* harmony import */ var _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-13a60c49.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-13a60c49.development.esm.js\");\n/* harmony import */ var _assign_541a432d_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assign-541a432d.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-541a432d.development.esm.js\");\n\n\n\nfunction resolveEmit(_, snapshot, args, actionParams, {\n  event: eventOrExpr\n}) {\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }, undefined];\n}\nfunction executeEmit(actorScope, {\n  event\n}) {\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */\nfunction emit(/** The event to emit, or an expression that returns an event to emit. */\neventOrExpr) {\n  if (_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U) {\n    console.warn('Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function emit(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n// this is needed to make JSDoc `@link` work properly\n\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: we can't use native `NoInfer` as we need those:\n// https://github.com/microsoft/TypeScript/pull/61092\n// https://github.com/microsoft/TypeScript/pull/61077\n// but even with those fixes native NoInfer still doesn't work - further issues have to be reproduced and fixed\n\n/** @deprecated Use the built-in `NoInfer` type instead */\n\n/** The full definition of an event, with a string `type`. */\n\n/**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */\n\n/** @deprecated Use `AnyMachineSnapshot` instead */\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */\n\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/** @deprecated Use `AnyActor` instead. */\n\n// Based on RxJS types\n\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n\n/** @deprecated Use `Actor<T>` instead. */\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\n\n/** @deprecated */\n\n// TODO: cover all that can be actually returned\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, {\n  to,\n  event: eventOrExpr,\n  id,\n  delay\n}, extra) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    targetId: typeof resolvedTarget === 'string' ? resolvedTarget : undefined,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }, undefined];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V ? (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.W)(actorScope.self.id, event.data) : event);\n  });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */\nfunction sendTo(to, eventOrExpr, options) {\n  if (_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U) {\n    console.warn('Custom actions should not call `sendTo()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function sendTo(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  sendTo.type = 'xstate.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nfunction forwardTo(target, options) {\n  if ((!target || typeof target === 'function')) {\n    const originalTarget = target;\n    target = (...args) => {\n      const resolvedTarget = typeof originalTarget === 'function' ? originalTarget(...args) : originalTarget;\n      if (!resolvedTarget) {\n        throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\n      }\n      return resolvedTarget;\n    };\n  }\n  return sendTo(target, ({\n    event\n  }) => event, options);\n}\n\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, {\n  collect\n}) {\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = (...args) => {\n    actions.push((0,_assign_541a432d_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(...args));\n  };\n  enqueue.cancel = (...args) => {\n    actions.push((0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(...args));\n  };\n  enqueue.raise = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push((0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)(...args));\n  };\n  enqueue.sendTo = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...args));\n  };\n  enqueue.sendParent = (...args) => {\n    actions.push(sendParent(...args));\n  };\n  enqueue.spawnChild = (...args) => {\n    actions.push((0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(...args));\n  };\n  enqueue.stopChild = (...args) => {\n    actions.push((0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)(...args));\n  };\n  enqueue.emit = (...args) => {\n    actions.push(emit(...args));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\n\nfunction resolveLog(_, snapshot, actionArgs, actionParams, {\n  value,\n  label\n}) {\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }, undefined];\n}\nfunction executeLog({\n  logger\n}, {\n  value,\n  label\n}) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */\nfunction log(value = ({\n  context,\n  event\n}) => ({\n  context,\n  event\n}), label) {\n  function log(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvbG9nLWI4Y2E0NzRlLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOE07QUFDM0k7O0FBRW5FO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRUFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCx1QkFBdUI7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYSxTQUFTLFlBQVksR0FBRztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZSxrQkFBa0Isb0JBQW9CO0FBQzdHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFZLEdBQUcscUVBQXFCO0FBQzNELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUVBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNFQUFNO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIscUVBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUVBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUVBQVU7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQixxRUFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFFQUFhO0FBQ2pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdmVkaWFuLW5ld3Nyb29tLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L2xvZy1iOGNhNDc0ZS5kZXZlbG9wbWVudC5lc20uanM/MTYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVIGFzIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiwgViBhcyBYU1RBVEVfRVJST1IsIFcgYXMgY3JlYXRlRXJyb3JBY3RvckV2ZW50LCB4IGFzIGV2YWx1YXRlR3VhcmQsIGEgYXMgY2FuY2VsLCByIGFzIHJhaXNlLCBiIGFzIHNwYXduQ2hpbGQsIHMgYXMgc3RvcENoaWxkIH0gZnJvbSAnLi9yYWlzZS0xM2E2MGM0OS5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuL2Fzc2lnbi01NDFhNDMyZC5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlRW1pdChfLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGV2ZW50OiBldmVudE9yRXhwclxufSkge1xuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnRcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVFbWl0KGFjdG9yU2NvcGUsIHtcbiAgZXZlbnRcbn0pIHtcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiBhY3RvclNjb3BlLmVtaXQoZXZlbnQpKTtcbn1cbi8qKlxuICogRW1pdHMgYW4gZXZlbnQgdG8gZXZlbnQgaGFuZGxlcnMgcmVnaXN0ZXJlZCBvbiB0aGUgYWN0b3IgdmlhIGBhY3Rvci5vbihldmVudCxcbiAqIGhhbmRsZXIpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBlbWl0IH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIC8vIC4uLlxuICogICBvbjoge1xuICogICAgIHNvbWV0aGluZzoge1xuICogICAgICAgYWN0aW9uczogZW1pdCh7XG4gKiAgICAgICAgIHR5cGU6ICdlbWl0dGVkJyxcbiAqICAgICAgICAgc29tZTogJ2RhdGEnXG4gKiAgICAgICB9KVxuICogICAgIH1cbiAqICAgfVxuICogICAvLyAuLi5cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSkuc3RhcnQoKTtcbiAqXG4gKiBhY3Rvci5vbignZW1pdHRlZCcsIChldmVudCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhldmVudCk7XG4gKiB9KTtcbiAqXG4gKiBhY3Rvci5zZW5kKHsgdHlwZTogJ3NvbWV0aGluZycgfSk7XG4gKiAvLyBsb2dzOlxuICogLy8ge1xuICogLy8gICB0eXBlOiAnZW1pdHRlZCcsXG4gKiAvLyAgIHNvbWU6ICdkYXRhJ1xuICogLy8gfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVtaXQoLyoqIFRoZSBldmVudCB0byBlbWl0LCBvciBhbiBleHByZXNzaW9uIHRoYXQgcmV0dXJucyBhbiBldmVudCB0byBlbWl0LiAqL1xuZXZlbnRPckV4cHIpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGBlbWl0KClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGVtaXQudHlwZSA9ICd4c3RhdGUuZW1pdCc7XG4gIGVtaXQuZXZlbnQgPSBldmVudE9yRXhwcjtcbiAgZW1pdC5yZXNvbHZlID0gcmVzb2x2ZUVtaXQ7XG4gIGVtaXQuZXhlY3V0ZSA9IGV4ZWN1dGVFbWl0O1xuICByZXR1cm4gZW1pdDtcbn1cblxuLy8gdGhpcyBpcyBuZWVkZWQgdG8gbWFrZSBKU0RvYyBgQGxpbmtgIHdvcmsgcHJvcGVybHlcblxuLyoqXG4gKiBAcmVtYXJrc1xuICogYFQgfCB1bmtub3duYCByZWR1Y2VzIHRvIGB1bmtub3duYCBhbmQgdGhhdCBjYW4gYmUgcHJvYmxlbWF0aWMgd2hlbiBpdCBjb21lc1xuICogdG8gY29udGV4dHVhbCB0eXBpbmcuIEl0IGVzcGVjaWFsbHkgaXMgYSBwcm9ibGVtIHdoZW4gdGhlIHVuaW9uIGhhcyBhXG4gKiBmdW5jdGlvbiBtZW1iZXIsIGxpa2UgaGVyZTpcbiAqXG4gKiBgYGB0c1xuICogZGVjbGFyZSBmdW5jdGlvbiB0ZXN0KFxuICogICBjYk9yVmFsOiAoKGFyZzogbnVtYmVyKSA9PiB1bmtub3duKSB8IHVua25vd25cbiAqICk6IHZvaWQ7XG4gKiB0ZXN0KChhcmcpID0+IHt9KTsgLy8gb29wcywgaW1wbGljaXQgYW55XG4gKiBgYGBcbiAqXG4gKiBUaGlzIHR5cGUgY2FuIGJlIHVzZWQgdG8gYXZvaWQgdGhpcyBwcm9ibGVtLiBUaGlzIHVuaW9uIHJlcHJlc2VudHMgdGhlIHNhbWVcbiAqIHZhbHVlIHNwYWNlIGFzIGB1bmtub3duYC5cbiAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzIzMTgyI2lzc3VlY29tbWVudC0zNzkwOTE4ODdcblxuLy8gQFRPRE86IHdlIGNhbid0IHVzZSBuYXRpdmUgYE5vSW5mZXJgIGFzIHdlIG5lZWQgdGhvc2U6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC82MTA5MlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNjEwNzdcbi8vIGJ1dCBldmVuIHdpdGggdGhvc2UgZml4ZXMgbmF0aXZlIE5vSW5mZXIgc3RpbGwgZG9lc24ndCB3b3JrIC0gZnVydGhlciBpc3N1ZXMgaGF2ZSB0byBiZSByZXByb2R1Y2VkIGFuZCBmaXhlZFxuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIHRoZSBidWlsdC1pbiBgTm9JbmZlcmAgdHlwZSBpbnN0ZWFkICovXG5cbi8qKiBUaGUgZnVsbCBkZWZpbml0aW9uIG9mIGFuIGV2ZW50LCB3aXRoIGEgc3RyaW5nIGB0eXBlYC4gKi9cblxuLyoqXG4gKiBUaGUgc3RyaW5nIG9yIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXRlIHZhbHVlIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAqIHN0YXRlIG5vZGUuXG4gKlxuICogQHJlbWFya3NcbiAqIC0gRm9yIGEgY2hpbGQgYXRvbWljIHN0YXRlIG5vZGUsIHRoaXMgaXMgYSBzdHJpbmcsIGUuZy4sIGBcInBlbmRpbmdcImAuXG4gKiAtIEZvciBjb21wbGV4IHN0YXRlIG5vZGVzLCB0aGlzIGlzIGFuIG9iamVjdCwgZS5nLiwgYHsgc3VjY2VzczpcbiAqICAgXCJzb21lQ2hpbGRTdGF0ZVwiIH1gLlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYEFueU1hY2hpbmVTbmFwc2hvdGAgaW5zdGVhZCAqL1xuXG4vLyBUT0RPOiBwb3NzaWJseSByZWZhY3RvciB0aGlzIHNvbWVob3csIHVzZSBldmVuIGEgc2ltcGxlciB0eXBlLCBhbmQgbWF5YmUgZXZlbiBtYWtlIGBtYWNoaW5lLm9wdGlvbnNgIHByaXZhdGUgb3Igc29tZXRoaW5nXG4vKiogQGlnbm9yZSAqL1xuXG5sZXQgU3BlY2lhbFRhcmdldHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFNwZWNpYWxUYXJnZXRzKSB7XG4gIFNwZWNpYWxUYXJnZXRzW1wiUGFyZW50XCJdID0gXCIjX3BhcmVudFwiO1xuICBTcGVjaWFsVGFyZ2V0c1tcIkludGVybmFsXCJdID0gXCIjX2ludGVybmFsXCI7XG4gIHJldHVybiBTcGVjaWFsVGFyZ2V0cztcbn0oe30pO1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBbnlBY3RvcmAgaW5zdGVhZC4gKi9cblxuLy8gQmFzZWQgb24gUnhKUyB0eXBlc1xuXG4vLyBUT0RPOiBpbiB2NiwgdGhpcyBzaG91bGQgb25seSBhY2NlcHQgQW55QWN0b3JMb2dpYywgbGlrZSBBY3RvclJlZkZyb21Mb2dpY1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBY3RvcjxUPmAgaW5zdGVhZC4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGxvZ2ljIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIGFjdG9yLlxuICpcbiAqIEB0ZW1wbGF0ZSBUU25hcHNob3QgLSBUaGUgdHlwZSBvZiB0aGUgc25hcHNob3QuXG4gKiBAdGVtcGxhdGUgVEV2ZW50IC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IG9iamVjdC5cbiAqIEB0ZW1wbGF0ZSBUSW5wdXQgLSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBAdGVtcGxhdGUgVFN5c3RlbSAtIFRoZSB0eXBlIG9mIHRoZSBhY3RvciBzeXN0ZW0uXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkICovXG5cbi8vIFRPRE86IGNvdmVyIGFsbCB0aGF0IGNhbiBiZSBhY3R1YWxseSByZXR1cm5lZFxuXG5mdW5jdGlvbiByZXNvbHZlU2VuZFRvKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgdG8sXG4gIGV2ZW50OiBldmVudE9yRXhwcixcbiAgaWQsXG4gIGRlbGF5XG59LCBleHRyYSkge1xuICBjb25zdCBkZWxheXNNYXAgPSBzbmFwc2hvdC5tYWNoaW5lLmltcGxlbWVudGF0aW9ucy5kZWxheXM7XG4gIGlmICh0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICBgT25seSBldmVudCBvYmplY3RzIG1heSBiZSB1c2VkIHdpdGggc2VuZFRvOyB1c2Ugc2VuZFRvKHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICBsZXQgcmVzb2x2ZWREZWxheTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdEZWxheSA9IGRlbGF5c01hcCAmJiBkZWxheXNNYXBbZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgY29uZmlnRGVsYXkgPT09ICdmdW5jdGlvbicgPyBjb25maWdEZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBkZWxheTtcbiAgfVxuICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiB0byA9PT0gJ2Z1bmN0aW9uJyA/IHRvKGFyZ3MsIGFjdGlvblBhcmFtcykgOiB0bztcbiAgbGV0IHRhcmdldEFjdG9yUmVmO1xuICBpZiAodHlwZW9mIHJlc29sdmVkVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgIGlmIChyZXNvbHZlZFRhcmdldCA9PT0gU3BlY2lhbFRhcmdldHMuUGFyZW50KSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGFjdG9yU2NvcGUuc2VsZi5fcGFyZW50O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICBlbHNlIGlmIChyZXNvbHZlZFRhcmdldCA9PT0gU3BlY2lhbFRhcmdldHMuSW50ZXJuYWwpIHtcbiAgICAgIHRhcmdldEFjdG9yUmVmID0gYWN0b3JTY29wZS5zZWxmO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRUYXJnZXQuc3RhcnRzV2l0aCgnI18nKSkge1xuICAgICAgLy8gU0NYTUwgY29tcGF0aWJpbGl0eTogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNTQ1hNTEV2ZW50UHJvY2Vzc29yXG4gICAgICAvLyAjX2ludm9rZWlkLiBJZiB0aGUgdGFyZ2V0IGlzIHRoZSBzcGVjaWFsIHRlcm0gJyNfaW52b2tlaWQnLCB3aGVyZSBpbnZva2VpZCBpcyB0aGUgaW52b2tlaWQgb2YgYW4gU0NYTUwgc2Vzc2lvbiB0aGF0IHRoZSBzZW5kaW5nIHNlc3Npb24gaGFzIGNyZWF0ZWQgYnkgPGludm9rZT4sIHRoZSBQcm9jZXNzb3IgbXVzdCBhZGQgdGhlIGV2ZW50IHRvIHRoZSBleHRlcm5hbCBxdWV1ZSBvZiB0aGF0IHNlc3Npb24uXG4gICAgICB0YXJnZXRBY3RvclJlZiA9IHNuYXBzaG90LmNoaWxkcmVuW3Jlc29sdmVkVGFyZ2V0LnNsaWNlKDIpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBleHRyYS5kZWZlcnJlZEFjdG9ySWRzPy5pbmNsdWRlcyhyZXNvbHZlZFRhcmdldCkgPyByZXNvbHZlZFRhcmdldCA6IHNuYXBzaG90LmNoaWxkcmVuW3Jlc29sdmVkVGFyZ2V0XTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXRBY3RvclJlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gc2VuZCBldmVudCB0byBhY3RvciAnJHtyZXNvbHZlZFRhcmdldH0nIGZyb20gbWFjaGluZSAnJHtzbmFwc2hvdC5tYWNoaW5lLmlkfScuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldEFjdG9yUmVmID0gcmVzb2x2ZWRUYXJnZXQgfHwgYWN0b3JTY29wZS5zZWxmO1xuICB9XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICB0bzogdGFyZ2V0QWN0b3JSZWYsXG4gICAgdGFyZ2V0SWQ6IHR5cGVvZiByZXNvbHZlZFRhcmdldCA9PT0gJ3N0cmluZycgPyByZXNvbHZlZFRhcmdldCA6IHVuZGVmaW5lZCxcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBpZCxcbiAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gcmV0cnlSZXNvbHZlU2VuZFRvKF8sIHNuYXBzaG90LCBwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zLnRvID0gc25hcHNob3QuY2hpbGRyZW5bcGFyYW1zLnRvXTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0ZVNlbmRUbyhhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgLy8gdGhpcyBmb3JtcyBhbiBvdXRnb2luZyBldmVudHMgcXVldWVcbiAgLy8gdGhhbmtzIHRvIHRoYXQgdGhlIHJlY2lwaWVudCBhY3RvcnMgYXJlIGFibGUgdG8gcmVhZCB0aGUgKnVwZGF0ZWQqIHNuYXBzaG90IHZhbHVlIG9mIHRoZSBzZW5kZXJcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdG8sXG4gICAgICBldmVudCxcbiAgICAgIGRlbGF5LFxuICAgICAgaWRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuc2NoZWR1bGUoYWN0b3JTY29wZS5zZWxmLCB0bywgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdG9yU2NvcGUuc3lzdGVtLl9yZWxheShhY3RvclNjb3BlLnNlbGYsXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgaW4gYSBkZWZlcnJlZCB0YXNrLCBpdCBzaG91bGQgYWxyZWFkeSBiZSBtdXRhdGVkIGJ5IHJldHJ5UmVzb2x2ZVNlbmRUb1xuICAgIC8vIGlmIGl0IGluaXRpYWxseSBzdGFydGVkIGFzIGEgc3RyaW5nXG4gICAgdG8sIGV2ZW50LnR5cGUgPT09IFhTVEFURV9FUlJPUiA/IGNyZWF0ZUVycm9yQWN0b3JFdmVudChhY3RvclNjb3BlLnNlbGYuaWQsIGV2ZW50LmRhdGEpIDogZXZlbnQpO1xuICB9KTtcbn1cbi8qKlxuICogU2VuZHMgYW4gZXZlbnQgdG8gYW4gYWN0b3IuXG4gKlxuICogQHBhcmFtIGFjdG9yIFRoZSBgQWN0b3JSZWZgIHRvIHNlbmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kLCBvciBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBldmVudFxuICogICB0byBzZW5kXG4gKiBAcGFyYW0gb3B0aW9ucyBTZW5kIGFjdGlvbiBvcHRpb25zXG4gKlxuICogICAtIGBpZGAgLSBUaGUgdW5pcXVlIHNlbmQgZXZlbnQgaWRlbnRpZmllciAodXNlZCB3aXRoIGBjYW5jZWwoKWApLlxuICogICAtIGBkZWxheWAgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc2VuZGluZyBvZiB0aGUgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRUbyh0bywgZXZlbnRPckV4cHIsIG9wdGlvbnMpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGBzZW5kVG8oKWAgZGlyZWN0bHksIGFzIGl0IGlzIG5vdCBpbXBlcmF0aXZlLiBTZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvYWN0aW9ucyNidWlsdC1pbi1hY3Rpb25zIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZFRvKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzZW5kVG8udHlwZSA9ICd4c3RhdGUuc2VuZFRvJztcbiAgc2VuZFRvLnRvID0gdG87XG4gIHNlbmRUby5ldmVudCA9IGV2ZW50T3JFeHByO1xuICBzZW5kVG8uaWQgPSBvcHRpb25zPy5pZDtcbiAgc2VuZFRvLmRlbGF5ID0gb3B0aW9ucz8uZGVsYXk7XG4gIHNlbmRUby5yZXNvbHZlID0gcmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLnJldHJ5UmVzb2x2ZSA9IHJldHJ5UmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLmV4ZWN1dGUgPSBleGVjdXRlU2VuZFRvO1xuICByZXR1cm4gc2VuZFRvO1xufVxuXG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQgdG8gdGhlIHBhcmVudCBtYWNoaW5lLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRQYXJlbnQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbmRUbyhTcGVjaWFsVGFyZ2V0cy5QYXJlbnQsIGV2ZW50LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRm9yd2FyZHMgKHNlbmRzKSBhbiBldmVudCB0byB0aGUgYHRhcmdldGAgYWN0b3IuXG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IGFjdG9yIHRvIGZvcndhcmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgYWN0aW9uIGNyZWF0b3IuXG4gKi9cbmZ1bmN0aW9uIGZvcndhcmRUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgaWYgKCghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIG9yaWdpbmFsVGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gb3JpZ2luYWxUYXJnZXQoLi4uYXJncykgOiBvcmlnaW5hbFRhcmdldDtcbiAgICAgIGlmICghcmVzb2x2ZWRUYXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gZm9yd2FyZCBldmVudCB0byB1bmRlZmluZWQgYWN0b3IuIFRoaXMgcmlza3MgYW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgc2VuZGVyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVkVGFyZ2V0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlbmRUbyh0YXJnZXQsICh7XG4gICAgZXZlbnRcbiAgfSkgPT4gZXZlbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRW5xdWV1ZUFjdGlvbnMoYWN0b3JTY29wZSwgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBjb2xsZWN0XG59KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgY29uc3QgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoYWN0aW9uKSB7XG4gICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH07XG4gIGVucXVldWUuYXNzaWduID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goYXNzaWduKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5jYW5jZWwgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChjYW5jZWwoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnJhaXNlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gaXQgZmFpbHMgdG8gaW5mZXIgYFREZWxheWAgZnJvbSBgLi4uYXJnc2AgaGVyZSBhbmQgcGlja3MgaXRzIGRlZmF1bHQgKGBuZXZlcmApXG4gICAgLy8gdGhlbiBpdCBmYWlscyB0byB0eXBlY2hlY2sgdGhhdCBiZWNhdXNlIGAuLi5hcmdzYCB1c2UgYHN0cmluZ2AgaW4gcGxhY2Ugb2YgYFREZWxheWBcbiAgICBhY3Rpb25zLnB1c2gocmFpc2UoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnNlbmRUbyA9ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIGl0IGZhaWxzIHRvIGluZmVyIGBURGVsYXlgIGZyb20gYC4uLmFyZ3NgIGhlcmUgYW5kIHBpY2tzIGl0cyBkZWZhdWx0IChgbmV2ZXJgKVxuICAgIC8vIHRoZW4gaXQgZmFpbHMgdG8gdHlwZWNoZWNrIHRoYXQgYmVjYXVzZSBgLi4uYXJnc2AgdXNlIGBzdHJpbmdgIGluIHBsYWNlIG9mIGBURGVsYXlcbiAgICBhY3Rpb25zLnB1c2goc2VuZFRvKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zZW5kUGFyZW50ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goc2VuZFBhcmVudCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc3Bhd25DaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHNwYXduQ2hpbGQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnN0b3BDaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHN0b3BDaGlsZCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuZW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKGVtaXQoLi4uYXJncykpO1xuICB9O1xuICBjb2xsZWN0KHtcbiAgICBjb250ZXh0OiBhcmdzLmNvbnRleHQsXG4gICAgZXZlbnQ6IGFyZ3MuZXZlbnQsXG4gICAgZW5xdWV1ZSxcbiAgICBjaGVjazogZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgc25hcHNob3QuY29udGV4dCwgYXJncy5ldmVudCwgc25hcHNob3QpLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH0sIGFjdGlvblBhcmFtcyk7XG4gIHJldHVybiBbc25hcHNob3QsIHVuZGVmaW5lZCwgYWN0aW9uc107XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYWN0aW9uIG9iamVjdCB0aGF0IHdpbGwgZXhlY3V0ZSBhY3Rpb25zIHRoYXQgYXJlIHF1ZXVlZCBieSB0aGVcbiAqIGBlbnF1ZXVlKGFjdGlvbilgIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGVucXVldWVBY3Rpb25zIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGVudHJ5OiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlLCBjaGVjayB9KSA9PiB7XG4gKiAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMCB9KTtcbiAqXG4gKiAgICAgaWYgKGNoZWNrKCdzb21lR3VhcmQnKSkge1xuICogICAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMSB9KTtcbiAqICAgICB9XG4gKlxuICogICAgIGVucXVldWUoJ3NvbWVBY3Rpb24nKTtcbiAqICAgfSlcbiAqIH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVBY3Rpb25zKGNvbGxlY3QpIHtcbiAgZnVuY3Rpb24gZW5xdWV1ZUFjdGlvbnMoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGVucXVldWVBY3Rpb25zLnR5cGUgPSAneHN0YXRlLmVucXVldWVBY3Rpb25zJztcbiAgZW5xdWV1ZUFjdGlvbnMuY29sbGVjdCA9IGNvbGxlY3Q7XG4gIGVucXVldWVBY3Rpb25zLnJlc29sdmUgPSByZXNvbHZlRW5xdWV1ZUFjdGlvbnM7XG4gIHJldHVybiBlbnF1ZXVlQWN0aW9ucztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxvZyhfLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHZhbHVlLFxuICBsYWJlbFxufSkge1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgdmFsdWU6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcykgOiB2YWx1ZSxcbiAgICBsYWJlbFxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZUxvZyh7XG4gIGxvZ2dlclxufSwge1xuICB2YWx1ZSxcbiAgbGFiZWxcbn0pIHtcbiAgaWYgKGxhYmVsKSB7XG4gICAgbG9nZ2VyKGxhYmVsLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyKHZhbHVlKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gZXhwciBUaGUgZXhwcmVzc2lvbiBmdW5jdGlvbiB0byBldmFsdWF0ZSB3aGljaCB3aWxsIGJlIGxvZ2dlZC4gVGFrZXNcbiAqICAgaW4gMiBhcmd1bWVudHM6XG4gKlxuICogICAtIGBjdHhgIC0gdGhlIGN1cnJlbnQgc3RhdGUgY29udGV4dFxuICogICAtIGBldmVudGAgLSB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gKlxuICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byBnaXZlIHRvIHRoZSBsb2dnZWQgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gbG9nKHZhbHVlID0gKHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0pID0+ICh7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59KSwgbGFiZWwpIHtcbiAgZnVuY3Rpb24gbG9nKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBsb2cudHlwZSA9ICd4c3RhdGUubG9nJztcbiAgbG9nLnZhbHVlID0gdmFsdWU7XG4gIGxvZy5sYWJlbCA9IGxhYmVsO1xuICBsb2cucmVzb2x2ZSA9IHJlc29sdmVMb2c7XG4gIGxvZy5leGVjdXRlID0gZXhlY3V0ZUxvZztcbiAgcmV0dXJuIGxvZztcbn1cblxuZXhwb3J0IHsgU3BlY2lhbFRhcmdldHMgYXMgUywgZW1pdCBhcyBhLCBzZW5kUGFyZW50IGFzIGIsIGVucXVldWVBY3Rpb25zIGFzIGUsIGZvcndhcmRUbyBhcyBmLCBsb2cgYXMgbCwgc2VuZFRvIGFzIHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/log-b8ca474e.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/raise-13a60c49.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dist/raise-13a60c49.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ $$ACTOR_TYPE),\n/* harmony export */   A: () => (/* binding */ Actor),\n/* harmony export */   B: () => (/* binding */ formatInitialTransition),\n/* harmony export */   C: () => (/* binding */ getCandidates),\n/* harmony export */   D: () => (/* binding */ resolveStateValue),\n/* harmony export */   E: () => (/* binding */ getAllStateNodes),\n/* harmony export */   F: () => (/* binding */ createMachineSnapshot),\n/* harmony export */   G: () => (/* binding */ isInFinalState),\n/* harmony export */   H: () => (/* binding */ macrostep),\n/* harmony export */   I: () => (/* binding */ transitionNode),\n/* harmony export */   J: () => (/* binding */ resolveActionsAndContext),\n/* harmony export */   K: () => (/* binding */ createInitEvent),\n/* harmony export */   L: () => (/* binding */ microstep),\n/* harmony export */   M: () => (/* binding */ getInitialStateNodes),\n/* harmony export */   N: () => (/* binding */ NULL_EVENT),\n/* harmony export */   O: () => (/* binding */ toStatePath),\n/* harmony export */   P: () => (/* binding */ isStateId),\n/* harmony export */   Q: () => (/* binding */ getStateNodeByPath),\n/* harmony export */   R: () => (/* binding */ getPersistedSnapshot),\n/* harmony export */   S: () => (/* binding */ STATE_DELIMITER),\n/* harmony export */   T: () => (/* binding */ resolveReferencedActor),\n/* harmony export */   U: () => (/* binding */ executingCustomAction),\n/* harmony export */   V: () => (/* binding */ XSTATE_ERROR),\n/* harmony export */   W: () => (/* binding */ createErrorActorEvent),\n/* harmony export */   X: () => (/* binding */ XSTATE_STOP),\n/* harmony export */   Y: () => (/* binding */ ProcessingStatus),\n/* harmony export */   Z: () => (/* binding */ cloneMachineSnapshot),\n/* harmony export */   a: () => (/* binding */ cancel),\n/* harmony export */   b: () => (/* binding */ spawnChild),\n/* harmony export */   c: () => (/* binding */ createActor),\n/* harmony export */   d: () => (/* binding */ and),\n/* harmony export */   e: () => (/* binding */ stateIn),\n/* harmony export */   f: () => (/* binding */ isMachineSnapshot),\n/* harmony export */   g: () => (/* binding */ getStateNodes),\n/* harmony export */   h: () => (/* binding */ getAllOwnEventDescriptors),\n/* harmony export */   i: () => (/* binding */ interpret),\n/* harmony export */   j: () => (/* binding */ matchesState),\n/* harmony export */   k: () => (/* binding */ toObserver),\n/* harmony export */   l: () => (/* binding */ stop),\n/* harmony export */   m: () => (/* binding */ matchesEventDescriptor),\n/* harmony export */   n: () => (/* binding */ not),\n/* harmony export */   o: () => (/* binding */ or),\n/* harmony export */   p: () => (/* binding */ pathToStateValue),\n/* harmony export */   q: () => (/* binding */ mapValues),\n/* harmony export */   r: () => (/* binding */ raise),\n/* harmony export */   s: () => (/* binding */ stopChild),\n/* harmony export */   t: () => (/* binding */ toArray),\n/* harmony export */   u: () => (/* binding */ formatTransitions),\n/* harmony export */   v: () => (/* binding */ toTransitionConfigArray),\n/* harmony export */   w: () => (/* binding */ formatTransition),\n/* harmony export */   x: () => (/* binding */ evaluateGuard),\n/* harmony export */   y: () => (/* binding */ createInvokeId),\n/* harmony export */   z: () => (/* binding */ getDelayedTransitions)\n/* harmony export */ });\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\nclass Mailbox {\n  constructor(_process) {\n    this._process = _process;\n    this._active = false;\n    this._current = null;\n    this._last = null;\n  }\n  start() {\n    this._active = true;\n    this.flush();\n  }\n  clear() {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n  enqueue(event) {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n    if (this._current) {\n      this._last.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n    this._current = enqueued;\n    this._last = enqueued;\n    if (this._active) {\n      this.flush();\n    }\n  }\n  flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n\nconst STATE_DELIMITER = '.';\nconst TARGETLESS_KEY = '';\nconst NULL_EVENT = '';\nconst STATE_IDENTIFIER = '#';\nconst WILDCARD = '*';\nconst XSTATE_INIT = 'xstate.init';\nconst XSTATE_ERROR = 'xstate.error';\nconst XSTATE_STOP = 'xstate.stop';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nfunction createAfterEvent(delayRef, id) {\n  return {\n    type: `xstate.after.${delayRef}.${id}`\n  };\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nfunction createDoneStateEvent(id, output) {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nfunction createDoneActorEvent(invokeId, output) {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\nfunction createErrorActorEvent(id, error) {\n  return {\n    type: `xstate.error.actor.${id}`,\n    error,\n    actorId: id\n  };\n}\nfunction createInitEvent(input) {\n  return {\n    type: XSTATE_INIT,\n    input\n  };\n}\n\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nfunction reportUnhandledError(err) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n\nconst symbolObservable = (() => typeof Symbol === 'function' && Symbol.observable || '@@observable')();\n\nfunction matchesState(parentStateId, childStateId) {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n  return Object.keys(parentStateValue).every(key => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n    return matchesState(parentStateValue[key], childStateValue[key]);\n  });\n}\nfunction toStatePath(stateId) {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n  const result = [];\n  let segment = '';\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n  result.push(segment);\n  return result;\n}\nfunction toStateValue(stateValue) {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n  if (typeof stateValue !== 'string') {\n    return stateValue;\n  }\n  const statePath = toStatePath(stateValue);\n  return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n  const value = {};\n  let marker = value;\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n  return value;\n}\nfunction mapValues(collection, iteratee) {\n  const result = {};\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n  return result;\n}\nfunction toArrayStrict(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\nfunction toArray(value) {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n  if (typeof mapper === 'function') {\n    return mapper({\n      context,\n      event,\n      self\n    });\n  }\n  if (!!mapper && typeof mapper === 'object' && Object.values(mapper).some(val => typeof val === 'function')) {\n    console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(mapper).filter(([, value]) => typeof value === 'function').map(([key, value]) => `\\n - ${key}: ${value.toString().replace(/\\n\\s*/g, '')}`).join('')}`);\n  }\n  return mapper;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n  return event.type.startsWith('xstate.error.actor');\n}\nfunction toTransitionConfigArray(configLike) {\n  return toArrayStrict(configLike).map(transitionLike => {\n    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string') {\n      return {\n        target: transitionLike\n      };\n    }\n    return transitionLike;\n  });\n}\nfunction normalizeTarget(target) {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)\n  };\n}\nfunction createInvokeId(stateNodeId, index) {\n  return `${index}.${stateNodeId}`;\n}\nfunction resolveReferencedActor(machine, src) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke;\n  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n  return [...new Set([...snapshot._nodes.flatMap(sn => sn.ownEvents)])];\n}\n\n/**\n * Checks if an event type matches an event descriptor, supporting wildcards.\n * Event descriptors can be:\n *\n * - Exact matches: \"event.type\"\n * - Wildcard: \"*\"\n * - Partial matches: \"event.*\"\n *\n * @param eventType - The actual event type string\n * @param descriptor - The event descriptor to match against\n * @returns True if the event type matches the descriptor\n */\nfunction matchesEventDescriptor(eventType, descriptor) {\n  if (descriptor === eventType) {\n    return true;\n  }\n  if (descriptor === WILDCARD) {\n    return true;\n  }\n  if (!descriptor.endsWith('.*')) {\n    return false;\n  }\n  if (/.*\\*.+/.test(descriptor)) {\n    console.warn(`Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${descriptor}\" event.`);\n  }\n  const partialEventTokens = descriptor.split('.');\n  const eventTokens = eventType.split('.');\n  for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {\n    const partialEventToken = partialEventTokens[tokenIndex];\n    const eventToken = eventTokens[tokenIndex];\n    if (partialEventToken === '*') {\n      const isLastToken = tokenIndex === partialEventTokens.length - 1;\n      if (!isLastToken) {\n        console.warn(`Infix wildcards in transition events are not allowed. Check the \"${descriptor}\" transition.`);\n      }\n      return isLastToken;\n    }\n    if (partialEventToken !== eventToken) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createScheduledEventId(actorRef, id) {\n  return `${actorRef.sessionId}.${id}`;\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n  const children = new Map();\n  const keyedActors = new Map();\n  const reverseKeyedActors = new WeakMap();\n  const inspectionObservers = new Set();\n  const timerMap = {};\n  const {\n    clock,\n    logger\n  } = options;\n  const scheduler = {\n    schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2)) => {\n      const scheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n        system._relay(source, target, event);\n      }, delay);\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: actorRef => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = event => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach(observer => observer.next?.(resolvedInspectionEvent));\n  };\n  const system = {\n    _snapshot: {\n      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: actorRef => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: systemId => {\n      return keyedActors.get(systemId);\n    },\n    getAll: () => {\n      return Object.fromEntries(keyedActors.entries());\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(`Actor with system ID '${systemId}' already exists.`);\n      }\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: observerOrFn => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: {\n          ...system._snapshot._scheduledEvents\n        }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const {\n          source,\n          target,\n          event,\n          delay,\n          id\n        } = scheduledEvents[scheduledId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n  return system;\n}\n\n// those are needed to make JSDoc `@link` work properly\n\nlet executingCustomAction = false;\nconst $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/function (ProcessingStatus) {\n  ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n  ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n  ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n  return ProcessingStatus;\n}({});\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: id => {\n      return clearTimeout(id);\n    }\n  },\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nclass Actor {\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(logic, options) {\n    this.logic = logic;\n    /** The current internal state of the actor. */\n    this._snapshot = void 0;\n    /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */\n    this.clock = void 0;\n    this.options = void 0;\n    /** The unique identifier for this actor relative to its parent. */\n    this.id = void 0;\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this.observers = new Set();\n    this.eventListeners = new Map();\n    this.logger = void 0;\n    /** @internal */\n    this._processingStatus = ProcessingStatus.NotStarted;\n    // Actor Ref\n    this._parent = void 0;\n    /** @internal */\n    this._syncSnapshot = void 0;\n    this.ref = void 0;\n    // TODO: add typings for system\n    this._actorScope = void 0;\n    this.systemId = void 0;\n    /** The globally unique process ID for this invocation. */\n    this.sessionId = void 0;\n    /** The system to which this actor belongs. */\n    this.system = void 0;\n    this._doneEvent = void 0;\n    this.src = void 0;\n    // array of functions to defer\n    this._deferred = [];\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n    const {\n      clock,\n      logger,\n      parent,\n      syncSnapshot,\n      id,\n      systemId,\n      inspect\n    } = resolvedOptions;\n    this.system = parent ? parent.system : createSystem(this, {\n      clock,\n      logger\n    });\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: fn => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: child => {\n        if (child._parent !== this) {\n          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);\n        }\n        child._stop();\n      },\n      emit: emittedEvent => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [...(listeners ? listeners.values() : []), ...(wildcardListener ? wildcardListener.values() : [])];\n        for (const handler of allListeners) {\n          try {\n            handler(emittedEvent);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n      },\n      actionExecutor: action => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n    if (systemId) {\n      this.systemId = systemId;\n      this.system._set(systemId, this);\n    }\n    this._initState(options?.snapshot ?? options?.state);\n    if (systemId && this._snapshot.status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n  _initState(persistedState) {\n    try {\n      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      };\n    }\n  }\n  update(snapshot, event) {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn;\n    while (deferredFn = this._deferred.shift()) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...snapshot,\n          status: 'error',\n          error: err\n        };\n      }\n    }\n    switch (this._snapshot.status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n        break;\n      case 'error':\n        this._error(this._snapshot.error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n\n  subscribe(nextListenerOrObserver, errorListener, completeListener) {\n    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch (this._snapshot.status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error':\n          {\n            const err = this._snapshot.error;\n            if (!observer.error) {\n              reportUnhandledError(err);\n            } else {\n              try {\n                observer.error(err);\n              } catch (err) {\n                reportUnhandledError(err);\n              }\n            }\n            break;\n          }\n      }\n    }\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n  on(type, handler) {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  start() {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: snapshot => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n    this.system._register(this.sessionId, this);\n    if (this.systemId) {\n      this.system._set(this.systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n    const status = this._snapshot.status;\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(this._snapshot, initEvent);\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error(this._snapshot.error);\n        return this;\n    }\n    if (!this._parent) {\n      this.system.start();\n    }\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...this._snapshot,\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent);\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n    this.mailbox.start();\n    return this;\n  }\n  _process(event) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = {\n        err\n      };\n    }\n    if (caughtError) {\n      const {\n        err\n      } = caughtError;\n      this._snapshot = {\n        ...this._snapshot,\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n  _stop() {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({\n      type: XSTATE_STOP\n    });\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  stop() {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  _complete() {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n    this.eventListeners.clear();\n  }\n  _reportError(err) {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      this.eventListeners.clear();\n      return;\n    }\n    let reportError = false;\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    this.eventListeners.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  _error(err) {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  _stopProcedure() {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n    return this;\n  }\n\n  /** @internal */\n  _send(event) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      {\n        const eventString = JSON.stringify(event);\n        console.warn(`Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`);\n      }\n      return;\n    }\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  send(event) {\n    if (typeof event === 'string') {\n      throw new Error(`Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`);\n    }\n    this.system._relay(undefined, this, event);\n  }\n  attachDevTools() {\n    const {\n      devTools\n    } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter = typeof devTools === 'function' ? devTools : _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.devToolsAdapter;\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n\n  getPersistedSnapshot(options) {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n  [symbolObservable]() {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  getSnapshot() {\n    if (!this._snapshot) {\n      throw new Error(`Snapshot can't be read while the actor initializes itself`);\n    }\n    return this._snapshot;\n  }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nfunction createActor(logic, ...[options]) {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nconst interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\n\nfunction resolveCancel(_, snapshot, actionArgs, actionParams, {\n  sendId\n}) {\n  const resolvedSendId = typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, {\n    sendId: resolvedSendId\n  }, undefined];\n}\nfunction executeCancel(actorScope, params) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n  });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nfunction cancel(sendId) {\n  function cancel(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n  return cancel;\n}\n\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {\n  id,\n  systemId,\n  src,\n  input,\n  syncSnapshot\n}) {\n  const logic = typeof src === 'string' ? resolveReferencedActor(snapshot.machine, src) : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef;\n  let resolvedInput = undefined;\n  if (logic) {\n    resolvedInput = typeof input === 'function' ? input({\n      context: snapshot.context,\n      event: actionArgs.event,\n      self: actorScope.self\n    }) : input;\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: resolvedInput\n    });\n  }\n  if (!actorRef) {\n    console.warn(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n    `Actor type '${src}' not found in machine '${actorScope.id}'.`);\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children: {\n      ...snapshot.children,\n      [resolvedId]: actorRef\n    }\n  }), {\n    id,\n    systemId,\n    actorRef,\n    src,\n    input: resolvedInput\n  }, undefined];\n}\nfunction executeSpawn(actorScope, {\n  actorRef\n}) {\n  if (!actorRef) {\n    return;\n  }\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\nfunction spawnChild(...[src, {\n  id,\n  systemId,\n  input,\n  syncSnapshot = false\n} = {}]) {\n  function spawnChild(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  spawnChild.type = 'xstate.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n  return spawnChild;\n}\n\nfunction resolveStop(_, snapshot, args, actionParams, {\n  actorRef\n}) {\n  const actorRefOrString = typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef = typeof actorRefOrString === 'string' ? snapshot.children[actorRefOrString] : actorRefOrString;\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = {\n      ...children\n    };\n    delete children[resolvedActorRef.id];\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children\n  }), resolvedActorRef, undefined];\n}\nfunction unregisterRecursively(actorScope, actorRef) {\n  // unregister children first (depth-first)\n  const snapshot = actorRef.getSnapshot();\n  if (snapshot && 'children' in snapshot) {\n    for (const child of Object.values(snapshot.children)) {\n      unregisterRecursively(actorScope, child);\n    }\n  }\n  actorScope.system._unregister(actorRef);\n}\nfunction executeStop(actorScope, actorRef) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  // we also need to recursively unregister all nested children's systemIds\n  unregisterRecursively(actorScope, actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nfunction stopChild(actorRef) {\n  function stop(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nconst stop = stopChild;\n\nfunction checkStateIn(snapshot, _, {\n  stateValue\n}) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some(sn => sn === target);\n  }\n  return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n  function stateIn() {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n  return stateIn;\n}\nfunction checkNot(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nfunction not(guard) {\n  function not(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  not.check = checkNot;\n  not.guards = [guard];\n  return not;\n}\nfunction checkAnd(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.every(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction and(guards) {\n  function and(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  and.check = checkAnd;\n  and.guards = guards;\n  return and;\n}\nfunction checkOr(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.some(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction or(guards) {\n  function or(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  or.check = checkOr;\n  or.guards = guards;\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n  const {\n    machine\n  } = snapshot;\n  const isInline = typeof guard === 'function';\n  const resolved = isInline ? guard : machine.implementations.guards[typeof guard === 'string' ? guard : guard.type];\n  if (!isInline && !resolved) {\n    throw new Error(`Guard '${typeof guard === 'string' ? guard : guard.type}' is not implemented.'.`);\n  }\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved, context, event, snapshot);\n  }\n  const guardArgs = {\n    context,\n    event\n  };\n  const guardParams = isInline || typeof guard === 'string' ? undefined : 'params' in guard ? typeof guard.params === 'function' ? guard.params({\n    context,\n    event\n  }) : guard.params : undefined;\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams);\n  }\n  const builtinGuard = resolved;\n  return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n  );\n}\n\nconst isAtomicStateNode = stateNode => stateNode.type === 'atomic' || stateNode.type === 'final';\nfunction getChildren(stateNode) {\n  return Object.values(stateNode.states).filter(sn => sn.type !== 'history');\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n  const ancestors = [];\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n  return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n  const nodeSet = new Set(stateNodes);\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach(sn => nodeSet.add(sn));\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n  return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n  const childStateNodes = adjList.get(baseNode);\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n  const stateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n  return stateValue;\n}\nfunction getAdjList(stateNodes) {\n  const adjList = new Map();\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n      adjList.get(s.parent).push(s);\n    }\n  }\n  return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(s => s.type === 'final' && stateNodeSet.has(s));\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every(sn => isInFinalState(stateNodeSet, sn));\n  }\n  return stateNode.type === 'final';\n}\nconst isStateId = str => str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n  const candidates = stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter(eventDescriptor => matchesEventDescriptor(receivedEventType, eventDescriptor)).sort((a, b) => b.length - a.length).flatMap(key => stateNode.transitions.get(key));\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nfunction getDelayedTransitions(stateNode) {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n  const mutateEntryExit = delay => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n    stateNode.entry.push(raise(afterEvent, {\n      id: eventType,\n      delay\n    }));\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n  const delayedTransitions = Object.keys(afterConfig).flatMap(delay => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition = typeof configTransition === 'string' ? {\n      target: configTransition\n    } : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map(transition => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map(delayedTransition => {\n    const {\n      delay\n    } = delayedTransition;\n    return {\n      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n      delay\n    };\n  });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (transitionConfig.cond) {\n    throw new Error(`State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`);\n  }\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map(t => `#${t.id}`) : undefined\n    })\n  };\n  return transition;\n}\nfunction formatTransitions(stateNode) {\n  const transitions = new Map();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n  const resolvedTarget = typeof _target === 'string' ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n    `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`);\n  }\n  const transition = {\n    source: stateNode,\n    actions: !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n  return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map(target => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n        return targetStateNode;\n      } catch (err) {\n        throw new Error(`Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`);\n      }\n    } else {\n      throw new Error(`Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`);\n    }\n  });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n  const normalizedTarget = normalizeTarget(stateNode.config.target);\n  if (!normalizedTarget) {\n    return stateNode.parent.initial;\n  }\n  return {\n    target: normalizedTarget.map(t => typeof t === 'string' ? getStateNodeByPath(stateNode.parent, t) : t)\n  };\n}\nfunction isHistoryNode(stateNode) {\n  return stateNode.type === 'history';\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\nfunction getInitialStateNodes(stateNode) {\n  const set = new Set();\n  function iter(descStateNode) {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n  iter(stateNode);\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode, stateKey) {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nfunction getStateNodeByPath(stateNode, statePath) {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift();\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nfunction getStateNodes(stateNode, stateValue) {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);\n    }\n    return [stateNode, childStateNode];\n  }\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes = childStateKeys.map(subStateKey => getStateNode(stateNode, subStateKey)).filter(Boolean);\n  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    if (!subStateNode) {\n      return allSubStateNodes;\n    }\n    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n    return allSubStateNodes.concat(subStateNodes);\n  }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n  const subStateKeys = Object.keys(stateValue);\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n  const allInnerTransitions = [];\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n    if (!subStateValue) {\n      continue;\n    }\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n  return Object.keys(stateNode.states).map(key => stateNode.states[key]).filter(sn => sn.type === 'history');\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n  return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n  const filteredTransitions = new Set();\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set();\n    for (const t2 of filteredTransitions) {\n      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue))) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n  return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every(sn => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n  if (!transition.target) {\n    return [];\n  }\n  const targets = new Set();\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n  return [...targets];\n}\nfunction getTransitionDomain(transition, historyValue) {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n  if (!targetStates) {\n    return;\n  }\n  if (!transition.reenter && targetStates.every(target => target === transition.source || isDescendant(target, transition.source))) {\n    return transition.source;\n  }\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n  return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n  const statesToExit = new Set();\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n  return [...statesToExit];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nfunction microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n  if (!transitions.length) {\n    return currentSnapshot;\n  }\n  const mutStateNodeSet = new Set(currentSnapshot._nodes);\n  let historyValue = currentSnapshot.historyValue;\n  const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n  let nextState = currentSnapshot;\n\n  // Exit states\n  if (!isInitial) {\n    [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);\n  }\n\n  // Execute transition content\n  nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap(t => t.actions), internalQueue, undefined);\n\n  // Enter states\n  nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n  const nextStateNodes = [...mutStateNodeSet];\n  if (nextState.status === 'done') {\n    nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b) => b.order - a.order).flatMap(state => state.exit), internalQueue, undefined);\n  }\n\n  // eslint-disable-next-line no-useless-catch\n  try {\n    if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n      return nextState;\n    }\n    return cloneMachineSnapshot(nextState, {\n      _nodes: nextStateNodes,\n      historyValue\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set();\n  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n  const completedNodes = new Set();\n  for (const stateNodeToEnter of [...statesToEnter].sort((a, b) => a.order - b.order)) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(spawnChild(invokeDef.src, {\n        ...invokeDef,\n        syncSnapshot: !!invokeDef.onSnapshot\n      }));\n    }\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map(invokeDef => invokeDef.id));\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n      let ancestorMarker = parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n      if (parent?.type === 'compound') {\n        internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n      }\n      while (ancestorMarker?.type === 'parallel' && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n      });\n    }\n  }\n  return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n    for (const s of t.target || []) {\n      if (!isHistoryNode(s) && (\n      // if the target is different than the source then it will *definitely* be entered\n      t.source !== s ||\n      // we know that the domain can't lie within the source\n      // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n      t.source !== domain ||\n      // reentering transitions always enter the target, even if it's the source itself\n      t.reenter)) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n    }\n  }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n      addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(sn => !isHistoryNode(sn))) {\n          if (![...statesToEnter].some(s => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n          }\n        }\n      }\n    }\n  }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter(sn => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some(s => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n      }\n    }\n  }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n  statesToExit.sort((a, b) => b.order - a.order);\n  let changedHistory;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate;\n      if (historyNode.history === 'deep') {\n        predicate = sn => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = sn => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= {\n        ...historyValue\n      };\n      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s.exit, ...s.invoke.map(def => stopChild(def.id))], internalQueue, undefined);\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue];\n}\nfunction getAction(machine, actionType) {\n  return machine.implementations.actions[actionType];\n}\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n  const {\n    machine\n  } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline ? action :\n    // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n    // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n    // our logic below makes sure that we call those 2 \"variants\" correctly\n\n    getAction(machine, typeof action === 'string' ? action : action.type);\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n    const actionParams = isInline || typeof action === 'string' ? undefined : 'params' in action ? typeof action.params === 'function' ? action.params({\n      context: intermediateSnapshot.context,\n      event\n    }) : action.params : undefined;\n    if (!resolvedAction || !('resolve' in resolvedAction)) {\n      actorScope.actionExecutor({\n        type: typeof action === 'string' ? action : typeof action === 'object' ? action.type : action.name || '(anonymous)',\n        info: actionArgs,\n        params: actionParams,\n        exec: resolvedAction\n      });\n      continue;\n    }\n    const builtinAction = resolvedAction;\n    const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction,\n    // this holds all params\n    extra);\n    intermediateSnapshot = nextState;\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n    if ('execute' in builtinAction) {\n      actorScope.actionExecutor({\n        type: builtinAction.type,\n        info: actionArgs,\n        params,\n        exec: builtinAction.execute.bind(null, actorScope, params)\n      });\n    }\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n    }\n  }\n  return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n  const retries = deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n    internalQueue,\n    deferredActorIds\n  }, retries);\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue) {\n  if (event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n  let nextSnapshot = snapshot;\n  const microstates = [];\n  function addMicrostate(microstate, event, transitions) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: microstate,\n      _transitions: transitions\n    });\n    microstates.push(microstate);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n      status: 'stopped'\n    });\n    addMicrostate(nextSnapshot, event, []);\n    return {\n      snapshot: nextSnapshot,\n      microstates\n    };\n  }\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostate(nextSnapshot, currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microstates\n      };\n    }\n    nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false,\n    // isInitial\n    internalQueue);\n    addMicrostate(nextSnapshot, currentEvent, transitions);\n  }\n  let shouldSelectEventlessTransitions = true;\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift();\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n  }\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n  return {\n    snapshot: nextSnapshot,\n    microstates\n  };\n}\nfunction stopChildren(nextState, event, actorScope) {\n  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map(child => stopChild(child)), [], undefined);\n}\nfunction selectTransitions(event, nextState) {\n  return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n  const enabledTransitionSet = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(getProperAncestors(stateNode, undefined))) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nfunction resolveStateValue(rootNode, stateValue) {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n\nfunction isMachineSnapshot(value) {\n  return !!value && typeof value === 'object' && 'machine' in value && 'value' in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n  return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n  return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n  if (!this.machine) {\n    console.warn(`state.can(...) used outside of a machine-created State object; this will always return false.`);\n  }\n  const transitionData = this.machine.getTransitionData(this, event);\n  return !!transitionData?.length &&\n  // Check that at least one transition is not forbidden\n  transitionData.some(t => t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return {\n    ...jsonValues,\n    tags: Array.from(tags)\n  };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n  return this._nodes.reduce((acc, stateNode) => {\n    if (stateNode.meta !== undefined) {\n      acc[stateNode.id] = stateNode.meta;\n    }\n    return acc;\n  }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n  return {\n    status: config.status,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes),\n    tags: new Set(config._nodes.flatMap(sn => sn.tags)),\n    children: config.children,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\nfunction cloneMachineSnapshot(snapshot, config = {}) {\n  return createMachineSnapshot({\n    ...snapshot,\n    ...config\n  }, snapshot.machine);\n}\nfunction serializeHistoryValue(historyValue) {\n  if (typeof historyValue !== 'object' || historyValue === null) {\n    return {};\n  }\n  const result = {};\n  for (const key in historyValue) {\n    const value = historyValue[key];\n    if (Array.isArray(value)) {\n      result[key] = value.map(item => ({\n        id: item.id\n      }));\n    }\n  }\n  return result;\n}\nfunction getPersistedSnapshot(snapshot, options) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n  const childrenJson = {};\n  for (const id in children) {\n    const child = children[id];\n    if (typeof child.src !== 'string' && (!options || !('__unsafeAllowInlineActors' in options))) {\n      throw new Error('An inline child actor cannot be persisted.');\n    }\n    childrenJson[id] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child.systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context),\n    children: childrenJson,\n    historyValue: serializeHistoryValue(jsonValues.historyValue)\n  };\n  return persisted;\n}\nfunction persistContext(contextPart) {\n  let copy;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n          ...contextPart\n        };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: value.id\n        };\n      } else {\n        const result = persistContext(value);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n            ...contextPart\n          };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n\nfunction resolveRaise(_, snapshot, args, actionParams, {\n  event: eventOrExpr,\n  id,\n  delay\n}, {\n  internalQueue\n}) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [snapshot, {\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }, undefined];\n}\nfunction executeRaise(actorScope, params) {\n  const {\n    event,\n    delay,\n    id\n  } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nfunction raise(eventOrExpr, options) {\n  if (executingCustomAction) {\n    console.warn('Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function raise(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n  return raise;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtMTNhNjBjNDkuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUyxHQUFHLEdBQUc7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzT0FBc08sd0dBQXdHLElBQUksSUFBSSx1Q0FBdUMsWUFBWTtBQUN6WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU0sR0FBRyxZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1KQUFtSixXQUFXO0FBQzlKO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3Q0FBd0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixXQUFXO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CLEdBQUcsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUsS0FBSyxTQUFTO0FBQzdFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLCtCQUErQixTQUFTLEdBQUcsZUFBZSx1RkFBdUYsWUFBWTtBQUN2TTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFlBQVksU0FBUyxNQUFNLEdBQUc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0ZBQWtGLG9GQUFlO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQsY0FBYyxtQkFBbUIsR0FBRywwQkFBMEI7QUFDOUQsTUFBTSxxQkFBcUIsR0FBRyxrQkFBa0IsT0FBTyxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLElBQUksMEJBQTBCLGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQStDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0IsMkNBQTJDLEtBQUs7QUFDaEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csS0FBSztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLG9DQUFvQyxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CLG9DQUFvQyxrQkFBa0I7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUVBQXlFLGFBQWEsTUFBTSxZQUFZO0FBQ3hHO0FBQ0EsTUFBTTtBQUNOLDBDQUEwQyxPQUFPLDZEQUE2RCxPQUFPO0FBQ3JIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUyxVQUFVLGFBQWEsR0FBRztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyx1QkFBdUIsYUFBYTtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyx1QkFBdUIsYUFBYTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZLFNBQVMsWUFBWSxHQUFHO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2F2ZWRpYW4tbmV3c3Jvb20vLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtMTNhNjBjNDkuZGV2ZWxvcG1lbnQuZXNtLmpzP2FiOTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGV2VG9vbHNBZGFwdGVyIH0gZnJvbSAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5jbGFzcyBNYWlsYm94IHtcbiAgY29uc3RydWN0b3IoX3Byb2Nlc3MpIHtcbiAgICB0aGlzLl9wcm9jZXNzID0gX3Byb2Nlc3M7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgLy8gd2UgY2FuJ3Qgc2V0IF9jdXJyZW50IHRvIG51bGwgYmVjYXVzZSB3ZSBtaWdodCBiZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgIC8vIGFuZCBlbnF1ZXVlIGZvbGxvd2luZyBjbGVhciBzaG91bGRuJ3Qgc3RhcnQgcHJvY2Vzc2luZyB0aGUgZW5xdWV1ZWQgaXRlbSBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50Lm5leHQgPSBudWxsO1xuICAgICAgdGhpcy5fbGFzdCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgfVxuICB9XG4gIGVucXVldWUoZXZlbnQpIHtcbiAgICBjb25zdCBlbnF1ZXVlZCA9IHtcbiAgICAgIHZhbHVlOiBldmVudCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9sYXN0Lm5leHQgPSBlbnF1ZXVlZDtcbiAgICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudCA9IGVucXVldWVkO1xuICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG4gIGZsdXNoKCkge1xuICAgIHdoaWxlICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICAvLyBhdG0gdGhlIGdpdmVuIF9wcm9jZXNzIGlzIHJlc3BvbnNpYmxlIGZvciBpbXBsZW1lbnRpbmcgcHJvcGVyIHRyeS9jYXRjaCBoYW5kbGluZ1xuICAgICAgLy8gd2UgYXNzdW1lIGhlcmUgdGhhdCB0aGlzIHdvbid0IHRocm93IGluIGEgd2F5IHRoYXQgY2FuIGFmZmVjdCB0aGlzIG1haWxib3hcbiAgICAgIGNvbnN0IGNvbnN1bWVkID0gdGhpcy5fY3VycmVudDtcbiAgICAgIHRoaXMuX3Byb2Nlc3MoY29uc3VtZWQudmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudCA9IGNvbnN1bWVkLm5leHQ7XG4gICAgfVxuICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICB9XG59XG5cbmNvbnN0IFNUQVRFX0RFTElNSVRFUiA9ICcuJztcbmNvbnN0IFRBUkdFVExFU1NfS0VZID0gJyc7XG5jb25zdCBOVUxMX0VWRU5UID0gJyc7XG5jb25zdCBTVEFURV9JREVOVElGSUVSID0gJyMnO1xuY29uc3QgV0lMRENBUkQgPSAnKic7XG5jb25zdCBYU1RBVEVfSU5JVCA9ICd4c3RhdGUuaW5pdCc7XG5jb25zdCBYU1RBVEVfRVJST1IgPSAneHN0YXRlLmVycm9yJztcbmNvbnN0IFhTVEFURV9TVE9QID0gJ3hzdGF0ZS5zdG9wJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyBhbiBpbXBsaWNpdCBldmVudCB0aGF0IGlzIHNlbnQgYWZ0ZXIgdGhlXG4gKiBzcGVjaWZpZWQgYGRlbGF5YC5cbiAqXG4gKiBAcGFyYW0gZGVsYXlSZWYgVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGlkIFRoZSBzdGF0ZSBub2RlIElEIHdoZXJlIHRoaXMgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVBZnRlckV2ZW50KGRlbGF5UmVmLCBpZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuYWZ0ZXIuJHtkZWxheVJlZn0uJHtpZH1gXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBldmVudCB0aGF0IHJlcHJlc2VudHMgdGhhdCBhIGZpbmFsIHN0YXRlIG5vZGUgaGFzIGJlZW4gcmVhY2hlZCBpblxuICogdGhlIHBhcmVudCBzdGF0ZSBub2RlLlxuICpcbiAqIEBwYXJhbSBpZCBUaGUgZmluYWwgc3RhdGUgbm9kZSdzIHBhcmVudCBzdGF0ZSBub2RlIGBpZGBcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lU3RhdGVFdmVudChpZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLnN0YXRlLiR7aWR9YCxcbiAgICBvdXRwdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyB0aGF0IGFuIGludm9rZWQgc2VydmljZSBoYXMgdGVybWluYXRlZC5cbiAqXG4gKiBBbiBpbnZva2VkIHNlcnZpY2UgaXMgdGVybWluYXRlZCB3aGVuIGl0IGhhcyByZWFjaGVkIGEgdG9wLWxldmVsIGZpbmFsIHN0YXRlXG4gKiBub2RlLCBidXQgbm90IHdoZW4gaXQgaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIGludm9rZUlkIFRoZSBpbnZva2VkIHNlcnZpY2UgSURcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lQWN0b3JFdmVudChpbnZva2VJZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLmFjdG9yLiR7aW52b2tlSWR9YCxcbiAgICBvdXRwdXQsXG4gICAgYWN0b3JJZDogaW52b2tlSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yQWN0b3JFdmVudChpZCwgZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmVycm9yLmFjdG9yLiR7aWR9YCxcbiAgICBlcnJvcixcbiAgICBhY3RvcklkOiBpZFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5pdEV2ZW50KGlucHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogWFNUQVRFX0lOSVQsXG4gICAgaW5wdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW4gYSBzZXBhcmF0ZVxuICogbWFjcm90YXNrLiBJdCBhbGxvd3MgdGhvc2UgZXJyb3JzIHRvIGJlIGRldGVjdGVkIGJ5IGdsb2JhbCBlcnJvciBoYW5kbGVycyBhbmRcbiAqIHJlcG9ydGVkIHRvIGJ1ZyB0cmFja2luZyBzZXJ2aWNlcyB3aXRob3V0IGludGVycnVwdGluZyBvdXIgb3duIHN0YWNrIG9mXG4gKiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIGVyciBFcnJvciB0byBiZSB0aHJvd25cbiAqL1xuZnVuY3Rpb24gcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGUgPSAoKCkgPT4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCAnQEBvYnNlcnZhYmxlJykoKTtcblxuZnVuY3Rpb24gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlSWQsIGNoaWxkU3RhdGVJZCkge1xuICBjb25zdCBwYXJlbnRTdGF0ZVZhbHVlID0gdG9TdGF0ZVZhbHVlKHBhcmVudFN0YXRlSWQpO1xuICBjb25zdCBjaGlsZFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUoY2hpbGRTdGF0ZUlkKTtcbiAgaWYgKHR5cGVvZiBjaGlsZFN0YXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnRTdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNoaWxkU3RhdGVWYWx1ZSA9PT0gcGFyZW50U3RhdGVWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBQYXJlbnQgbW9yZSBzcGVjaWZpYyB0aGFuIGNoaWxkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcGFyZW50U3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyZW50U3RhdGVWYWx1ZSBpbiBjaGlsZFN0YXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmVudFN0YXRlVmFsdWUpLmV2ZXJ5KGtleSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIGNoaWxkU3RhdGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXNTdGF0ZShwYXJlbnRTdGF0ZVZhbHVlW2tleV0sIGNoaWxkU3RhdGVWYWx1ZVtrZXldKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1N0YXRlUGF0aChzdGF0ZUlkKSB7XG4gIGlmIChpc0FycmF5KHN0YXRlSWQpKSB7XG4gICAgcmV0dXJuIHN0YXRlSWQ7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzZWdtZW50ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVJZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdGF0ZUlkLmNoYXJDb2RlQXQoaSk7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAvLyBcXFxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgc2VnbWVudCArPSBzdGF0ZUlkW2kgKyAxXTtcbiAgICAgICAgLy8gYW5kIHNraXAgb3ZlciBpdFxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gLlxuICAgICAgY2FzZSA0NjpcbiAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIHNlZ21lbnQgPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gc3RhdGVJZFtpXTtcbiAgfVxuICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVWYWx1ZShzdGF0ZVZhbHVlKSB7XG4gIGlmIChpc01hY2hpbmVTbmFwc2hvdChzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlLnZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgfVxuICBjb25zdCBzdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVZhbHVlKTtcbiAgcmV0dXJuIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKTtcbn1cbmZ1bmN0aW9uIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKSB7XG4gIGlmIChzdGF0ZVBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHN0YXRlUGF0aFswXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHt9O1xuICBsZXQgbWFya2VyID0gdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpID09PSBzdGF0ZVBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgbWFya2VyW3N0YXRlUGF0aFtpXV0gPSBzdGF0ZVBhdGhbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IG1hcmtlcjtcbiAgICAgIG1hcmtlciA9IHt9O1xuICAgICAgcHJldmlvdXNbc3RhdGVQYXRoW2ldXSA9IG1hcmtlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBjb2xsZWN0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gY29sbGVjdGlvbktleXNbaV07XG4gICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZShjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbiwgaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlTdHJpY3QodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdG9BcnJheVN0cmljdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlT3V0cHV0KG1hcHBlciwgY29udGV4dCwgZXZlbnQsIHNlbGYpIHtcbiAgaWYgKHR5cGVvZiBtYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWFwcGVyKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGZcbiAgICB9KTtcbiAgfVxuICBpZiAoISFtYXBwZXIgJiYgdHlwZW9mIG1hcHBlciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnZhbHVlcyhtYXBwZXIpLnNvbWUodmFsID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc29sZS53YXJuKGBEeW5hbWljYWxseSBtYXBwaW5nIHZhbHVlcyB0byBpbmRpdmlkdWFsIHByb3BlcnRpZXMgaXMgZGVwcmVjYXRlZC4gVXNlIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWFwcGVkIG9iamVjdCBpbnN0ZWFkLlxcbkZvdW5kIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBwb3NzaWJseSBtYXBwaW5nIGZ1bmN0aW9uczogJHtPYmplY3QuZW50cmllcyhtYXBwZXIpLmZpbHRlcigoWywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgXFxuIC0gJHtrZXl9OiAke3ZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxuXFxzKi9nLCAnJyl9YCkuam9pbignJyl9YCk7XG4gIH1cbiAgcmV0dXJuIG1hcHBlcjtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcnJvckFjdG9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgneHN0YXRlLmVycm9yLmFjdG9yJyk7XG59XG5mdW5jdGlvbiB0b1RyYW5zaXRpb25Db25maWdBcnJheShjb25maWdMaWtlKSB7XG4gIHJldHVybiB0b0FycmF5U3RyaWN0KGNvbmZpZ0xpa2UpLm1hcCh0cmFuc2l0aW9uTGlrZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHRyYW5zaXRpb25MaWtlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB0cmFuc2l0aW9uTGlrZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MaWtlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gVEFSR0VUTEVTU19LRVkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0b0FycmF5KHRhcmdldCk7XG59XG5mdW5jdGlvbiB0b09ic2VydmVyKG5leHRIYW5kbGVyLCBlcnJvckhhbmRsZXIsIGNvbXBsZXRpb25IYW5kbGVyKSB7XG4gIGNvbnN0IGlzT2JzZXJ2ZXIgPSB0eXBlb2YgbmV4dEhhbmRsZXIgPT09ICdvYmplY3QnO1xuICBjb25zdCBzZWxmID0gaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIG5leHQ6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIubmV4dCA6IG5leHRIYW5kbGVyKT8uYmluZChzZWxmKSxcbiAgICBlcnJvcjogKGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlci5lcnJvciA6IGVycm9ySGFuZGxlcik/LmJpbmQoc2VsZiksXG4gICAgY29tcGxldGU6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuY29tcGxldGUgOiBjb21wbGV0aW9uSGFuZGxlcik/LmJpbmQoc2VsZilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludm9rZUlkKHN0YXRlTm9kZUlkLCBpbmRleCkge1xuICByZXR1cm4gYCR7aW5kZXh9LiR7c3RhdGVOb2RlSWR9YDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKSB7XG4gIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKC9eeHN0YXRlXFwuaW52b2tlXFwuKFxcZCspXFwuKC4qKS8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmFjdG9yc1tzcmNdO1xuICB9XG4gIGNvbnN0IFssIGluZGV4U3RyLCBub2RlSWRdID0gbWF0Y2g7XG4gIGNvbnN0IG5vZGUgPSBtYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQobm9kZUlkKTtcbiAgY29uc3QgaW52b2tlQ29uZmlnID0gbm9kZS5jb25maWcuaW52b2tlO1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW52b2tlQ29uZmlnKSA/IGludm9rZUNvbmZpZ1tpbmRleFN0cl0gOiBpbnZva2VDb25maWcpLnNyYztcbn1cbmZ1bmN0aW9uIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMoc25hcHNob3QpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KFsuLi5zbmFwc2hvdC5fbm9kZXMuZmxhdE1hcChzbiA9PiBzbi5vd25FdmVudHMpXSldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCB0eXBlIG1hdGNoZXMgYW4gZXZlbnQgZGVzY3JpcHRvciwgc3VwcG9ydGluZyB3aWxkY2FyZHMuXG4gKiBFdmVudCBkZXNjcmlwdG9ycyBjYW4gYmU6XG4gKlxuICogLSBFeGFjdCBtYXRjaGVzOiBcImV2ZW50LnR5cGVcIlxuICogLSBXaWxkY2FyZDogXCIqXCJcbiAqIC0gUGFydGlhbCBtYXRjaGVzOiBcImV2ZW50LipcIlxuICpcbiAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgYWN0dWFsIGV2ZW50IHR5cGUgc3RyaW5nXG4gKiBAcGFyYW0gZGVzY3JpcHRvciAtIFRoZSBldmVudCBkZXNjcmlwdG9yIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGV2ZW50IHR5cGUgbWF0Y2hlcyB0aGUgZGVzY3JpcHRvclxuICovXG5mdW5jdGlvbiBtYXRjaGVzRXZlbnREZXNjcmlwdG9yKGV2ZW50VHlwZSwgZGVzY3JpcHRvcikge1xuICBpZiAoZGVzY3JpcHRvciA9PT0gZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRlc2NyaXB0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFkZXNjcmlwdG9yLmVuZHNXaXRoKCcuKicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgvLipcXCouKy8udGVzdChkZXNjcmlwdG9yKSkge1xuICAgIGNvbnNvbGUud2FybihgV2lsZGNhcmRzIGNhbiBvbmx5IGJlIHRoZSBsYXN0IHRva2VuIG9mIGFuIGV2ZW50IGRlc2NyaXB0b3IgKGUuZy4sIFwiZXZlbnQuKlwiKSBvciB0aGUgZW50aXJlIGV2ZW50IGRlc2NyaXB0b3IgKFwiKlwiKS4gQ2hlY2sgdGhlIFwiJHtkZXNjcmlwdG9yfVwiIGV2ZW50LmApO1xuICB9XG4gIGNvbnN0IHBhcnRpYWxFdmVudFRva2VucyA9IGRlc2NyaXB0b3Iuc3BsaXQoJy4nKTtcbiAgY29uc3QgZXZlbnRUb2tlbnMgPSBldmVudFR5cGUuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoOyB0b2tlbkluZGV4KyspIHtcbiAgICBjb25zdCBwYXJ0aWFsRXZlbnRUb2tlbiA9IHBhcnRpYWxFdmVudFRva2Vuc1t0b2tlbkluZGV4XTtcbiAgICBjb25zdCBldmVudFRva2VuID0gZXZlbnRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgaWYgKHBhcnRpYWxFdmVudFRva2VuID09PSAnKicpIHtcbiAgICAgIGNvbnN0IGlzTGFzdFRva2VuID0gdG9rZW5JbmRleCA9PT0gcGFydGlhbEV2ZW50VG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWlzTGFzdFRva2VuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW5maXggd2lsZGNhcmRzIGluIHRyYW5zaXRpb24gZXZlbnRzIGFyZSBub3QgYWxsb3dlZC4gQ2hlY2sgdGhlIFwiJHtkZXNjcmlwdG9yfVwiIHRyYW5zaXRpb24uYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNMYXN0VG9rZW47XG4gICAgfVxuICAgIGlmIChwYXJ0aWFsRXZlbnRUb2tlbiAhPT0gZXZlbnRUb2tlbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVkRXZlbnRJZChhY3RvclJlZiwgaWQpIHtcbiAgcmV0dXJuIGAke2FjdG9yUmVmLnNlc3Npb25JZH0uJHtpZH1gO1xufVxubGV0IGlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBjcmVhdGVTeXN0ZW0ocm9vdEFjdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICBjb25zdCBrZXllZEFjdG9ycyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgcmV2ZXJzZUtleWVkQWN0b3JzID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgaW5zcGVjdGlvbk9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdGltZXJNYXAgPSB7fTtcbiAgY29uc3Qge1xuICAgIGNsb2NrLFxuICAgIGxvZ2dlclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2NoZWR1bGVyID0ge1xuICAgIHNjaGVkdWxlOiAoc291cmNlLCB0YXJnZXQsIGV2ZW50LCBkZWxheSwgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSkgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGlkLFxuICAgICAgICBzdGFydGVkQXQ6IERhdGUubm93KClcbiAgICAgIH07XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudElkID0gY3JlYXRlU2NoZWR1bGVkRXZlbnRJZChzb3VyY2UsIGlkKTtcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXSA9IHNjaGVkdWxlZEV2ZW50O1xuICAgICAgY29uc3QgdGltZW91dCA9IGNsb2NrLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIGRlbGV0ZSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIHN5c3RlbS5fcmVsYXkoc291cmNlLCB0YXJnZXQsIGV2ZW50KTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICAgIHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdID0gdGltZW91dDtcbiAgICB9LFxuICAgIGNhbmNlbDogKHNvdXJjZSwgaWQpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgPSBjcmVhdGVTY2hlZHVsZWRFdmVudElkKHNvdXJjZSwgaWQpO1xuICAgICAgY29uc3QgdGltZW91dCA9IHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgZGVsZXRlIHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgZGVsZXRlIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgIGlmICh0aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xvY2suY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsQWxsOiBhY3RvclJlZiA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgaW4gc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50ID0gc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgICBpZiAoc2NoZWR1bGVkRXZlbnQuc291cmNlID09PSBhY3RvclJlZikge1xuICAgICAgICAgIHNjaGVkdWxlci5jYW5jZWwoYWN0b3JSZWYsIHNjaGVkdWxlZEV2ZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2VuZEluc3BlY3Rpb25FdmVudCA9IGV2ZW50ID0+IHtcbiAgICBpZiAoIWluc3BlY3Rpb25PYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluc3BlY3Rpb25FdmVudCA9IHtcbiAgICAgIC4uLmV2ZW50LFxuICAgICAgcm9vdElkOiByb290QWN0b3Iuc2Vzc2lvbklkXG4gICAgfTtcbiAgICBpbnNwZWN0aW9uT2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIubmV4dD8uKHJlc29sdmVkSW5zcGVjdGlvbkV2ZW50KSk7XG4gIH07XG4gIGNvbnN0IHN5c3RlbSA9IHtcbiAgICBfc25hcHNob3Q6IHtcbiAgICAgIF9zY2hlZHVsZWRFdmVudHM6IChvcHRpb25zPy5zbmFwc2hvdCAmJiBvcHRpb25zLnNuYXBzaG90LnNjaGVkdWxlcikgPz8ge31cbiAgICB9LFxuICAgIF9ib29rSWQ6ICgpID0+IGB4OiR7aWRDb3VudGVyKyt9YCxcbiAgICBfcmVnaXN0ZXI6IChzZXNzaW9uSWQsIGFjdG9yUmVmKSA9PiB7XG4gICAgICBjaGlsZHJlbi5zZXQoc2Vzc2lvbklkLCBhY3RvclJlZik7XG4gICAgICByZXR1cm4gc2Vzc2lvbklkO1xuICAgIH0sXG4gICAgX3VucmVnaXN0ZXI6IGFjdG9yUmVmID0+IHtcbiAgICAgIGNoaWxkcmVuLmRlbGV0ZShhY3RvclJlZi5zZXNzaW9uSWQpO1xuICAgICAgY29uc3Qgc3lzdGVtSWQgPSByZXZlcnNlS2V5ZWRBY3RvcnMuZ2V0KGFjdG9yUmVmKTtcbiAgICAgIGlmIChzeXN0ZW1JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleWVkQWN0b3JzLmRlbGV0ZShzeXN0ZW1JZCk7XG4gICAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5kZWxldGUoYWN0b3JSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiBzeXN0ZW1JZCA9PiB7XG4gICAgICByZXR1cm4ga2V5ZWRBY3RvcnMuZ2V0KHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIGdldEFsbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhrZXllZEFjdG9ycy5lbnRyaWVzKCkpO1xuICAgIH0sXG4gICAgX3NldDogKHN5c3RlbUlkLCBhY3RvclJlZikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nICE9PSBhY3RvclJlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdG9yIHdpdGggc3lzdGVtIElEICcke3N5c3RlbUlkfScgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICB9XG4gICAgICBrZXllZEFjdG9ycy5zZXQoc3lzdGVtSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5zZXQoYWN0b3JSZWYsIHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIGluc3BlY3Q6IG9ic2VydmVyT3JGbiA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckZuKTtcbiAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIF9zZW5kSW5zcGVjdGlvbkV2ZW50OiBzZW5kSW5zcGVjdGlvbkV2ZW50LFxuICAgIF9yZWxheTogKHNvdXJjZSwgdGFyZ2V0LCBldmVudCkgPT4ge1xuICAgICAgc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgICAgdHlwZTogJ0B4c3RhdGUuZXZlbnQnLFxuICAgICAgICBzb3VyY2VSZWY6IHNvdXJjZSxcbiAgICAgICAgYWN0b3JSZWY6IHRhcmdldCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0Ll9zZW5kKGV2ZW50KTtcbiAgICB9LFxuICAgIHNjaGVkdWxlcixcbiAgICBnZXRTbmFwc2hvdDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3NjaGVkdWxlZEV2ZW50czoge1xuICAgICAgICAgIC4uLnN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50cyA9IHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cztcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBzY2hlZHVsZWRJZCBpbiBzY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IHNjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRJZF07XG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZShzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2xvY2s6IGNsb2NrLFxuICAgIF9sb2dnZXI6IGxvZ2dlclxuICB9O1xuICByZXR1cm4gc3lzdGVtO1xufVxuXG4vLyB0aG9zZSBhcmUgbmVlZGVkIHRvIG1ha2UgSlNEb2MgYEBsaW5rYCB3b3JrIHByb3Blcmx5XG5cbmxldCBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSBmYWxzZTtcbmNvbnN0ICQkQUNUT1JfVFlQRSA9IDE7XG5cbi8vIHRob3NlIHZhbHVlcyBhcmUgY3VycmVudGx5IHVzZWQgYnkgQHhzdGF0ZS9yZWFjdCBkaXJlY3RseSBzbyBpdCdzIGltcG9ydGFudCB0byBrZWVwIHRoZSBhc3NpZ25lZCB2YWx1ZXMgaW4gc3luY1xubGV0IFByb2Nlc3NpbmdTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFByb2Nlc3NpbmdTdGF0dXMpIHtcbiAgUHJvY2Vzc2luZ1N0YXR1c1tQcm9jZXNzaW5nU3RhdHVzW1wiTm90U3RhcnRlZFwiXSA9IDBdID0gXCJOb3RTdGFydGVkXCI7XG4gIFByb2Nlc3NpbmdTdGF0dXNbUHJvY2Vzc2luZ1N0YXR1c1tcIlJ1bm5pbmdcIl0gPSAxXSA9IFwiUnVubmluZ1wiO1xuICBQcm9jZXNzaW5nU3RhdHVzW1Byb2Nlc3NpbmdTdGF0dXNbXCJTdG9wcGVkXCJdID0gMl0gPSBcIlN0b3BwZWRcIjtcbiAgcmV0dXJuIFByb2Nlc3NpbmdTdGF0dXM7XG59KHt9KTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjbG9jazoge1xuICAgIHNldFRpbWVvdXQ6IChmbiwgbXMpID0+IHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gICAgfSxcbiAgICBjbGVhclRpbWVvdXQ6IGlkID0+IHtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cbiAgfSxcbiAgbG9nZ2VyOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICBkZXZUb29sczogZmFsc2Vcbn07XG5cbi8qKlxuICogQW4gQWN0b3IgaXMgYSBydW5uaW5nIHByb2Nlc3MgdGhhdCBjYW4gcmVjZWl2ZSBldmVudHMsIHNlbmQgZXZlbnRzIGFuZCBjaGFuZ2VcbiAqIGl0cyBiZWhhdmlvciBiYXNlZCBvbiB0aGUgZXZlbnRzIGl0IHJlY2VpdmVzLCB3aGljaCBjYW4gY2F1c2UgZWZmZWN0cyBvdXRzaWRlXG4gKiBvZiB0aGUgYWN0b3IuIFdoZW4geW91IHJ1biBhIHN0YXRlIG1hY2hpbmUsIGl0IGJlY29tZXMgYW4gYWN0b3IuXG4gKi9cbmNsYXNzIEFjdG9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYWN0b3IgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBsb2dpYyB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLFxuICAgKiBpZiBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpYyBUaGUgbG9naWMgdG8gY3JlYXRlIGFuIGFjdG9yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgQWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IobG9naWMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2ljID0gbG9naWM7XG4gICAgLyoqIFRoZSBjdXJyZW50IGludGVybmFsIHN0YXRlIG9mIHRoZSBhY3Rvci4gKi9cbiAgICB0aGlzLl9zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xvY2sgdGhhdCBpcyByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbmQgY2xlYXJpbmcgdGltZW91dHMsIHN1Y2ggYXNcbiAgICAgKiBkZWxheWVkIGV2ZW50cyBhbmQgdHJhbnNpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5jbG9jayA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3RvciByZWxhdGl2ZSB0byBpdHMgcGFyZW50LiAqL1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWlsYm94ID0gbmV3IE1haWxib3godGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5Ob3RTdGFydGVkO1xuICAgIC8vIEFjdG9yIFJlZlxuICAgIHRoaXMuX3BhcmVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3luY1NuYXBzaG90ID0gdm9pZCAwO1xuICAgIHRoaXMucmVmID0gdm9pZCAwO1xuICAgIC8vIFRPRE86IGFkZCB0eXBpbmdzIGZvciBzeXN0ZW1cbiAgICB0aGlzLl9hY3RvclNjb3BlID0gdm9pZCAwO1xuICAgIHRoaXMuc3lzdGVtSWQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBnbG9iYWxseSB1bmlxdWUgcHJvY2VzcyBJRCBmb3IgdGhpcyBpbnZvY2F0aW9uLiAqL1xuICAgIHRoaXMuc2Vzc2lvbklkID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgc3lzdGVtIHRvIHdoaWNoIHRoaXMgYWN0b3IgYmVsb25ncy4gKi9cbiAgICB0aGlzLnN5c3RlbSA9IHZvaWQgMDtcbiAgICB0aGlzLl9kb25lRXZlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zcmMgPSB2b2lkIDA7XG4gICAgLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGRlZmVyXG4gICAgdGhpcy5fZGVmZXJyZWQgPSBbXTtcbiAgICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGNsb2NrLFxuICAgICAgbG9nZ2VyLFxuICAgICAgcGFyZW50LFxuICAgICAgc3luY1NuYXBzaG90LFxuICAgICAgaWQsXG4gICAgICBzeXN0ZW1JZCxcbiAgICAgIGluc3BlY3RcbiAgICB9ID0gcmVzb2x2ZWRPcHRpb25zO1xuICAgIHRoaXMuc3lzdGVtID0gcGFyZW50ID8gcGFyZW50LnN5c3RlbSA6IGNyZWF0ZVN5c3RlbSh0aGlzLCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxvZ2dlclxuICAgIH0pO1xuICAgIGlmIChpbnNwZWN0ICYmICFwYXJlbnQpIHtcbiAgICAgIC8vIEFsd2F5cyBpbnNwZWN0IGF0IHRoZSBzeXN0ZW0tbGV2ZWxcbiAgICAgIHRoaXMuc3lzdGVtLmluc3BlY3QodG9PYnNlcnZlcihpbnNwZWN0KSk7XG4gICAgfVxuICAgIHRoaXMuc2Vzc2lvbklkID0gdGhpcy5zeXN0ZW0uX2Jvb2tJZCgpO1xuICAgIHRoaXMuaWQgPSBpZCA/PyB0aGlzLnNlc3Npb25JZDtcbiAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnM/LmxvZ2dlciA/PyB0aGlzLnN5c3RlbS5fbG9nZ2VyO1xuICAgIHRoaXMuY2xvY2sgPSBvcHRpb25zPy5jbG9jayA/PyB0aGlzLnN5c3RlbS5fY2xvY2s7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX3N5bmNTbmFwc2hvdCA9IHN5bmNTbmFwc2hvdDtcbiAgICB0aGlzLm9wdGlvbnMgPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgdGhpcy5zcmMgPSByZXNvbHZlZE9wdGlvbnMuc3JjID8/IGxvZ2ljO1xuICAgIHRoaXMucmVmID0gdGhpcztcbiAgICB0aGlzLl9hY3RvclNjb3BlID0ge1xuICAgICAgc2VsZjogdGhpcyxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICBkZWZlcjogZm4gPT4ge1xuICAgICAgICB0aGlzLl9kZWZlcnJlZC5wdXNoKGZuKTtcbiAgICAgIH0sXG4gICAgICBzeXN0ZW06IHRoaXMuc3lzdGVtLFxuICAgICAgc3RvcENoaWxkOiBjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5fcGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3RvcCBjaGlsZCBhY3RvciAke2NoaWxkLmlkfSBvZiAke3RoaXMuaWR9IGJlY2F1c2UgaXQgaXMgbm90IGEgY2hpbGRgKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5fc3RvcCgpO1xuICAgICAgfSxcbiAgICAgIGVtaXQ6IGVtaXR0ZWRFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGVtaXR0ZWRFdmVudC50eXBlKTtcbiAgICAgICAgY29uc3Qgd2lsZGNhcmRMaXN0ZW5lciA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KCcqJyk7XG4gICAgICAgIGlmICghbGlzdGVuZXJzICYmICF3aWxkY2FyZExpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IFsuLi4obGlzdGVuZXJzID8gbGlzdGVuZXJzLnZhbHVlcygpIDogW10pLCAuLi4od2lsZGNhcmRMaXN0ZW5lciA/IHdpbGRjYXJkTGlzdGVuZXIudmFsdWVzKCkgOiBbXSldO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgYWxsTGlzdGVuZXJzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhhbmRsZXIoZW1pdHRlZEV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWN0aW9uRXhlY3V0b3I6IGFjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGV4ZWMgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYWN0b3JTY29wZS5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ0B4c3RhdGUuYWN0aW9uJyxcbiAgICAgICAgICAgIGFjdG9yUmVmOiB0aGlzLFxuICAgICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICAgIHR5cGU6IGFjdGlvbi50eXBlLFxuICAgICAgICAgICAgICBwYXJhbXM6IGFjdGlvbi5wYXJhbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWFjdGlvbi5leGVjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNhdmVFeGVjdXRpbmdDdXN0b21BY3Rpb24gPSBleGVjdXRpbmdDdXN0b21BY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBhY3Rpb24uZXhlYyhhY3Rpb24uaW5mbywgYWN0aW9uLnBhcmFtcyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiA9IHNhdmVFeGVjdXRpbmdDdXN0b21BY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAgICAgZXhlYygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RlZmVycmVkLnB1c2goZXhlYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbmQgbWV0aG9kIGlzIGJvdW5kIHRvIHRoaXMgQWN0b3IgaW5zdGFuY2VcbiAgICAvLyBpZiBkZXN0cnVjdHVyZWRcbiAgICB0aGlzLnNlbmQgPSB0aGlzLnNlbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5hY3RvcicsXG4gICAgICBhY3RvclJlZjogdGhpc1xuICAgIH0pO1xuICAgIGlmIChzeXN0ZW1JZCkge1xuICAgICAgdGhpcy5zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuICAgICAgdGhpcy5zeXN0ZW0uX3NldChzeXN0ZW1JZCwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRTdGF0ZShvcHRpb25zPy5zbmFwc2hvdCA/PyBvcHRpb25zPy5zdGF0ZSk7XG4gICAgaWYgKHN5c3RlbUlkICYmIHRoaXMuX3NuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl91bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBfaW5pdFN0YXRlKHBlcnNpc3RlZFN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0gcGVyc2lzdGVkU3RhdGUgPyB0aGlzLmxvZ2ljLnJlc3RvcmVTbmFwc2hvdCA/IHRoaXMubG9naWMucmVzdG9yZVNuYXBzaG90KHBlcnNpc3RlZFN0YXRlLCB0aGlzLl9hY3RvclNjb3BlKSA6IHBlcnNpc3RlZFN0YXRlIDogdGhpcy5sb2dpYy5nZXRJbml0aWFsU25hcHNob3QodGhpcy5fYWN0b3JTY29wZSwgdGhpcy5vcHRpb25zPy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpZiB3ZSBnZXQgaGVyZSB0aGVuIGl0IG1lYW5zIHRoYXQgd2UgYXNzaWduIGEgdmFsdWUgdG8gdGhpcy5fc25hcHNob3QgdGhhdCBpcyBub3Qgb2YgdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgLy8gd2UgY2FuJ3QgZ2V0IHRoZSB0cnVlIGBUU25hcHNob3QgJiB7IHN0YXR1czogJ2Vycm9yJzsgfWAsIGl0J3MgaW1wb3NzaWJsZVxuICAgICAgLy8gc28gcmlnaHQgbm93IHRoaXMgaXMgYSBsaWUgb2Ygc29ydHNcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB1cGRhdGUoc25hcHNob3QsIGV2ZW50KSB7XG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgdGhpcy5fc25hcHNob3QgPSBzbmFwc2hvdDtcblxuICAgIC8vIEV4ZWN1dGUgZGVmZXJyZWQgZWZmZWN0c1xuICAgIGxldCBkZWZlcnJlZEZuO1xuICAgIHdoaWxlIChkZWZlcnJlZEZuID0gdGhpcy5fZGVmZXJyZWQuc2hpZnQoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVmZXJyZWRGbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHRoaXMgZXJyb3IgY2FuIG9ubHkgYmUgY2F1Z2h0IHdoZW4gZXhlY3V0aW5nICppbml0aWFsKiBhY3Rpb25zXG4gICAgICAgIC8vIGl0J3MgdGhlIG9ubHkgdGltZSB3aGVuIHdlIGNhbGwgYWN0aW9ucyBwcm92aWRlZCBieSB0aGUgdXNlciB0aHJvdWdoIHRob3NlIGRlZmVycmVkc1xuICAgICAgICAvLyB3aGVuIHRoZSBhY3RvciBpcyBhbHJlYWR5IHJ1bm5pbmcgd2UgYWx3YXlzIGV4ZWN1dGUgdGhlbSBzeW5jaHJvbm91c2x5IHdoaWxlIHRyYW5zaXRpb25pbmdcbiAgICAgICAgLy8gbm8gXCJidWlsdGluIGRlZmVycmVkXCIgc2hvdWxkIGFjdHVhbGx5IHRocm93IGFuIGVycm9yIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBzYWZlXG4gICAgICAgIC8vIG9yIHRoZSBjb250cm9sIGZsb3cgaXMgcGFzc2VkIHRocm91Z2ggdGhlIG1haWxib3ggYW5kIGVycm9ycyBzaG91bGQgYmUgY2F1Z2h0IGJ5IHRoZSBgX3Byb2Nlc3NgIHVzZWQgYnkgdGhlIG1haWxib3hcbiAgICAgICAgdGhpcy5fZGVmZXJyZWQubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIG5leHQgb2JzZXJ2ZXJzIGFyZSBtZWFudCB0byBiZSBub3RpZmllZCBhYm91dCBkb25lIHNuYXBzaG90c1xuICAgICAgICAvLyB0aGlzIGNhbiBiZSBzZWVuIGFzIHNvbWV0aGluZyB0aGF0IGlzIGRpZmZlcmVudCBmcm9tIGhvdyBvYnNlcnZhYmxlIHdvcmtcbiAgICAgICAgLy8gYnV0IHdpdGggb2JzZXJ2YWJsZXMgYGNvbXBsZXRlYCBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzXG4gICAgICAgIC8vIGl0J3MgbW9yZSBlcmdvbm9taWMgZm9yIFhTdGF0ZSB0byB0cmVhdCBhIGRvbmUgc25hcHNob3QgYXMgYSBcIm5leHRcIiB2YWx1ZVxuICAgICAgICAvLyBhbmQgdGhlIGNvbXBsZXRpb24gZXZlbnQgYXMgc29tZXRoaW5nIHRoYXQgaXMgc2VwYXJhdGUsXG4gICAgICAgIC8vIHNvbWV0aGluZyB0aGF0IG1lcmVseSBmb2xsb3dzIGVtaXR0aW5nIHRoYXQgZG9uZSBzbmFwc2hvdFxuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQ/LihzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX2RvbmVFdmVudCA9IGNyZWF0ZURvbmVBY3RvckV2ZW50KHRoaXMuaWQsIHRoaXMuX3NuYXBzaG90Lm91dHB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCB0aGlzLl9kb25lRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB0aGlzLl9lcnJvcih0aGlzLl9zbmFwc2hvdC5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5zbmFwc2hvdCcsXG4gICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgIGV2ZW50LFxuICAgICAgc25hcHNob3RcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgYW4gb2JzZXJ2ZXIgdG8gYW4gYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIG9ic2VydmVyIHdpbGwgcmVjZWl2ZSB0aGUgYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlIHdoZW4gaXQgaXMgZW1pdHRlZC5cbiAgICogVGhlIG9ic2VydmVyIGNhbiBiZTpcbiAgICpcbiAgICogLSBBIHBsYWluIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCBzbmFwc2hvdCwgb3JcbiAgICogLSBBbiBvYnNlcnZlciBvYmplY3Qgd2hvc2UgYC5uZXh0KHNuYXBzaG90KWAgbWV0aG9kIHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBPYnNlcnZlciBhcyBhIHBsYWluIGZ1bmN0aW9uXG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gT2JzZXJ2ZXIgYXMgYW4gb2JqZWN0XG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSh7XG4gICAqICAgbmV4dChzbmFwc2hvdCkge1xuICAgKiAgICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICAgKiAgIH0sXG4gICAqICAgZXJyb3IoZXJyKSB7XG4gICAqICAgICAvLyAuLi5cbiAgICogICB9LFxuICAgKiAgIGNvbXBsZXRlKCkge1xuICAgKiAgICAgLy8gLi4uXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgYGFjdG9yLnN1YnNjcmliZShvYnNlcnZlcilgIGlzIGEgc3Vic2NyaXB0aW9uIG9iamVjdFxuICAgKiB0aGF0IGhhcyBhbiBgLnVuc3Vic2NyaWJlKClgIG1ldGhvZC4gWW91IGNhbiBjYWxsXG4gICAqIGBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKWAgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmVyOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gICAqICAgLy8gLi4uXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgb2JzZXJ2ZXJcbiAgICogc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaGVuIHRoZSBhY3RvciBpcyBzdG9wcGVkLCBhbGwgb2YgaXRzIG9ic2VydmVycyB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICogdW5zdWJzY3JpYmVkLlxuICAgKlxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBFaXRoZXIgYSBwbGFpbiBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdCwgb3IgYW4gb2JzZXJ2ZXIgb2JqZWN0IHdob3NlIGAubmV4dChzbmFwc2hvdClgIG1ldGhvZCByZWNlaXZlc1xuICAgKiAgIHRoZSBsYXRlc3Qgc25hcHNob3RcbiAgICovXG5cbiAgc3Vic2NyaWJlKG5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIsIGVycm9yTGlzdGVuZXIsIGNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIobmV4dExpc3RlbmVyT3JPYnNlcnZlciwgZXJyb3JMaXN0ZW5lciwgY29tcGxldGVMaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fc25hcHNob3QuZXJyb3I7XG4gICAgICAgICAgICBpZiAoIW9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KHR5cGUpO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldCh0eXBlLCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IGhhbmRsZXIuYmluZCh1bmRlZmluZWQpO1xuICAgIGxpc3RlbmVycy5hZGQod3JhcHBlZEhhbmRsZXIpO1xuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqIFN0YXJ0cyB0aGUgQWN0b3IgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAvLyBEbyBub3QgcmVzdGFydCB0aGUgc2VydmljZSBpZiBpdCBpcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3luY1NuYXBzaG90KSB7XG4gICAgICB0aGlzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICBpZiAoc25hcHNob3Quc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHRoaXMsIHRoaXMuX3BhcmVudCwge1xuICAgICAgICAgICAgICB0eXBlOiBgeHN0YXRlLnNuYXBzaG90LiR7dGhpcy5pZH1gLFxuICAgICAgICAgICAgICBzbmFwc2hvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fcmVnaXN0ZXIodGhpcy5zZXNzaW9uSWQsIHRoaXMpO1xuICAgIGlmICh0aGlzLnN5c3RlbUlkKSB7XG4gICAgICB0aGlzLnN5c3RlbS5fc2V0KHRoaXMuc3lzdGVtSWQsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nO1xuXG4gICAgLy8gVE9ETzogdGhpcyBpc24ndCBjb3JyZWN0IHdoZW4gcmVoeWRyYXRpbmdcbiAgICBjb25zdCBpbml0RXZlbnQgPSBjcmVhdGVJbml0RXZlbnQodGhpcy5vcHRpb25zLmlucHV0KTtcbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5ldmVudCcsXG4gICAgICBzb3VyY2VSZWY6IHRoaXMuX3BhcmVudCxcbiAgICAgIGFjdG9yUmVmOiB0aGlzLFxuICAgICAgZXZlbnQ6IGluaXRFdmVudFxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuX3NuYXBzaG90LnN0YXR1cztcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIGEgc3RhdGUgbWFjaGluZSBjYW4gYmUgXCJkb25lXCIgdXBvbiBpbml0aWFsaXphdGlvbiAoaXQgY291bGQgcmVhY2ggYSBmaW5hbCBzdGF0ZSB1c2luZyBpbml0aWFsIG1pY3Jvc3RlcHMpXG4gICAgICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gY29tcGxldGUgb2JzZXJ2ZXJzLCBmbHVzaCBkZWZlcnJlZHMgZXRjXG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuX3NuYXBzaG90LCBpbml0RXZlbnQpO1xuICAgICAgICAvLyBUT0RPOiByZXRoaW5rIGNsZWFudXAgb2Ygb2JzZXJ2ZXJzLCBtYWlsYm94LCBldGNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHRoaXMuX2Vycm9yKHRoaXMuX3NuYXBzaG90LmVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLnN5c3RlbS5zdGFydCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dpYy5zdGFydCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2dpYy5zdGFydCh0aGlzLl9zbmFwc2hvdCwgdGhpcy5fYWN0b3JTY29wZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgICAgLi4udGhpcy5fc25hcHNob3QsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBub3RpZmllcyBhbGwgc3Vic2NyaWJlcnMgYnV0IHVzdWFsbHkgdGhpcyBpcyByZWR1bmRhbnRcbiAgICAvLyB0aGVyZSBpcyBubyByZWFsIGNoYW5nZSBoYXBwZW5pbmcgaGVyZVxuICAgIC8vIHdlIG5lZWQgdG8gcmV0aGluayBpZiB0aGlzIG5lZWRzIHRvIGJlIHJlZmFjdG9yZWRcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLl9zbmFwc2hvdCwgaW5pdEV2ZW50KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRldlRvb2xzKSB7XG4gICAgICB0aGlzLmF0dGFjaERldlRvb2xzKCk7XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5zdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9wcm9jZXNzKGV2ZW50KSB7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgY2F1Z2h0RXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5leHRTdGF0ZSA9IHRoaXMubG9naWMudHJhbnNpdGlvbih0aGlzLl9zbmFwc2hvdCwgZXZlbnQsIHRoaXMuX2FjdG9yU2NvcGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gd2Ugd3JhcCBpdCBpbiBhIGJveCBzbyB3ZSBjYW4gcmV0aHJvdyBpdCBsYXRlciBldmVuIGlmIGZhbHN5IHZhbHVlIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgIGNhdWdodEVycm9yID0ge1xuICAgICAgICBlcnJcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJcbiAgICAgIH0gPSBjYXVnaHRFcnJvcjtcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICAuLi50aGlzLl9zbmFwc2hvdCxcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9O1xuICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUobmV4dFN0YXRlLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFhTVEFURV9TVE9QKSB7XG4gICAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuICBfc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuTm90U3RhcnRlZCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guZW5xdWV1ZSh7XG4gICAgICB0eXBlOiBYU1RBVEVfU1RPUFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIFN0b3BzIHRoZSBBY3RvciBhbmQgdW5zdWJzY3JpYmUgYWxsIGxpc3RlbmVycy4gKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egbm9uLXJvb3QgYWN0b3IgY2Fubm90IGJlIHN0b3BwZWQgZGlyZWN0bHkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdG9wKCk7XG4gIH1cbiAgX2NvbXBsZXRlKCkge1xuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBfcmVwb3J0RXJyb3IoZXJyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmVwb3J0RXJyb3IgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICBjb25zdCBlcnJvckxpc3RlbmVyID0gb2JzZXJ2ZXIuZXJyb3I7XG4gICAgICByZXBvcnRFcnJvciB8fD0gIWVycm9yTGlzdGVuZXI7XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckxpc3RlbmVyPy4oZXJyKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5jbGVhcigpO1xuICAgIGlmIChyZXBvcnRFcnJvcikge1xuICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgX2Vycm9yKGVycikge1xuICAgIHRoaXMuX3N0b3BQcm9jZWR1cmUoKTtcbiAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnIpO1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl9yZWxheSh0aGlzLCB0aGlzLl9wYXJlbnQsIGNyZWF0ZUVycm9yQWN0b3JFdmVudCh0aGlzLmlkLCBlcnIpKTtcbiAgICB9XG4gIH1cbiAgLy8gVE9ETzogYXRtIGNoaWxkcmVuIGRvbid0IGJlbG9uZyBlbnRpcmVseSB0byB0aGUgYWN0b3Igc29cbiAgLy8gaW4gYSB3YXkgLSBpdCdzIG5vdCBldmVuIHN1cGVyIGF3YXJlIG9mIHRoZW1cbiAgLy8gc28gd2UgY2FuJ3Qgc3RvcCB0aGVtIGZyb20gaGVyZSBidXQgd2UgcmVhbGx5IHNob3VsZCFcbiAgLy8gcmlnaHQgbm93LCB0aGV5IGFyZSBiZWluZyBzdG9wcGVkIHdpdGhpbiB0aGUgbWFjaGluZSdzIHRyYW5zaXRpb25cbiAgLy8gYnV0IHRoYXQgY291bGQgdGhyb3cgYW5kIGxlYXZlIHVzIHdpdGggXCJvcnBoYW5lZFwiIGFjdGl2ZSBhY3RvcnNcbiAgX3N0b3BQcm9jZWR1cmUoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZykge1xuICAgICAgLy8gQWN0b3IgYWxyZWFkeSBzdG9wcGVkOyBkbyBub3RoaW5nXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBDYW5jZWwgYWxsIGRlbGF5ZWQgZXZlbnRzXG4gICAgdGhpcy5zeXN0ZW0uc2NoZWR1bGVyLmNhbmNlbEFsbCh0aGlzKTtcblxuICAgIC8vIFRPRE86IG1haWxib3gucmVzZXRcbiAgICB0aGlzLm1haWxib3guY2xlYXIoKTtcbiAgICAvLyBUT0RPOiBhZnRlciBgc3RvcGAgd2UgbXVzdCBwcmVwYXJlIG91cnNlbHZlcyBmb3IgcmVjZWl2aW5nIGV2ZW50cyBhZ2FpblxuICAgIC8vIGV2ZW50cyBzZW50ICphZnRlciogc3RvcCBzaWduYWwgbXVzdCBiZSBxdWV1ZWRcbiAgICAvLyBpdCBzZWVtcyBsaWtlIHRoaXMgc2hvdWxkIGJlIHRoZSBjb21tb24gYmVoYXZpb3IgZm9yIGFsbCBvZiBvdXIgY29uc3VtZXJzXG4gICAgLy8gc28gcGVyaGFwcyB0aGlzIHNob3VsZCBiZSB1bmlmaWVkIHNvbWVob3cgZm9yIGFsbCBvZiB0aGVtXG4gICAgdGhpcy5tYWlsYm94ID0gbmV3IE1haWxib3godGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkO1xuICAgIHRoaXMuc3lzdGVtLl91bnJlZ2lzdGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VuZChldmVudCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIHtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShldmVudCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXZlbnQgXCIke2V2ZW50LnR5cGV9XCIgd2FzIHNlbnQgdG8gc3RvcHBlZCBhY3RvciBcIiR7dGhpcy5pZH0gKCR7dGhpcy5zZXNzaW9uSWR9KVwiLiBUaGlzIGFjdG9yIGhhcyBhbHJlYWR5IHJlYWNoZWQgaXRzIGZpbmFsIHN0YXRlLCBhbmQgd2lsbCBub3QgdHJhbnNpdGlvbi5cXG5FdmVudDogJHtldmVudFN0cmluZ31gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmVucXVldWUoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoZSBydW5uaW5nIEFjdG9yIHRvIHRyaWdnZXIgYSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmRcbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGV2ZW50IG9iamVjdHMgbWF5IGJlIHNlbnQgdG8gYWN0b3JzOyB1c2UgLnNlbmQoeyB0eXBlOiBcIiR7ZXZlbnR9XCIgfSkgaW5zdGVhZGApO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fcmVsYXkodW5kZWZpbmVkLCB0aGlzLCBldmVudCk7XG4gIH1cbiAgYXR0YWNoRGV2VG9vbHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGV2VG9vbHNcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChkZXZUb29scykge1xuICAgICAgY29uc3QgcmVzb2x2ZWREZXZUb29sc0FkYXB0ZXIgPSB0eXBlb2YgZGV2VG9vbHMgPT09ICdmdW5jdGlvbicgPyBkZXZUb29scyA6IGRldlRvb2xzQWRhcHRlcjtcbiAgICAgIHJlc29sdmVkRGV2VG9vbHNBZGFwdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhzdGF0ZSQkdHlwZTogJCRBQ1RPUl9UWVBFLFxuICAgICAgaWQ6IHRoaXMuaWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGFjdG9yLCB3aGljaCBjYW4gYmUgcGVyc2lzdGVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgaW50ZXJuYWwgc3RhdGUgY2FuIGJlIHBlcnNpc3RlZCBmcm9tIGFueSBhY3Rvciwgbm90IG9ubHkgbWFjaGluZXMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgcGVyc2lzdGVkIHN0YXRlIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgc25hcHNob3QgZnJvbVxuICAgKiB7QGxpbmsgQWN0b3IuZ2V0U25hcHNob3R9LiBQZXJzaXN0ZWQgc3RhdGUgcmVwcmVzZW50cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2ZcbiAgICogdGhlIGFjdG9yLCB3aGlsZSBzbmFwc2hvdHMgcmVwcmVzZW50IHRoZSBhY3RvcidzIGxhc3QgZW1pdHRlZCB2YWx1ZS5cbiAgICpcbiAgICogQ2FuIGJlIHJlc3RvcmVkIHdpdGgge0BsaW5rIEFjdG9yT3B0aW9ucy5zdGF0ZX1cbiAgICogQHNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9wZXJzaXN0ZW5jZVxuICAgKi9cblxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubG9naWMuZ2V0UGVyc2lzdGVkU25hcHNob3QodGhpcy5fc25hcHNob3QsIG9wdGlvbnMpO1xuICB9XG4gIFtzeW1ib2xPYnNlcnZhYmxlXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGFuIGFjdG9y4oCZcyBzbmFwc2hvdCBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgc25hcHNob3QgcmVwcmVzZW50IGFuIGFjdG9yJ3MgbGFzdCBlbWl0dGVkIHZhbHVlLlxuICAgKlxuICAgKiBXaGVuIGFuIGFjdG9yIHJlY2VpdmVzIGFuIGV2ZW50LCBpdHMgaW50ZXJuYWwgc3RhdGUgbWF5IGNoYW5nZS4gQW4gYWN0b3JcbiAgICogbWF5IGVtaXQgYSBzbmFwc2hvdCB3aGVuIGEgc3RhdGUgdHJhbnNpdGlvbiBvY2N1cnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzb21lIGFjdG9ycywgc3VjaCBhcyBjYWxsYmFjayBhY3RvcnMgZ2VuZXJhdGVkIHdpdGhcbiAgICogYGZyb21DYWxsYmFja2AsIHdpbGwgbm90IGVtaXQgc25hcHNob3RzLlxuICAgKiBAc2VlIHtAbGluayBBY3Rvci5zdWJzY3JpYmV9IHRvIHN1YnNjcmliZSB0byBhbiBhY3RvcuKAmXMgc25hcHNob3QgdmFsdWVzLlxuICAgKiBAc2VlIHtAbGluayBBY3Rvci5nZXRQZXJzaXN0ZWRTbmFwc2hvdH0gdG8gcGVyc2lzdCB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYW4gYWN0b3IgKHdoaWNoIGlzIG1vcmUgdGhhbiBqdXN0IGEgc25hcHNob3QpLlxuICAgKi9cbiAgZ2V0U25hcHNob3QoKSB7XG4gICAgaWYgKCF0aGlzLl9zbmFwc2hvdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwc2hvdCBjYW4ndCBiZSByZWFkIHdoaWxlIHRoZSBhY3RvciBpbml0aWFsaXplcyBpdHNlbGZgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NuYXBzaG90O1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYWN0b3IgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhY3RvciBsb2dpYyB3aXRoIHRoZSBwcm92aWRlZFxuICogb3B0aW9ucywgaWYgYW55LlxuICpcbiAqIEByZW1hcmtzXG4gKiBXaGVuIHlvdSBjcmVhdGUgYW4gYWN0b3IgZnJvbSBhY3RvciBsb2dpYyB2aWEgYGNyZWF0ZUFjdG9yKGxvZ2ljKWAsIHlvdVxuICogaW1wbGljaXRseSBjcmVhdGUgYW4gYWN0b3Igc3lzdGVtIHdoZXJlIHRoZSBjcmVhdGVkIGFjdG9yIGlzIHRoZSByb290IGFjdG9yLlxuICogQW55IGFjdG9ycyBzcGF3bmVkIGZyb20gdGhpcyByb290IGFjdG9yIGFuZCBpdHMgZGVzY2VuZGFudHMgYXJlIHBhcnQgb2YgdGhhdFxuICogYWN0b3Igc3lzdGVtLlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgc29tZUFjdG9yTG9naWMgfSBmcm9tICcuL3NvbWVBY3RvckxvZ2ljLnRzJztcbiAqXG4gKiAvLyBDcmVhdGluZyB0aGUgYWN0b3IsIHdoaWNoIGltcGxpY2l0bHkgY3JlYXRlcyBhbiBhY3RvciBzeXN0ZW0gd2l0aCBpdHNlbGYgYXMgdGhlIHJvb3QgYWN0b3JcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3Ioc29tZUFjdG9yTG9naWMpO1xuICpcbiAqIGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICogfSk7XG4gKlxuICogLy8gQWN0b3JzIG11c3QgYmUgc3RhcnRlZCBieSBjYWxsaW5nIGBhY3Rvci5zdGFydCgpYCwgd2hpY2ggd2lsbCBhbHNvIHN0YXJ0IHRoZSBhY3RvciBzeXN0ZW0uXG4gKiBhY3Rvci5zdGFydCgpO1xuICpcbiAqIC8vIEFjdG9ycyBjYW4gcmVjZWl2ZSBldmVudHNcbiAqIGFjdG9yLnNlbmQoeyB0eXBlOiAnc29tZUV2ZW50JyB9KTtcbiAqXG4gKiAvLyBZb3UgY2FuIHN0b3Agcm9vdCBhY3RvcnMgYnkgY2FsbGluZyBgYWN0b3Iuc3RvcCgpYCwgd2hpY2ggd2lsbCBhbHNvIHN0b3AgdGhlIGFjdG9yIHN5c3RlbSBhbmQgYWxsIGFjdG9ycyBpbiB0aGF0IHN5c3RlbS5cbiAqIGFjdG9yLnN0b3AoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsb2dpYyAtIFRoZSBhY3RvciBsb2dpYyB0byBjcmVhdGUgYW4gYWN0b3IgZnJvbS4gRm9yIGEgc3RhdGUgbWFjaGluZVxuICogICBhY3RvciBsb2dpYyBjcmVhdG9yLCBzZWUge0BsaW5rIGNyZWF0ZU1hY2hpbmV9LiBPdGhlciBhY3RvciBsb2dpYyBjcmVhdG9yc1xuICogICBpbmNsdWRlIHtAbGluayBmcm9tQ2FsbGJhY2t9LCB7QGxpbmsgZnJvbUV2ZW50T2JzZXJ2YWJsZX0sXG4gKiAgIHtAbGluayBmcm9tT2JzZXJ2YWJsZX0sIHtAbGluayBmcm9tUHJvbWlzZX0sIGFuZCB7QGxpbmsgZnJvbVRyYW5zaXRpb259LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBY3RvciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFjdG9yKGxvZ2ljLCAuLi5bb3B0aW9uc10pIHtcbiAgcmV0dXJuIG5ldyBBY3Rvcihsb2dpYywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBJbnRlcnByZXRlciBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIG1hY2hpbmUgd2l0aCB0aGUgcHJvdmlkZWRcbiAqIG9wdGlvbnMsIGlmIGFueS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGNyZWF0ZUFjdG9yYCBpbnN0ZWFkXG4gKiBAYWxpYXNcbiAqL1xuY29uc3QgaW50ZXJwcmV0ID0gY3JlYXRlQWN0b3I7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBBY3RvcmAgaW5zdGVhZC5cbiAqIEBhbGlhc1xuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVDYW5jZWwoXywgc25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBzZW5kSWRcbn0pIHtcbiAgY29uc3QgcmVzb2x2ZWRTZW5kSWQgPSB0eXBlb2Ygc2VuZElkID09PSAnZnVuY3Rpb24nID8gc2VuZElkKGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcykgOiBzZW5kSWQ7XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICBzZW5kSWQ6IHJlc29sdmVkU2VuZElkXG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlQ2FuY2VsKGFjdG9yU2NvcGUsIHBhcmFtcykge1xuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuY2FuY2VsKGFjdG9yU2NvcGUuc2VsZiwgcGFyYW1zLnNlbmRJZCk7XG4gIH0pO1xufVxuLyoqXG4gKiBDYW5jZWxzIGEgZGVsYXllZCBgc2VuZFRvKC4uLilgIGFjdGlvbiB0aGF0IGlzIHdhaXRpbmcgdG8gYmUgZXhlY3V0ZWQuIFRoZVxuICogY2FuY2VsZWQgYHNlbmRUbyguLi4pYCBhY3Rpb24gd2lsbCBub3Qgc2VuZCBpdHMgZXZlbnQgb3IgZXhlY3V0ZSwgdW5sZXNzIHRoZVxuICogYGRlbGF5YCBoYXMgYWxyZWFkeSBlbGFwc2VkIGJlZm9yZSBgY2FuY2VsKC4uLilgIGlzIGNhbGxlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBzZW5kVG8sIGNhbmNlbCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzZW5kRXZlbnQ6IHtcbiAqICAgICAgIGFjdGlvbnM6IHNlbmRUbyhcbiAqICAgICAgICAgJ3NvbWUtYWN0b3InLFxuICogICAgICAgICB7IHR5cGU6ICdzb21lRXZlbnQnIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBpZDogJ3NvbWUtaWQnLFxuICogICAgICAgICAgIGRlbGF5OiAxMDAwXG4gKiAgICAgICAgIH1cbiAqICAgICAgIClcbiAqICAgICB9LFxuICogICAgIGNhbmNlbEV2ZW50OiB7XG4gKiAgICAgICBhY3Rpb25zOiBjYW5jZWwoJ3NvbWUtaWQnKVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VuZElkIFRoZSBgaWRgIG9mIHRoZSBgc2VuZFRvKC4uLilgIGFjdGlvbiB0byBjYW5jZWwuXG4gKi9cbmZ1bmN0aW9uIGNhbmNlbChzZW5kSWQpIHtcbiAgZnVuY3Rpb24gY2FuY2VsKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBjYW5jZWwudHlwZSA9ICd4c3RhdGUuY2FuY2VsJztcbiAgY2FuY2VsLnNlbmRJZCA9IHNlbmRJZDtcbiAgY2FuY2VsLnJlc29sdmUgPSByZXNvbHZlQ2FuY2VsO1xuICBjYW5jZWwuZXhlY3V0ZSA9IGV4ZWN1dGVDYW5jZWw7XG4gIHJldHVybiBjYW5jZWw7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTcGF3bihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgX2FjdGlvblBhcmFtcywge1xuICBpZCxcbiAgc3lzdGVtSWQsXG4gIHNyYyxcbiAgaW5wdXQsXG4gIHN5bmNTbmFwc2hvdFxufSkge1xuICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3RvcihzbmFwc2hvdC5tYWNoaW5lLCBzcmMpIDogc3JjO1xuICBjb25zdCByZXNvbHZlZElkID0gdHlwZW9mIGlkID09PSAnZnVuY3Rpb24nID8gaWQoYWN0aW9uQXJncykgOiBpZDtcbiAgbGV0IGFjdG9yUmVmO1xuICBsZXQgcmVzb2x2ZWRJbnB1dCA9IHVuZGVmaW5lZDtcbiAgaWYgKGxvZ2ljKSB7XG4gICAgcmVzb2x2ZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/IGlucHV0KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudDogYWN0aW9uQXJncy5ldmVudCxcbiAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgIH0pIDogaW5wdXQ7XG4gICAgYWN0b3JSZWYgPSBjcmVhdGVBY3Rvcihsb2dpYywge1xuICAgICAgaWQ6IHJlc29sdmVkSWQsXG4gICAgICBzcmMsXG4gICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5bmNTbmFwc2hvdCxcbiAgICAgIHN5c3RlbUlkLFxuICAgICAgaW5wdXQ6IHJlc29sdmVkSW5wdXRcbiAgICB9KTtcbiAgfVxuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgYEFjdG9yIHR5cGUgJyR7c3JjfScgbm90IGZvdW5kIGluIG1hY2hpbmUgJyR7YWN0b3JTY29wZS5pZH0nLmApO1xuICB9XG4gIHJldHVybiBbY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICBjaGlsZHJlbjoge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICBbcmVzb2x2ZWRJZF06IGFjdG9yUmVmXG4gICAgfVxuICB9KSwge1xuICAgIGlkLFxuICAgIHN5c3RlbUlkLFxuICAgIGFjdG9yUmVmLFxuICAgIHNyYyxcbiAgICBpbnB1dDogcmVzb2x2ZWRJbnB1dFxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVNwYXduKGFjdG9yU2NvcGUsIHtcbiAgYWN0b3JSZWZcbn0pIHtcbiAgaWYgKCFhY3RvclJlZikge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RvclJlZi5zdGFydCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNwYXduQ2hpbGQoLi4uW3NyYywge1xuICBpZCxcbiAgc3lzdGVtSWQsXG4gIGlucHV0LFxuICBzeW5jU25hcHNob3QgPSBmYWxzZVxufSA9IHt9XSkge1xuICBmdW5jdGlvbiBzcGF3bkNoaWxkKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzcGF3bkNoaWxkLnR5cGUgPSAneHN0YXRlLnNwYXduQ2hpbGQnO1xuICBzcGF3bkNoaWxkLmlkID0gaWQ7XG4gIHNwYXduQ2hpbGQuc3lzdGVtSWQgPSBzeXN0ZW1JZDtcbiAgc3Bhd25DaGlsZC5zcmMgPSBzcmM7XG4gIHNwYXduQ2hpbGQuaW5wdXQgPSBpbnB1dDtcbiAgc3Bhd25DaGlsZC5zeW5jU25hcHNob3QgPSBzeW5jU25hcHNob3Q7XG4gIHNwYXduQ2hpbGQucmVzb2x2ZSA9IHJlc29sdmVTcGF3bjtcbiAgc3Bhd25DaGlsZC5leGVjdXRlID0gZXhlY3V0ZVNwYXduO1xuICByZXR1cm4gc3Bhd25DaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVN0b3AoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBhY3RvclJlZlxufSkge1xuICBjb25zdCBhY3RvclJlZk9yU3RyaW5nID0gdHlwZW9mIGFjdG9yUmVmID09PSAnZnVuY3Rpb24nID8gYWN0b3JSZWYoYXJncywgYWN0aW9uUGFyYW1zKSA6IGFjdG9yUmVmO1xuICBjb25zdCByZXNvbHZlZEFjdG9yUmVmID0gdHlwZW9mIGFjdG9yUmVmT3JTdHJpbmcgPT09ICdzdHJpbmcnID8gc25hcHNob3QuY2hpbGRyZW5bYWN0b3JSZWZPclN0cmluZ10gOiBhY3RvclJlZk9yU3RyaW5nO1xuICBsZXQgY2hpbGRyZW4gPSBzbmFwc2hvdC5jaGlsZHJlbjtcbiAgaWYgKHJlc29sdmVkQWN0b3JSZWYpIHtcbiAgICBjaGlsZHJlbiA9IHtcbiAgICAgIC4uLmNoaWxkcmVuXG4gICAgfTtcbiAgICBkZWxldGUgY2hpbGRyZW5bcmVzb2x2ZWRBY3RvclJlZi5pZF07XG4gIH1cbiAgcmV0dXJuIFtjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgIGNoaWxkcmVuXG4gIH0pLCByZXNvbHZlZEFjdG9yUmVmLCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlclJlY3Vyc2l2ZWx5KGFjdG9yU2NvcGUsIGFjdG9yUmVmKSB7XG4gIC8vIHVucmVnaXN0ZXIgY2hpbGRyZW4gZmlyc3QgKGRlcHRoLWZpcnN0KVxuICBjb25zdCBzbmFwc2hvdCA9IGFjdG9yUmVmLmdldFNuYXBzaG90KCk7XG4gIGlmIChzbmFwc2hvdCAmJiAnY2hpbGRyZW4nIGluIHNuYXBzaG90KSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBPYmplY3QudmFsdWVzKHNuYXBzaG90LmNoaWxkcmVuKSkge1xuICAgICAgdW5yZWdpc3RlclJlY3Vyc2l2ZWx5KGFjdG9yU2NvcGUsIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgYWN0b3JTY29wZS5zeXN0ZW0uX3VucmVnaXN0ZXIoYWN0b3JSZWYpO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVN0b3AoYWN0b3JTY29wZSwgYWN0b3JSZWYpIHtcbiAgaWYgKCFhY3RvclJlZikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgdG8gZWFnZXJseSB1bnJlZ2lzdGVyIGl0IGhlcmUgc28gYSBuZXcgYWN0b3Igd2l0aCB0aGUgc2FtZSBzeXN0ZW1JZCBjYW4gYmUgcmVnaXN0ZXJlZCBpbW1lZGlhdGVseVxuICAvLyBzaW5jZSB3ZSBkZWZlciBhY3R1YWwgc3RvcHBpbmcgb2YgdGhlIGFjdG9yIGJ1dCB3ZSBkb24ndCBkZWZlciBhY3RvciBjcmVhdGlvbnMgKGFuZCB3ZSBjYW4ndCBkbyB0aGF0KVxuICAvLyB0aGlzIGNvdWxkIHRocm93IG9uIGBzeXN0ZW1JZGAgY29sbGlzaW9uLCBmb3IgZXhhbXBsZSwgd2hlbiBkZWFsaW5nIHdpdGggcmVlbnRlcmluZyB0cmFuc2l0aW9uc1xuICAvLyB3ZSBhbHNvIG5lZWQgdG8gcmVjdXJzaXZlbHkgdW5yZWdpc3RlciBhbGwgbmVzdGVkIGNoaWxkcmVuJ3Mgc3lzdGVtSWRzXG4gIHVucmVnaXN0ZXJSZWN1cnNpdmVseShhY3RvclNjb3BlLCBhY3RvclJlZik7XG5cbiAgLy8gdGhpcyBhbGxvd3MgdXMgdG8gcHJldmVudCBhbiBhY3RvciBmcm9tIGJlaW5nIHN0YXJ0ZWQgaWYgaXQgZ2V0cyBzdG9wcGVkIHdpdGhpbiB0aGUgc2FtZSBtYWNyb3N0ZXBcbiAgLy8gdGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgd2hlbiB0aGUgaW52b2tpbmcgc3RhdGUgaXMgYmVpbmcgZXhpdGVkIGltbWVkaWF0ZWx5IGJ5IGFuIGFsd2F5cyB0cmFuc2l0aW9uXG4gIGlmIChhY3RvclJlZi5fcHJvY2Vzc2luZ1N0YXR1cyAhPT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgYWN0b3JTY29wZS5zdG9wQ2hpbGQoYWN0b3JSZWYpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzdG9wcGluZyBhIGNoaWxkIGVucXVldWVzIGEgc3RvcCBldmVudCBpbiB0aGUgY2hpbGQgYWN0b3IncyBtYWlsYm94XG4gIC8vIHdlIG5lZWQgZm9yIGFsbCBvZiB0aGUgYWxyZWFkeSBlbnF1ZXVlZCBldmVudHMgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB3ZSBzdG9wIHRoZSBjaGlsZFxuICAvLyB0aGUgcGFyZW50IGl0c2VsZiBtaWdodCB3YW50IHRvIHNlbmQgc29tZSBldmVudHMgdG8gYSBjaGlsZCAoZm9yIGV4YW1wbGUgZnJvbSBleGl0IGFjdGlvbnMgb24gdGhlIGludm9raW5nIHN0YXRlKVxuICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpZ25vcmUgdGhvc2UgZXZlbnRzXG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGFjdG9yU2NvcGUuc3RvcENoaWxkKGFjdG9yUmVmKTtcbiAgfSk7XG59XG4vKipcbiAqIFN0b3BzIGEgY2hpbGQgYWN0b3IuXG4gKlxuICogQHBhcmFtIGFjdG9yUmVmIFRoZSBhY3RvciB0byBzdG9wLlxuICovXG5mdW5jdGlvbiBzdG9wQ2hpbGQoYWN0b3JSZWYpIHtcbiAgZnVuY3Rpb24gc3RvcChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc3RvcC50eXBlID0gJ3hzdGF0ZS5zdG9wQ2hpbGQnO1xuICBzdG9wLmFjdG9yUmVmID0gYWN0b3JSZWY7XG4gIHN0b3AucmVzb2x2ZSA9IHJlc29sdmVTdG9wO1xuICBzdG9wLmV4ZWN1dGUgPSBleGVjdXRlU3RvcDtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbi8qKlxuICogU3RvcHMgYSBjaGlsZCBhY3Rvci5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHN0b3BDaGlsZCguLi4pYCBpbnN0ZWFkXG4gKiBAYWxpYXNcbiAqL1xuY29uc3Qgc3RvcCA9IHN0b3BDaGlsZDtcblxuZnVuY3Rpb24gY2hlY2tTdGF0ZUluKHNuYXBzaG90LCBfLCB7XG4gIHN0YXRlVmFsdWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJyAmJiBpc1N0YXRlSWQoc3RhdGVWYWx1ZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBzbmFwc2hvdC5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVWYWx1ZSk7XG4gICAgcmV0dXJuIHNuYXBzaG90Ll9ub2Rlcy5zb21lKHNuID0+IHNuID09PSB0YXJnZXQpO1xuICB9XG4gIHJldHVybiBzbmFwc2hvdC5tYXRjaGVzKHN0YXRlVmFsdWUpO1xufVxuZnVuY3Rpb24gc3RhdGVJbihzdGF0ZVZhbHVlKSB7XG4gIGZ1bmN0aW9uIHN0YXRlSW4oKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzdGF0ZUluLmNoZWNrID0gY2hlY2tTdGF0ZUluO1xuICBzdGF0ZUluLnN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlO1xuICByZXR1cm4gc3RhdGVJbjtcbn1cbmZ1bmN0aW9uIGNoZWNrTm90KHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gIWV2YWx1YXRlR3VhcmQoZ3VhcmRzWzBdLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgdGhlIGBndWFyZGAgcGFzc2VkIHRvIGl0XG4gKiBldmFsdWF0ZXMgdG8gYGZhbHNlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgbm90IH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gZmFsc2VcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogbm90KCdzb21lTmFtZWRHdWFyZCcpLFxuICogICAgICAgYWN0aW9uczogKCkgPT4ge1xuICogICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGlmIGd1YXJkIGluIGBub3QoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGVzIHRvIGBmYWxzZWBcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZFxuICovXG5mdW5jdGlvbiBub3QoZ3VhcmQpIHtcbiAgZnVuY3Rpb24gbm90KF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBub3QuY2hlY2sgPSBjaGVja05vdDtcbiAgbm90Lmd1YXJkcyA9IFtndWFyZF07XG4gIHJldHVybiBub3Q7XG59XG5mdW5jdGlvbiBjaGVja0FuZChzbmFwc2hvdCwge1xuICBjb250ZXh0LFxuICBldmVudFxufSwge1xuICBndWFyZHNcbn0pIHtcbiAgcmV0dXJuIGd1YXJkcy5ldmVyeShndWFyZCA9PiBldmFsdWF0ZUd1YXJkKGd1YXJkLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpKTtcbn1cblxuLyoqXG4gKiBIaWdoZXItb3JkZXIgZ3VhcmQgdGhhdCBldmFsdWF0ZXMgdG8gYHRydWVgIGlmIGFsbCBgZ3VhcmRzYCBwYXNzZWQgdG8gaXRcbiAqIGV2YWx1YXRlIHRvIGB0cnVlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgYW5kIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gdHJ1ZVxuICogICB9XG4gKiB9KS5jcmVhdGVNYWNoaW5lKHtcbiAqICAgb246IHtcbiAqICAgICBzb21lRXZlbnQ6IHtcbiAqICAgICAgIGd1YXJkOiBhbmQoWyh7IGNvbnRleHQgfSkgPT4gY29udGV4dC52YWx1ZSA+IDAsICdzb21lTmFtZWRHdWFyZCddKSxcbiAqICAgICAgIGFjdGlvbnM6ICgpID0+IHtcbiAqICAgICAgICAgLy8gd2lsbCBiZSBleGVjdXRlZCBpZiBhbGwgZ3VhcmRzIGluIGBhbmQoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGUgdG8gdHJ1ZVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkIGFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYW5kKGd1YXJkcykge1xuICBmdW5jdGlvbiBhbmQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFuZC5jaGVjayA9IGNoZWNrQW5kO1xuICBhbmQuZ3VhcmRzID0gZ3VhcmRzO1xuICByZXR1cm4gYW5kO1xufVxuZnVuY3Rpb24gY2hlY2tPcihzbmFwc2hvdCwge1xuICBjb250ZXh0LFxuICBldmVudFxufSwge1xuICBndWFyZHNcbn0pIHtcbiAgcmV0dXJuIGd1YXJkcy5zb21lKGd1YXJkID0+IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCkpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgYW55IG9mIHRoZSBgZ3VhcmRzYCBwYXNzZWQgdG9cbiAqIGl0IGV2YWx1YXRlIHRvIGB0cnVlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgb3IgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBzZXR1cCh7XG4gKiAgIGd1YXJkczoge1xuICogICAgIHNvbWVOYW1lZEd1YXJkOiAoKSA9PiB0cnVlXG4gKiAgIH1cbiAqIH0pLmNyZWF0ZU1hY2hpbmUoe1xuICogICBvbjoge1xuICogICAgIHNvbWVFdmVudDoge1xuICogICAgICAgZ3VhcmQ6IG9yKFsoeyBjb250ZXh0IH0pID0+IGNvbnRleHQudmFsdWUgPiAwLCAnc29tZU5hbWVkR3VhcmQnXSksXG4gKiAgICAgICBhY3Rpb25zOiAoKSA9PiB7XG4gKiAgICAgICAgIC8vIHdpbGwgYmUgZXhlY3V0ZWQgaWYgYW55IG9mIHRoZSBndWFyZHMgaW4gYG9yKC4uLilgXG4gKiAgICAgICAgIC8vIGV2YWx1YXRlIHRvIHRydWVcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZCBhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG9yKGd1YXJkcykge1xuICBmdW5jdGlvbiBvcihfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgb3IuY2hlY2sgPSBjaGVja09yO1xuICBvci5ndWFyZHMgPSBndWFyZHM7XG4gIHJldHVybiBvcjtcbn1cblxuLy8gVE9ETzogdGhyb3cgb24gY3ljbGVzIChkZXB0aCBjaGVjayBzaG91bGQgYmUgZW5vdWdoKVxuZnVuY3Rpb24gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSB7XG4gIGNvbnN0IHtcbiAgICBtYWNoaW5lXG4gIH0gPSBzbmFwc2hvdDtcbiAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgZ3VhcmQgPT09ICdmdW5jdGlvbic7XG4gIGNvbnN0IHJlc29sdmVkID0gaXNJbmxpbmUgPyBndWFyZCA6IG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmd1YXJkc1t0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gZ3VhcmQgOiBndWFyZC50eXBlXTtcbiAgaWYgKCFpc0lubGluZSAmJiAhcmVzb2x2ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEd1YXJkICcke3R5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IGd1YXJkLnR5cGV9JyBpcyBub3QgaW1wbGVtZW50ZWQuJy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGV2YWx1YXRlR3VhcmQocmVzb2x2ZWQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG4gIH1cbiAgY29uc3QgZ3VhcmRBcmdzID0ge1xuICAgIGNvbnRleHQsXG4gICAgZXZlbnRcbiAgfTtcbiAgY29uc3QgZ3VhcmRQYXJhbXMgPSBpc0lubGluZSB8fCB0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gZ3VhcmQgPyB0eXBlb2YgZ3VhcmQucGFyYW1zID09PSAnZnVuY3Rpb24nID8gZ3VhcmQucGFyYW1zKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pIDogZ3VhcmQucGFyYW1zIDogdW5kZWZpbmVkO1xuICBpZiAoISgnY2hlY2snIGluIHJlc29sdmVkKSkge1xuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuZ3VhcmRzYCBhc3N1bWVzIG5vbi1udWxsYWJsZSBgVEV4cHJlc3Npb25HdWFyZGBcbiAgICAvLyBpbmxpbmUgZ3VhcmRzIGV4cGVjdCBgVEV4cHJlc3Npb25HdWFyZGAgdG8gYmUgc2V0IHRvIGB1bmRlZmluZWRgXG4gICAgLy8gaXQncyBmaW5lIHRvIGNhc3QgdGhpcyBoZXJlLCBvdXIgbG9naWMgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG4gICAgcmV0dXJuIHJlc29sdmVkKGd1YXJkQXJncywgZ3VhcmRQYXJhbXMpO1xuICB9XG4gIGNvbnN0IGJ1aWx0aW5HdWFyZCA9IHJlc29sdmVkO1xuICByZXR1cm4gYnVpbHRpbkd1YXJkLmNoZWNrKHNuYXBzaG90LCBndWFyZEFyZ3MsIHJlc29sdmVkIC8vIHRoaXMgaG9sZHMgYWxsIHBhcmFtc1xuICApO1xufVxuXG5jb25zdCBpc0F0b21pY1N0YXRlTm9kZSA9IHN0YXRlTm9kZSA9PiBzdGF0ZU5vZGUudHlwZSA9PT0gJ2F0b21pYycgfHwgc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGVOb2RlLnN0YXRlcykuZmlsdGVyKHNuID0+IHNuLnR5cGUgIT09ICdoaXN0b3J5Jyk7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSkge1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgaWYgKHRvU3RhdGVOb2RlID09PSBzdGF0ZU5vZGUpIHtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG5cbiAgLy8gYWRkIGFsbCBhbmNlc3RvcnNcbiAgbGV0IG0gPSBzdGF0ZU5vZGUucGFyZW50O1xuICB3aGlsZSAobSAmJiBtICE9PSB0b1N0YXRlTm9kZSkge1xuICAgIGFuY2VzdG9ycy5wdXNoKG0pO1xuICAgIG0gPSBtLnBhcmVudDtcbiAgfVxuICByZXR1cm4gYW5jZXN0b3JzO1xufVxuZnVuY3Rpb24gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IG5vZGVTZXQgPSBuZXcgU2V0KHN0YXRlTm9kZXMpO1xuICBjb25zdCBhZGpMaXN0ID0gZ2V0QWRqTGlzdChub2RlU2V0KTtcblxuICAvLyBhZGQgZGVzY2VuZGFudHNcbiAgZm9yIChjb25zdCBzIG9mIG5vZGVTZXQpIHtcbiAgICAvLyBpZiBwcmV2aW91c2x5IGFjdGl2ZSwgYWRkIGV4aXN0aW5nIGNoaWxkIG5vZGVzXG4gICAgaWYgKHMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAoIWFkakxpc3QuZ2V0KHMpIHx8ICFhZGpMaXN0LmdldChzKS5sZW5ndGgpKSB7XG4gICAgICBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhzKS5mb3JFYWNoKHNuID0+IG5vZGVTZXQuYWRkKHNuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihzKSkge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5vZGVTZXQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlcyA9IGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKGNoaWxkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5pdGlhbFN0YXRlTm9kZSBvZiBpbml0aWFsU3RhdGVzKSB7XG4gICAgICAgICAgICAgIG5vZGVTZXQuYWRkKGluaXRpYWxTdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gIGZvciAoY29uc3QgcyBvZiBub2RlU2V0KSB7XG4gICAgbGV0IG0gPSBzLnBhcmVudDtcbiAgICB3aGlsZSAobSkge1xuICAgICAgbm9kZVNldC5hZGQobSk7XG4gICAgICBtID0gbS5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlU2V0O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tQWRqKGJhc2VOb2RlLCBhZGpMaXN0KSB7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGFkakxpc3QuZ2V0KGJhc2VOb2RlKTtcbiAgaWYgKCFjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICByZXR1cm4ge307IC8vIHRvZG86IGZpeD9cbiAgfVxuICBpZiAoYmFzZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gY2hpbGRTdGF0ZU5vZGVzWzBdO1xuICAgIGlmIChjaGlsZFN0YXRlTm9kZSkge1xuICAgICAgaWYgKGlzQXRvbWljU3RhdGVOb2RlKGNoaWxkU3RhdGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRTdGF0ZU5vZGUua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRlVmFsdWUgPSB7fTtcbiAgZm9yIChjb25zdCBjaGlsZFN0YXRlTm9kZSBvZiBjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICBzdGF0ZVZhbHVlW2NoaWxkU3RhdGVOb2RlLmtleV0gPSBnZXRWYWx1ZUZyb21BZGooY2hpbGRTdGF0ZU5vZGUsIGFkakxpc3QpO1xuICB9XG4gIHJldHVybiBzdGF0ZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QWRqTGlzdChzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGFkakxpc3QgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZU5vZGVzKSB7XG4gICAgaWYgKCFhZGpMaXN0LmhhcyhzKSkge1xuICAgICAgYWRqTGlzdC5zZXQocywgW10pO1xuICAgIH1cbiAgICBpZiAocy5wYXJlbnQpIHtcbiAgICAgIGlmICghYWRqTGlzdC5oYXMocy5wYXJlbnQpKSB7XG4gICAgICAgIGFkakxpc3Quc2V0KHMucGFyZW50LCBbXSk7XG4gICAgICB9XG4gICAgICBhZGpMaXN0LmdldChzLnBhcmVudCkucHVzaChzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkakxpc3Q7XG59XG5mdW5jdGlvbiBnZXRTdGF0ZVZhbHVlKHJvb3ROb2RlLCBzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldEFsbFN0YXRlTm9kZXMoc3RhdGVOb2Rlcyk7XG4gIHJldHVybiBnZXRWYWx1ZUZyb21BZGoocm9vdE5vZGUsIGdldEFkakxpc3QoY29uZmlnKSk7XG59XG5mdW5jdGlvbiBpc0luRmluYWxTdGF0ZShzdGF0ZU5vZGVTZXQsIHN0YXRlTm9kZSkge1xuICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5zb21lKHMgPT4gcy50eXBlID09PSAnZmluYWwnICYmIHN0YXRlTm9kZVNldC5oYXMocykpO1xuICB9XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLmV2ZXJ5KHNuID0+IGlzSW5GaW5hbFN0YXRlKHN0YXRlTm9kZVNldCwgc24pKTtcbiAgfVxuICByZXR1cm4gc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG59XG5jb25zdCBpc1N0YXRlSWQgPSBzdHIgPT4gc3RyWzBdID09PSBTVEFURV9JREVOVElGSUVSO1xuZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhzdGF0ZU5vZGUsIHJlY2VpdmVkRXZlbnRUeXBlKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBzdGF0ZU5vZGUudHJhbnNpdGlvbnMuZ2V0KHJlY2VpdmVkRXZlbnRUeXBlKSB8fCBbLi4uc3RhdGVOb2RlLnRyYW5zaXRpb25zLmtleXMoKV0uZmlsdGVyKGV2ZW50RGVzY3JpcHRvciA9PiBtYXRjaGVzRXZlbnREZXNjcmlwdG9yKHJlY2VpdmVkRXZlbnRUeXBlLCBldmVudERlc2NyaXB0b3IpKS5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKS5mbGF0TWFwKGtleSA9PiBzdGF0ZU5vZGUudHJhbnNpdGlvbnMuZ2V0KGtleSkpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn1cblxuLyoqIEFsbCBkZWxheWVkIHRyYW5zaXRpb25zIGZyb20gdGhlIGNvbmZpZy4gKi9cbmZ1bmN0aW9uIGdldERlbGF5ZWRUcmFuc2l0aW9ucyhzdGF0ZU5vZGUpIHtcbiAgY29uc3QgYWZ0ZXJDb25maWcgPSBzdGF0ZU5vZGUuY29uZmlnLmFmdGVyO1xuICBpZiAoIWFmdGVyQ29uZmlnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG11dGF0ZUVudHJ5RXhpdCA9IGRlbGF5ID0+IHtcbiAgICBjb25zdCBhZnRlckV2ZW50ID0gY3JlYXRlQWZ0ZXJFdmVudChkZWxheSwgc3RhdGVOb2RlLmlkKTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBhZnRlckV2ZW50LnR5cGU7XG4gICAgc3RhdGVOb2RlLmVudHJ5LnB1c2gocmFpc2UoYWZ0ZXJFdmVudCwge1xuICAgICAgaWQ6IGV2ZW50VHlwZSxcbiAgICAgIGRlbGF5XG4gICAgfSkpO1xuICAgIHN0YXRlTm9kZS5leGl0LnB1c2goY2FuY2VsKGV2ZW50VHlwZSkpO1xuICAgIHJldHVybiBldmVudFR5cGU7XG4gIH07XG4gIGNvbnN0IGRlbGF5ZWRUcmFuc2l0aW9ucyA9IE9iamVjdC5rZXlzKGFmdGVyQ29uZmlnKS5mbGF0TWFwKGRlbGF5ID0+IHtcbiAgICBjb25zdCBjb25maWdUcmFuc2l0aW9uID0gYWZ0ZXJDb25maWdbZGVsYXldO1xuICAgIGNvbnN0IHJlc29sdmVkVHJhbnNpdGlvbiA9IHR5cGVvZiBjb25maWdUcmFuc2l0aW9uID09PSAnc3RyaW5nJyA/IHtcbiAgICAgIHRhcmdldDogY29uZmlnVHJhbnNpdGlvblxuICAgIH0gOiBjb25maWdUcmFuc2l0aW9uO1xuICAgIGNvbnN0IHJlc29sdmVkRGVsYXkgPSBOdW1iZXIuaXNOYU4oK2RlbGF5KSA/IGRlbGF5IDogK2RlbGF5O1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IG11dGF0ZUVudHJ5RXhpdChyZXNvbHZlZERlbGF5KTtcbiAgICByZXR1cm4gdG9BcnJheShyZXNvbHZlZFRyYW5zaXRpb24pLm1hcCh0cmFuc2l0aW9uID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgZXZlbnQ6IGV2ZW50VHlwZSxcbiAgICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIGRlbGF5ZWRUcmFuc2l0aW9ucy5tYXAoZGVsYXllZFRyYW5zaXRpb24gPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5XG4gICAgfSA9IGRlbGF5ZWRUcmFuc2l0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVsYXllZFRyYW5zaXRpb24uZXZlbnQsIGRlbGF5ZWRUcmFuc2l0aW9uKSxcbiAgICAgIGRlbGF5XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdHJhbnNpdGlvbkNvbmZpZykge1xuICBjb25zdCBub3JtYWxpemVkVGFyZ2V0ID0gbm9ybWFsaXplVGFyZ2V0KHRyYW5zaXRpb25Db25maWcudGFyZ2V0KTtcbiAgY29uc3QgcmVlbnRlciA9IHRyYW5zaXRpb25Db25maWcucmVlbnRlciA/PyBmYWxzZTtcbiAgY29uc3QgdGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChzdGF0ZU5vZGUsIG5vcm1hbGl6ZWRUYXJnZXQpO1xuXG4gIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIHBhcnQgb2YgYSBsaW50IHJ1bGUgaW5zdGVhZD9cbiAgaWYgKHRyYW5zaXRpb25Db25maWcuY29uZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGUgXCIke3N0YXRlTm9kZS5pZH1cIiBoYXMgZGVjbGFyZWQgXFxgY29uZFxcYCBmb3Igb25lIG9mIGl0cyB0cmFuc2l0aW9ucy4gVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYGd1YXJkXFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZS5gKTtcbiAgfVxuICBjb25zdCB0cmFuc2l0aW9uID0ge1xuICAgIC4uLnRyYW5zaXRpb25Db25maWcsXG4gICAgYWN0aW9uczogdG9BcnJheSh0cmFuc2l0aW9uQ29uZmlnLmFjdGlvbnMpLFxuICAgIGd1YXJkOiB0cmFuc2l0aW9uQ29uZmlnLmd1YXJkLFxuICAgIHRhcmdldCxcbiAgICBzb3VyY2U6IHN0YXRlTm9kZSxcbiAgICByZWVudGVyLFxuICAgIGV2ZW50VHlwZTogZGVzY3JpcHRvcixcbiAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgc291cmNlOiBgIyR7c3RhdGVOb2RlLmlkfWAsXG4gICAgICB0YXJnZXQ6IHRhcmdldCA/IHRhcmdldC5tYXAodCA9PiBgIyR7dC5pZH1gKSA6IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhbnNpdGlvbnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICBpZiAoc3RhdGVOb2RlLmNvbmZpZy5vbikge1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBPYmplY3Qua2V5cyhzdGF0ZU5vZGUuY29uZmlnLm9uKSkge1xuICAgICAgaWYgKGRlc2NyaXB0b3IgPT09IE5VTExfRVZFTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGV2ZW50cyAoXCJcIikgY2Fubm90IGJlIHNwZWNpZmllZCBhcyBhIHRyYW5zaXRpb24ga2V5LiBVc2UgYGFsd2F5czogeyAuLi4gfWAgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zaXRpb25zQ29uZmlnID0gc3RhdGVOb2RlLmNvbmZpZy5vbltkZXNjcmlwdG9yXTtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheSh0cmFuc2l0aW9uc0NvbmZpZykubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHQpKSk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZU5vZGUuY29uZmlnLm9uRG9uZSkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmRvbmUuc3RhdGUuJHtzdGF0ZU5vZGUuaWR9YDtcbiAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoc3RhdGVOb2RlLmNvbmZpZy5vbkRvbmUpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICB9XG4gIGZvciAoY29uc3QgaW52b2tlRGVmIG9mIHN0YXRlTm9kZS5pbnZva2UpIHtcbiAgICBpZiAoaW52b2tlRGVmLm9uRG9uZSkge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGB4c3RhdGUuZG9uZS5hY3Rvci4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vbkRvbmUpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgICBpZiAoaW52b2tlRGVmLm9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmVycm9yLmFjdG9yLiR7aW52b2tlRGVmLmlkfWA7XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoaW52b2tlRGVmLm9uRXJyb3IpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgICBpZiAoaW52b2tlRGVmLm9uU25hcHNob3QpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLnNuYXBzaG90LiR7aW52b2tlRGVmLmlkfWA7XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoaW52b2tlRGVmLm9uU25hcHNob3QpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGRlbGF5ZWRUcmFuc2l0aW9uIG9mIHN0YXRlTm9kZS5hZnRlcikge1xuICAgIGxldCBleGlzdGluZyA9IHRyYW5zaXRpb25zLmdldChkZWxheWVkVHJhbnNpdGlvbi5ldmVudFR5cGUpO1xuICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgIGV4aXN0aW5nID0gW107XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVsYXllZFRyYW5zaXRpb24uZXZlbnRUeXBlLCBleGlzdGluZyk7XG4gICAgfVxuICAgIGV4aXN0aW5nLnB1c2goZGVsYXllZFRyYW5zaXRpb24pO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9ucztcbn1cbmZ1bmN0aW9uIGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uKHN0YXRlTm9kZSwgX3RhcmdldCkge1xuICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiBfdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHN0YXRlTm9kZS5zdGF0ZXNbX3RhcmdldF0gOiBfdGFyZ2V0ID8gc3RhdGVOb2RlLnN0YXRlc1tfdGFyZ2V0LnRhcmdldF0gOiB1bmRlZmluZWQ7XG4gIGlmICghcmVzb2x2ZWRUYXJnZXQgJiYgX3RhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICBgSW5pdGlhbCBzdGF0ZSBub2RlIFwiJHtfdGFyZ2V0fVwiIG5vdCBmb3VuZCBvbiBwYXJlbnQgc3RhdGUgbm9kZSAjJHtzdGF0ZU5vZGUuaWR9YCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbiA9IHtcbiAgICBzb3VyY2U6IHN0YXRlTm9kZSxcbiAgICBhY3Rpb25zOiAhX3RhcmdldCB8fCB0eXBlb2YgX3RhcmdldCA9PT0gJ3N0cmluZycgPyBbXSA6IHRvQXJyYXkoX3RhcmdldC5hY3Rpb25zKSxcbiAgICBldmVudFR5cGU6IG51bGwsXG4gICAgcmVlbnRlcjogZmFsc2UsXG4gICAgdGFyZ2V0OiByZXNvbHZlZFRhcmdldCA/IFtyZXNvbHZlZFRhcmdldF0gOiBbXSxcbiAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgc291cmNlOiBgIyR7c3RhdGVOb2RlLmlkfWAsXG4gICAgICB0YXJnZXQ6IHJlc29sdmVkVGFyZ2V0ID8gW2AjJHtyZXNvbHZlZFRhcmdldC5pZH1gXSA6IFtdXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIHRyYW5zaXRpb247XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0KHN0YXRlTm9kZSwgdGFyZ2V0cykge1xuICBpZiAodGFyZ2V0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gYW4gdW5kZWZpbmVkIHRhcmdldCBzaWduYWxzIHRoYXQgdGhlIHN0YXRlIG5vZGUgc2hvdWxkIG5vdCB0cmFuc2l0aW9uIGZyb20gdGhhdCBzdGF0ZSB3aGVuIHJlY2VpdmluZyB0aGF0IGV2ZW50XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChpc1N0YXRlSWQodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZS5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQodGFyZ2V0KTtcbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcm5hbFRhcmdldCA9IHRhcmdldFswXSA9PT0gU1RBVEVfREVMSU1JVEVSO1xuICAgIC8vIElmIGludGVybmFsIHRhcmdldCBpcyBkZWZpbmVkIG9uIG1hY2hpbmUsXG4gICAgLy8gZG8gbm90IGluY2x1ZGUgbWFjaGluZSBrZXkgb24gdGFyZ2V0XG4gICAgaWYgKGlzSW50ZXJuYWxUYXJnZXQgJiYgIXN0YXRlTm9kZS5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCB0YXJnZXQuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZFRhcmdldCA9IGlzSW50ZXJuYWxUYXJnZXQgPyBzdGF0ZU5vZGUua2V5ICsgdGFyZ2V0IDogdGFyZ2V0O1xuICAgIGlmIChzdGF0ZU5vZGUucGFyZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLnBhcmVudCwgcmVzb2x2ZWRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGVOb2RlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmFuc2l0aW9uIGRlZmluaXRpb24gZm9yIHN0YXRlIG5vZGUgJyR7c3RhdGVOb2RlLmlkfSc6XFxuJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldDogXCIke3RhcmdldH1cIiBpcyBub3QgYSB2YWxpZCB0YXJnZXQgZnJvbSB0aGUgcm9vdCBub2RlLiBEaWQgeW91IG1lYW4gXCIuJHt0YXJnZXR9XCI/YCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24oc3RhdGVOb2RlKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRUYXJnZXQgPSBub3JtYWxpemVUYXJnZXQoc3RhdGVOb2RlLmNvbmZpZy50YXJnZXQpO1xuICBpZiAoIW5vcm1hbGl6ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gc3RhdGVOb2RlLnBhcmVudC5pbml0aWFsO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiBub3JtYWxpemVkVGFyZ2V0Lm1hcCh0ID0+IHR5cGVvZiB0ID09PSAnc3RyaW5nJyA/IGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUucGFyZW50LCB0KSA6IHQpXG4gIH07XG59XG5mdW5jdGlvbiBpc0hpc3RvcnlOb2RlKHN0YXRlTm9kZSkge1xuICByZXR1cm4gc3RhdGVOb2RlLnR5cGUgPT09ICdoaXN0b3J5Jztcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKHN0YXRlTm9kZSkge1xuICBjb25zdCBzdGF0ZXMgPSBnZXRJbml0aWFsU3RhdGVOb2RlcyhzdGF0ZU5vZGUpO1xuICBmb3IgKGNvbnN0IGluaXRpYWxTdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGdldFByb3BlckFuY2VzdG9ycyhpbml0aWFsU3RhdGUsIHN0YXRlTm9kZSkpIHtcbiAgICAgIHN0YXRlcy5hZGQoYW5jZXN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGVzO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlTm9kZXMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gaXRlcihkZXNjU3RhdGVOb2RlKSB7XG4gICAgaWYgKHNldC5oYXMoZGVzY1N0YXRlTm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0LmFkZChkZXNjU3RhdGVOb2RlKTtcbiAgICBpZiAoZGVzY1N0YXRlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBpdGVyKGRlc2NTdGF0ZU5vZGUuaW5pdGlhbC50YXJnZXRbMF0pO1xuICAgIH0gZWxzZSBpZiAoZGVzY1N0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKGRlc2NTdGF0ZU5vZGUpKSB7XG4gICAgICAgIGl0ZXIoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpdGVyKHN0YXRlTm9kZSk7XG4gIHJldHVybiBzZXQ7XG59XG4vKiogUmV0dXJucyB0aGUgY2hpbGQgc3RhdGUgbm9kZSBmcm9tIGl0cyByZWxhdGl2ZSBgc3RhdGVLZXlgLCBvciB0aHJvd3MuICovXG5mdW5jdGlvbiBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdGF0ZUtleSkge1xuICBpZiAoaXNTdGF0ZUlkKHN0YXRlS2V5KSkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlS2V5KTtcbiAgfVxuICBpZiAoIXN0YXRlTm9kZS5zdGF0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXRyaWV2ZSBjaGlsZCBzdGF0ZSAnJHtzdGF0ZUtleX0nIGZyb20gJyR7c3RhdGVOb2RlLmlkfSc7IG5vIGNoaWxkIHN0YXRlcyBleGlzdC5gKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBzdGF0ZU5vZGUuc3RhdGVzW3N0YXRlS2V5XTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlICcke3N0YXRlS2V5fScgZG9lcyBub3QgZXhpc3Qgb24gJyR7c3RhdGVOb2RlLmlkfSdgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlbGF0aXZlIHN0YXRlIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gYHN0YXRlUGF0aGAsIG9yIHRocm93cy5cbiAqXG4gKiBAcGFyYW0gc3RhdGVQYXRoIFRoZSBzdHJpbmcgb3Igc3RyaW5nIGFycmF5IHJlbGF0aXZlIHBhdGggdG8gdGhlIHN0YXRlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUsIHN0YXRlUGF0aCkge1xuICBpZiAodHlwZW9mIHN0YXRlUGF0aCA9PT0gJ3N0cmluZycgJiYgaXNTdGF0ZUlkKHN0YXRlUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZS5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVQYXRoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIHRyeSBpbmRpdmlkdWFsIHBhdGhzXG4gICAgICAvLyB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBjb25zdCBhcnJheVN0YXRlUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlUGF0aCkuc2xpY2UoKTtcbiAgbGV0IGN1cnJlbnRTdGF0ZU5vZGUgPSBzdGF0ZU5vZGU7XG4gIHdoaWxlIChhcnJheVN0YXRlUGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBrZXkgPSBhcnJheVN0YXRlUGF0aC5zaGlmdCgpO1xuICAgIGlmICgha2V5Lmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoY3VycmVudFN0YXRlTm9kZSwga2V5KTtcbiAgfVxuICByZXR1cm4gY3VycmVudFN0YXRlTm9kZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlcyByZXByZXNlbnRlZCBieSB0aGUgY3VycmVudCBzdGF0ZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgc3RhdGUgdmFsdWUgb3IgU3RhdGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlcyhzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gc3RhdGVOb2RlLnN0YXRlc1tzdGF0ZVZhbHVlXTtcbiAgICBpZiAoIWNoaWxkU3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlICcke3N0YXRlVmFsdWV9JyBkb2VzIG5vdCBleGlzdCBvbiAnJHtzdGF0ZU5vZGUuaWR9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXRlTm9kZSwgY2hpbGRTdGF0ZU5vZGVdO1xuICB9XG4gIGNvbnN0IGNoaWxkU3RhdGVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGNoaWxkU3RhdGVLZXlzLm1hcChzdWJTdGF0ZUtleSA9PiBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSkpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFtzdGF0ZU5vZGUubWFjaGluZS5yb290LCBzdGF0ZU5vZGVdLmNvbmNhdChjaGlsZFN0YXRlTm9kZXMsIGNoaWxkU3RhdGVLZXlzLnJlZHVjZSgoYWxsU3ViU3RhdGVOb2Rlcywgc3ViU3RhdGVLZXkpID0+IHtcbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgaWYgKCFzdWJTdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBhbGxTdWJTdGF0ZU5vZGVzO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGVzID0gZ2V0U3RhdGVOb2RlcyhzdWJTdGF0ZU5vZGUsIHN0YXRlVmFsdWVbc3ViU3RhdGVLZXldKTtcbiAgICByZXR1cm4gYWxsU3ViU3RhdGVOb2Rlcy5jb25jYXQoc3ViU3RhdGVOb2Rlcyk7XG4gIH0sIFtdKSk7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpO1xuICBjb25zdCBuZXh0ID0gY2hpbGRTdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQ29tcG91bmROb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IHN1YlN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN1YlN0YXRlS2V5c1swXSk7XG4gIGNvbnN0IG5leHQgPSB0cmFuc2l0aW9uTm9kZShjaGlsZFN0YXRlTm9kZSwgc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleXNbMF1dLCBzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IGFsbElubmVyVHJhbnNpdGlvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBzdWJTdGF0ZUtleSBvZiBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKSkge1xuICAgIGNvbnN0IHN1YlN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlW3N1YlN0YXRlS2V5XTtcbiAgICBpZiAoIXN1YlN0YXRlVmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgY29uc3QgaW5uZXJUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25Ob2RlKHN1YlN0YXRlTm9kZSwgc3ViU3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbiAgICBpZiAoaW5uZXJUcmFuc2l0aW9ucykge1xuICAgICAgYWxsSW5uZXJUcmFuc2l0aW9ucy5wdXNoKC4uLmlubmVyVHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoIWFsbElubmVyVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIGFsbElubmVyVHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICAvLyBsZWFmIG5vZGVcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBjb21wb3VuZCBub2RlXG4gIGlmIChPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBwYXJhbGxlbCBub2RlXG4gIHJldHVybiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhpc3RvcnlOb2RlcyhzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlTm9kZS5zdGF0ZXMpLm1hcChrZXkgPT4gc3RhdGVOb2RlLnN0YXRlc1trZXldKS5maWx0ZXIoc24gPT4gc24udHlwZSA9PT0gJ2hpc3RvcnknKTtcbn1cbmZ1bmN0aW9uIGlzRGVzY2VuZGFudChjaGlsZFN0YXRlTm9kZSwgcGFyZW50U3RhdGVOb2RlKSB7XG4gIGxldCBtYXJrZXIgPSBjaGlsZFN0YXRlTm9kZTtcbiAgd2hpbGUgKG1hcmtlci5wYXJlbnQgJiYgbWFya2VyLnBhcmVudCAhPT0gcGFyZW50U3RhdGVOb2RlKSB7XG4gICAgbWFya2VyID0gbWFya2VyLnBhcmVudDtcbiAgfVxuICByZXR1cm4gbWFya2VyLnBhcmVudCA9PT0gcGFyZW50U3RhdGVOb2RlO1xufVxuZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uKHMxLCBzMikge1xuICBjb25zdCBzZXQxID0gbmV3IFNldChzMSk7XG4gIGNvbnN0IHNldDIgPSBuZXcgU2V0KHMyKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldDEpIHtcbiAgICBpZiAoc2V0Mi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2V0Mikge1xuICAgIGlmIChzZXQxLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnMoZW5hYmxlZFRyYW5zaXRpb25zLCBzdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSkge1xuICBjb25zdCBmaWx0ZXJlZFRyYW5zaXRpb25zID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQxIG9mIGVuYWJsZWRUcmFuc2l0aW9ucykge1xuICAgIGxldCB0MVByZWVtcHRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyYW5zaXRpb25zVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB0MiBvZiBmaWx0ZXJlZFRyYW5zaXRpb25zKSB7XG4gICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uKGNvbXB1dGVFeGl0U2V0KFt0MV0sIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSwgY29tcHV0ZUV4aXRTZXQoW3QyXSwgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpKSkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHQxLnNvdXJjZSwgdDIuc291cmNlKSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zVG9SZW1vdmUuYWRkKHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0MVByZWVtcHRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0MVByZWVtcHRlZCkge1xuICAgICAgZm9yIChjb25zdCB0MyBvZiB0cmFuc2l0aW9uc1RvUmVtb3ZlKSB7XG4gICAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuZGVsZXRlKHQzKTtcbiAgICAgIH1cbiAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuYWRkKHQxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oZmlsdGVyZWRUcmFuc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBmaW5kTGVhc3RDb21tb25BbmNlc3RvcihzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHN0YXRlTm9kZXM7XG4gIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgZ2V0UHJvcGVyQW5jZXN0b3JzKGhlYWQsIHVuZGVmaW5lZCkpIHtcbiAgICBpZiAodGFpbC5ldmVyeShzbiA9PiBpc0Rlc2NlbmRhbnQoc24sIGFuY2VzdG9yKSkpIHtcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgaWYgKCF0cmFuc2l0aW9uLnRhcmdldCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHRhcmdldE5vZGUgb2YgdHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICBpZiAoaXNIaXN0b3J5Tm9kZSh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGhpc3RvcnlWYWx1ZVt0YXJnZXROb2RlLmlkXSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGlzdG9yeVZhbHVlW3RhcmdldE5vZGUuaWRdKSB7XG4gICAgICAgICAgdGFyZ2V0cy5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXMocmVzb2x2ZUhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbih0YXJnZXROb2RlKSwgaGlzdG9yeVZhbHVlKSkge1xuICAgICAgICAgIHRhcmdldHMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldHMuYWRkKHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnRhcmdldHNdO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkRvbWFpbih0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVzID0gZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzKHRyYW5zaXRpb24sIGhpc3RvcnlWYWx1ZSk7XG4gIGlmICghdGFyZ2V0U3RhdGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdHJhbnNpdGlvbi5yZWVudGVyICYmIHRhcmdldFN0YXRlcy5ldmVyeSh0YXJnZXQgPT4gdGFyZ2V0ID09PSB0cmFuc2l0aW9uLnNvdXJjZSB8fCBpc0Rlc2NlbmRhbnQodGFyZ2V0LCB0cmFuc2l0aW9uLnNvdXJjZSkpKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb24uc291cmNlO1xuICB9XG4gIGNvbnN0IGxjYSA9IGZpbmRMZWFzdENvbW1vbkFuY2VzdG9yKHRhcmdldFN0YXRlcy5jb25jYXQodHJhbnNpdGlvbi5zb3VyY2UpKTtcbiAgaWYgKGxjYSkge1xuICAgIHJldHVybiBsY2E7XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCBpdCdzIGEgcm9vdCB0cmFuc2l0aW9uIHNpbmNlIExDQSBjb3VsZG4ndCBiZSBmb3VuZFxuICBpZiAodHJhbnNpdGlvbi5yZWVudGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9uLnNvdXJjZS5tYWNoaW5lLnJvb3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3Qgc3RhdGVzVG9FeGl0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICBpZiAodC50YXJnZXQ/Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZG9tYWluID0gZ2V0VHJhbnNpdGlvbkRvbWFpbih0LCBoaXN0b3J5VmFsdWUpO1xuICAgICAgaWYgKHQucmVlbnRlciAmJiB0LnNvdXJjZSA9PT0gZG9tYWluKSB7XG4gICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc3RhdGVOb2RlIG9mIHN0YXRlTm9kZVNldCkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHN0YXRlTm9kZSwgZG9tYWluKSkge1xuICAgICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoc3RhdGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnN0YXRlc1RvRXhpdF07XG59XG5mdW5jdGlvbiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKHByZXZTdGF0ZU5vZGVzLCBuZXh0U3RhdGVOb2RlU2V0KSB7XG4gIGlmIChwcmV2U3RhdGVOb2Rlcy5sZW5ndGggIT09IG5leHRTdGF0ZU5vZGVTZXQuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcHJldlN0YXRlTm9kZXMpIHtcbiAgICBpZiAoIW5leHRTdGF0ZU5vZGVTZXQuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNtaWNyb3N0ZXBQcm9jZWR1cmUgKi9cbmZ1bmN0aW9uIG1pY3Jvc3RlcCh0cmFuc2l0aW9ucywgY3VycmVudFNuYXBzaG90LCBhY3RvclNjb3BlLCBldmVudCwgaXNJbml0aWFsLCBpbnRlcm5hbFF1ZXVlKSB7XG4gIGlmICghdHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbmFwc2hvdDtcbiAgfVxuICBjb25zdCBtdXRTdGF0ZU5vZGVTZXQgPSBuZXcgU2V0KGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMpO1xuICBsZXQgaGlzdG9yeVZhbHVlID0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZTtcbiAgY29uc3QgZmlsdGVyZWRUcmFuc2l0aW9ucyA9IHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKTtcbiAgbGV0IG5leHRTdGF0ZSA9IGN1cnJlbnRTbmFwc2hvdDtcblxuICAvLyBFeGl0IHN0YXRlc1xuICBpZiAoIWlzSW5pdGlhbCkge1xuICAgIFtuZXh0U3RhdGUsIGhpc3RvcnlWYWx1ZV0gPSBleGl0U3RhdGVzKG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUsIGZpbHRlcmVkVHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlLCBpbnRlcm5hbFF1ZXVlLCBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgdHJhbnNpdGlvbiBjb250ZW50XG4gIG5leHRTdGF0ZSA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLmZsYXRNYXAodCA9PiB0LmFjdGlvbnMpLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuXG4gIC8vIEVudGVyIHN0YXRlc1xuICBuZXh0U3RhdGUgPSBlbnRlclN0YXRlcyhuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGludGVybmFsUXVldWUsIGhpc3RvcnlWYWx1ZSwgaXNJbml0aWFsKTtcbiAgY29uc3QgbmV4dFN0YXRlTm9kZXMgPSBbLi4ubXV0U3RhdGVOb2RlU2V0XTtcbiAgaWYgKG5leHRTdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgIG5leHRTdGF0ZSA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBuZXh0U3RhdGVOb2Rlcy5zb3J0KChhLCBiKSA9PiBiLm9yZGVyIC0gYS5vcmRlcikuZmxhdE1hcChzdGF0ZSA9PiBzdGF0ZS5leGl0KSwgaW50ZXJuYWxRdWV1ZSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhdGNoXG4gIHRyeSB7XG4gICAgaWYgKGhpc3RvcnlWYWx1ZSA9PT0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZSAmJiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMsIG11dFN0YXRlTm9kZVNldCkpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZU1hY2hpbmVTbmFwc2hvdChuZXh0U3RhdGUsIHtcbiAgICAgIF9ub2RlczogbmV4dFN0YXRlTm9kZXMsXG4gICAgICBoaXN0b3J5VmFsdWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgb25jZSBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgaXMgaW1wbGVtZW50ZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0ZWx5YWkvcmZjcy9wdWxsLzRcbiAgICB0aHJvdyBlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRNYWNoaW5lT3V0cHV0KHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgcm9vdE5vZGUsIHJvb3RDb21wbGV0aW9uTm9kZSkge1xuICBpZiAocm9vdE5vZGUub3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZG9uZVN0YXRlRXZlbnQgPSBjcmVhdGVEb25lU3RhdGVFdmVudChyb290Q29tcGxldGlvbk5vZGUuaWQsIHJvb3RDb21wbGV0aW9uTm9kZS5vdXRwdXQgIT09IHVuZGVmaW5lZCAmJiByb290Q29tcGxldGlvbk5vZGUucGFyZW50ID8gcmVzb2x2ZU91dHB1dChyb290Q29tcGxldGlvbk5vZGUub3V0cHV0LCBzbmFwc2hvdC5jb250ZXh0LCBldmVudCwgYWN0b3JTY29wZS5zZWxmKSA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiByZXNvbHZlT3V0cHV0KHJvb3ROb2RlLm91dHB1dCwgc25hcHNob3QuY29udGV4dCwgZG9uZVN0YXRlRXZlbnQsIGFjdG9yU2NvcGUuc2VsZik7XG59XG5mdW5jdGlvbiBlbnRlclN0YXRlcyhjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGludGVybmFsUXVldWUsIGhpc3RvcnlWYWx1ZSwgaXNJbml0aWFsKSB7XG4gIGxldCBuZXh0U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gIGNvbnN0IHN0YXRlc1RvRW50ZXIgPSBuZXcgU2V0KCk7XG4gIC8vIHRob3NlIGFyZSBzdGF0ZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IHRhcmdldGVkIG9yIGluZGlyZWN0bHkgdGFyZ2V0ZWQgYnkgdGhlIGV4cGxpY2l0IHRhcmdldFxuICAvLyBpbiBvdGhlciB3b3JkcywgdGhvc2UgYXJlIHN0YXRlcyBmb3Igd2hpY2ggaW5pdGlhbCBhY3Rpb25zIHNob3VsZCBiZSBleGVjdXRlZFxuICAvLyB3aGVuIHdlIHRhcmdldCBgI2RlZXBfY2hpbGRgIGluaXRpYWwgYWN0aW9ucyBvZiBpdHMgYW5jZXN0b3JzIHNob3VsZG4ndCBiZSBleGVjdXRlZFxuICBjb25zdCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkgPSBuZXcgU2V0KCk7XG4gIGNvbXB1dGVFbnRyeVNldChmaWx0ZXJlZFRyYW5zaXRpb25zLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG5cbiAgLy8gSW4gdGhlIGluaXRpYWwgc3RhdGUsIHRoZSByb290IHN0YXRlIG5vZGUgaXMgXCJlbnRlcmVkXCIuXG4gIGlmIChpc0luaXRpYWwpIHtcbiAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKGN1cnJlbnRTbmFwc2hvdC5tYWNoaW5lLnJvb3QpO1xuICB9XG4gIGNvbnN0IGNvbXBsZXRlZE5vZGVzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHN0YXRlTm9kZVRvRW50ZXIgb2YgWy4uLnN0YXRlc1RvRW50ZXJdLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKSkge1xuICAgIG11dFN0YXRlTm9kZVNldC5hZGQoc3RhdGVOb2RlVG9FbnRlcik7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuXG4gICAgLy8gQWRkIGVudHJ5IGFjdGlvbnNcbiAgICBhY3Rpb25zLnB1c2goLi4uc3RhdGVOb2RlVG9FbnRlci5lbnRyeSk7XG4gICAgZm9yIChjb25zdCBpbnZva2VEZWYgb2Ygc3RhdGVOb2RlVG9FbnRlci5pbnZva2UpIHtcbiAgICAgIGFjdGlvbnMucHVzaChzcGF3bkNoaWxkKGludm9rZURlZi5zcmMsIHtcbiAgICAgICAgLi4uaW52b2tlRGVmLFxuICAgICAgICBzeW5jU25hcHNob3Q6ICEhaW52b2tlRGVmLm9uU25hcHNob3RcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5oYXMoc3RhdGVOb2RlVG9FbnRlcikpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxBY3Rpb25zID0gc3RhdGVOb2RlVG9FbnRlci5pbml0aWFsLmFjdGlvbnM7XG4gICAgICBhY3Rpb25zLnB1c2goLi4uaW5pdGlhbEFjdGlvbnMpO1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgaW50ZXJuYWxRdWV1ZSwgc3RhdGVOb2RlVG9FbnRlci5pbnZva2UubWFwKGludm9rZURlZiA9PiBpbnZva2VEZWYuaWQpKTtcbiAgICBpZiAoc3RhdGVOb2RlVG9FbnRlci50eXBlID09PSAnZmluYWwnKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGF0ZU5vZGVUb0VudGVyLnBhcmVudDtcbiAgICAgIGxldCBhbmNlc3Rvck1hcmtlciA9IHBhcmVudD8udHlwZSA9PT0gJ3BhcmFsbGVsJyA/IHBhcmVudCA6IHBhcmVudD8ucGFyZW50O1xuICAgICAgbGV0IHJvb3RDb21wbGV0aW9uTm9kZSA9IGFuY2VzdG9yTWFya2VyIHx8IHN0YXRlTm9kZVRvRW50ZXI7XG4gICAgICBpZiAocGFyZW50Py50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICAgIGludGVybmFsUXVldWUucHVzaChjcmVhdGVEb25lU3RhdGVFdmVudChwYXJlbnQuaWQsIHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0ICE9PSB1bmRlZmluZWQgPyByZXNvbHZlT3V0cHV0KHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0LCBuZXh0U25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUuc2VsZikgOiB1bmRlZmluZWQpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhbmNlc3Rvck1hcmtlcj8udHlwZSA9PT0gJ3BhcmFsbGVsJyAmJiAhY29tcGxldGVkTm9kZXMuaGFzKGFuY2VzdG9yTWFya2VyKSAmJiBpc0luRmluYWxTdGF0ZShtdXRTdGF0ZU5vZGVTZXQsIGFuY2VzdG9yTWFya2VyKSkge1xuICAgICAgICBjb21wbGV0ZWROb2Rlcy5hZGQoYW5jZXN0b3JNYXJrZXIpO1xuICAgICAgICBpbnRlcm5hbFF1ZXVlLnB1c2goY3JlYXRlRG9uZVN0YXRlRXZlbnQoYW5jZXN0b3JNYXJrZXIuaWQpKTtcbiAgICAgICAgcm9vdENvbXBsZXRpb25Ob2RlID0gYW5jZXN0b3JNYXJrZXI7XG4gICAgICAgIGFuY2VzdG9yTWFya2VyID0gYW5jZXN0b3JNYXJrZXIucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGFuY2VzdG9yTWFya2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV4dFNuYXBzaG90ID0gY2xvbmVNYWNoaW5lU25hcHNob3QobmV4dFNuYXBzaG90LCB7XG4gICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICBvdXRwdXQ6IGdldE1hY2hpbmVPdXRwdXQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFNuYXBzaG90Lm1hY2hpbmUucm9vdCwgcm9vdENvbXBsZXRpb25Ob2RlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRW50cnlTZXQodHJhbnNpdGlvbnMsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKSB7XG4gIGZvciAoY29uc3QgdCBvZiB0cmFuc2l0aW9ucykge1xuICAgIGNvbnN0IGRvbWFpbiA9IGdldFRyYW5zaXRpb25Eb21haW4odCwgaGlzdG9yeVZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdC50YXJnZXQgfHwgW10pIHtcbiAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShzKSAmJiAoXG4gICAgICAvLyBpZiB0aGUgdGFyZ2V0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCB3aWxsICpkZWZpbml0ZWx5KiBiZSBlbnRlcmVkXG4gICAgICB0LnNvdXJjZSAhPT0gcyB8fFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBkb21haW4gY2FuJ3QgbGllIHdpdGhpbiB0aGUgc291cmNlXG4gICAgICAvLyBpZiBpdCdzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCdzIG91dHNpZGUgb2YgaXQgYW5kIGl0IG1lYW5zIHRoYXQgdGhlIHRhcmdldCBoYXMgdG8gYmUgZW50ZXJlZCBhcyB3ZWxsXG4gICAgICB0LnNvdXJjZSAhPT0gZG9tYWluIHx8XG4gICAgICAvLyByZWVudGVyaW5nIHRyYW5zaXRpb25zIGFsd2F5cyBlbnRlciB0aGUgdGFyZ2V0LCBldmVuIGlmIGl0J3MgdGhlIHNvdXJjZSBpdHNlbGZcbiAgICAgIHQucmVlbnRlcikpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQocyk7XG4gICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQocyk7XG4gICAgICB9XG4gICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRlcyA9IGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0LCBoaXN0b3J5VmFsdWUpO1xuICAgIGZvciAoY29uc3QgcyBvZiB0YXJnZXRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IGdldFByb3BlckFuY2VzdG9ycyhzLCBkb21haW4pO1xuICAgICAgaWYgKGRvbWFpbj8udHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChkb21haW4pO1xuICAgICAgfVxuICAgICAgYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBhbmNlc3RvcnMsICF0LnNvdXJjZS5wYXJlbnQgJiYgdC5yZWVudGVyID8gdW5kZWZpbmVkIDogZG9tYWluKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKHN0YXRlTm9kZSwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpIHtcbiAgaWYgKGlzSGlzdG9yeU5vZGUoc3RhdGVOb2RlKSkge1xuICAgIGlmIChoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXSkge1xuICAgICAgY29uc3QgaGlzdG9yeVN0YXRlTm9kZXMgPSBoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5U3RhdGVOb2Rlcykge1xuICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChzKTtcbiAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzIG9mIGhpc3RvcnlTdGF0ZU5vZGVzKSB7XG4gICAgICAgIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzLCBzdGF0ZU5vZGUucGFyZW50LCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiA9IHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24oc3RhdGVOb2RlKTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24udGFyZ2V0KSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKHMpO1xuICAgICAgICBpZiAoaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uID09PSBzdGF0ZU5vZGUucGFyZW50Py5pbml0aWFsKSB7XG4gICAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChzdGF0ZU5vZGUucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uLnRhcmdldCkge1xuICAgICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIocywgc3RhdGVOb2RlLnBhcmVudCwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIGNvbnN0IFtpbml0aWFsU3RhdGVdID0gc3RhdGVOb2RlLmluaXRpYWwudGFyZ2V0O1xuICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGluaXRpYWxTdGF0ZSkpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChpbml0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBzdGF0ZU5vZGUsIHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5maWx0ZXIoc24gPT4gIWlzSGlzdG9yeU5vZGUoc24pKSkge1xuICAgICAgICAgIGlmICghWy4uLnN0YXRlc1RvRW50ZXJdLnNvbWUocyA9PiBpc0Rlc2NlbmRhbnQocywgY2hpbGQpKSkge1xuICAgICAgICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoY2hpbGQsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgYW5jZXN0b3JzLCByZWVudHJhbmN5RG9tYWluKSB7XG4gIGZvciAoY29uc3QgYW5jIG9mIGFuY2VzdG9ycykge1xuICAgIGlmICghcmVlbnRyYW5jeURvbWFpbiB8fCBpc0Rlc2NlbmRhbnQoYW5jLCByZWVudHJhbmN5RG9tYWluKSkge1xuICAgICAgc3RhdGVzVG9FbnRlci5hZGQoYW5jKTtcbiAgICB9XG4gICAgaWYgKGFuYy50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKGFuYykuZmlsdGVyKHNuID0+ICFpc0hpc3RvcnlOb2RlKHNuKSkpIHtcbiAgICAgICAgaWYgKCFbLi4uc3RhdGVzVG9FbnRlcl0uc29tZShzID0+IGlzRGVzY2VuZGFudChzLCBjaGlsZCkpKSB7XG4gICAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoY2hpbGQpO1xuICAgICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGNoaWxkLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlLCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSkge1xuICBhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlKSk7XG59XG5mdW5jdGlvbiBleGl0U3RhdGVzKGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSwgaW50ZXJuYWxRdWV1ZSwgX2FjdGlvbkV4ZWN1dG9yKSB7XG4gIGxldCBuZXh0U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gIGNvbnN0IHN0YXRlc1RvRXhpdCA9IGNvbXB1dGVFeGl0U2V0KHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSk7XG4gIHN0YXRlc1RvRXhpdC5zb3J0KChhLCBiKSA9PiBiLm9yZGVyIC0gYS5vcmRlcik7XG4gIGxldCBjaGFuZ2VkSGlzdG9yeTtcblxuICAvLyBGcm9tIFNDWE1MIGFsZ29yaXRobTogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNleGl0U3RhdGVzXG4gIGZvciAoY29uc3QgZXhpdFN0YXRlTm9kZSBvZiBzdGF0ZXNUb0V4aXQpIHtcbiAgICBmb3IgKGNvbnN0IGhpc3RvcnlOb2RlIG9mIGdldEhpc3RvcnlOb2RlcyhleGl0U3RhdGVOb2RlKSkge1xuICAgICAgbGV0IHByZWRpY2F0ZTtcbiAgICAgIGlmIChoaXN0b3J5Tm9kZS5oaXN0b3J5ID09PSAnZGVlcCcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gc24gPT4gaXNBdG9taWNTdGF0ZU5vZGUoc24pICYmIGlzRGVzY2VuZGFudChzbiwgZXhpdFN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWNhdGUgPSBzbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNuLnBhcmVudCA9PT0gZXhpdFN0YXRlTm9kZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNoYW5nZWRIaXN0b3J5ID8/PSB7XG4gICAgICAgIC4uLmhpc3RvcnlWYWx1ZVxuICAgICAgfTtcbiAgICAgIGNoYW5nZWRIaXN0b3J5W2hpc3RvcnlOb2RlLmlkXSA9IEFycmF5LmZyb20obXV0U3RhdGVOb2RlU2V0KS5maWx0ZXIocHJlZGljYXRlKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzIG9mIHN0YXRlc1RvRXhpdCkge1xuICAgIG5leHRTbmFwc2hvdCA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBbLi4ucy5leGl0LCAuLi5zLmludm9rZS5tYXAoZGVmID0+IHN0b3BDaGlsZChkZWYuaWQpKV0sIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gICAgbXV0U3RhdGVOb2RlU2V0LmRlbGV0ZShzKTtcbiAgfVxuICByZXR1cm4gW25leHRTbmFwc2hvdCwgY2hhbmdlZEhpc3RvcnkgfHwgaGlzdG9yeVZhbHVlXTtcbn1cbmZ1bmN0aW9uIGdldEFjdGlvbihtYWNoaW5lLCBhY3Rpb25UeXBlKSB7XG4gIHJldHVybiBtYWNoaW5lLmltcGxlbWVudGF0aW9ucy5hY3Rpb25zW2FjdGlvblR5cGVdO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgZXh0cmEsIHJldHJpZXMpIHtcbiAgY29uc3Qge1xuICAgIG1hY2hpbmVcbiAgfSA9IGN1cnJlbnRTbmFwc2hvdDtcbiAgbGV0IGludGVybWVkaWF0ZVNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nO1xuICAgIGNvbnN0IHJlc29sdmVkQWN0aW9uID0gaXNJbmxpbmUgPyBhY3Rpb24gOlxuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuYWN0aW9uc2AgYXNzdW1lcyBub24tbnVsbGFibGUgYFRFeHByZXNzaW9uQWN0aW9uYFxuICAgIC8vIGl0J3MgZmluZSB0byBjYXN0IHRoaXMgaGVyZSB0byBnZXQgYSBjb21tb24gdHlwZSBhbmQgbGFjayBvZiBlcnJvcnMgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGVcbiAgICAvLyBvdXIgbG9naWMgYmVsb3cgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG5cbiAgICBnZXRBY3Rpb24obWFjaGluZSwgdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyBhY3Rpb24gOiBhY3Rpb24udHlwZSk7XG4gICAgY29uc3QgYWN0aW9uQXJncyA9IHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5c3RlbTogYWN0b3JTY29wZS5zeXN0ZW1cbiAgICB9O1xuICAgIGNvbnN0IGFjdGlvblBhcmFtcyA9IGlzSW5saW5lIHx8IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gYWN0aW9uID8gdHlwZW9mIGFjdGlvbi5wYXJhbXMgPT09ICdmdW5jdGlvbicgPyBhY3Rpb24ucGFyYW1zKHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pIDogYWN0aW9uLnBhcmFtcyA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXJlc29sdmVkQWN0aW9uIHx8ICEoJ3Jlc29sdmUnIGluIHJlc29sdmVkQWN0aW9uKSkge1xuICAgICAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcih7XG4gICAgICAgIHR5cGU6IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gYWN0aW9uIDogdHlwZW9mIGFjdGlvbiA9PT0gJ29iamVjdCcgPyBhY3Rpb24udHlwZSA6IGFjdGlvbi5uYW1lIHx8ICcoYW5vbnltb3VzKScsXG4gICAgICAgIGluZm86IGFjdGlvbkFyZ3MsXG4gICAgICAgIHBhcmFtczogYWN0aW9uUGFyYW1zLFxuICAgICAgICBleGVjOiByZXNvbHZlZEFjdGlvblxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYnVpbHRpbkFjdGlvbiA9IHJlc29sdmVkQWN0aW9uO1xuICAgIGNvbnN0IFtuZXh0U3RhdGUsIHBhcmFtcywgYWN0aW9uc10gPSBidWlsdGluQWN0aW9uLnJlc29sdmUoYWN0b3JTY29wZSwgaW50ZXJtZWRpYXRlU25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywgcmVzb2x2ZWRBY3Rpb24sXG4gICAgLy8gdGhpcyBob2xkcyBhbGwgcGFyYW1zXG4gICAgZXh0cmEpO1xuICAgIGludGVybWVkaWF0ZVNuYXBzaG90ID0gbmV4dFN0YXRlO1xuICAgIGlmICgncmV0cnlSZXNvbHZlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICByZXRyaWVzPy5wdXNoKFtidWlsdGluQWN0aW9uLCBwYXJhbXNdKTtcbiAgICB9XG4gICAgaWYgKCdleGVjdXRlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yKHtcbiAgICAgICAgdHlwZTogYnVpbHRpbkFjdGlvbi50eXBlLFxuICAgICAgICBpbmZvOiBhY3Rpb25BcmdzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGV4ZWM6IGJ1aWx0aW5BY3Rpb24uZXhlY3V0ZS5iaW5kKG51bGwsIGFjdG9yU2NvcGUsIHBhcmFtcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYWN0aW9ucykge1xuICAgICAgaW50ZXJtZWRpYXRlU25hcHNob3QgPSByZXNvbHZlQW5kRXhlY3V0ZUFjdGlvbnNXaXRoQ29udGV4dChpbnRlcm1lZGlhdGVTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGV4dHJhLCByZXRyaWVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVybWVkaWF0ZVNuYXBzaG90O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGludGVybmFsUXVldWUsIGRlZmVycmVkQWN0b3JJZHMpIHtcbiAgY29uc3QgcmV0cmllcyA9IGRlZmVycmVkQWN0b3JJZHMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmV4dFN0YXRlID0gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywge1xuICAgIGludGVybmFsUXVldWUsXG4gICAgZGVmZXJyZWRBY3Rvcklkc1xuICB9LCByZXRyaWVzKTtcbiAgcmV0cmllcz8uZm9yRWFjaCgoW2J1aWx0aW5BY3Rpb24sIHBhcmFtc10pID0+IHtcbiAgICBidWlsdGluQWN0aW9uLnJldHJ5UmVzb2x2ZShhY3RvclNjb3BlLCBuZXh0U3RhdGUsIHBhcmFtcyk7XG4gIH0pO1xuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuZnVuY3Rpb24gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSkge1xuICBpZiAoZXZlbnQudHlwZSA9PT0gV0lMRENBUkQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGV2ZW50IGNhbm5vdCBoYXZlIHRoZSB3aWxkY2FyZCB0eXBlICgnJHtXSUxEQ0FSRH0nKWApO1xuICB9XG4gIGxldCBuZXh0U25hcHNob3QgPSBzbmFwc2hvdDtcbiAgY29uc3QgbWljcm9zdGF0ZXMgPSBbXTtcbiAgZnVuY3Rpb24gYWRkTWljcm9zdGF0ZShtaWNyb3N0YXRlLCBldmVudCwgdHJhbnNpdGlvbnMpIHtcbiAgICBhY3RvclNjb3BlLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5taWNyb3N0ZXAnLFxuICAgICAgYWN0b3JSZWY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIGV2ZW50LFxuICAgICAgc25hcHNob3Q6IG1pY3Jvc3RhdGUsXG4gICAgICBfdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zXG4gICAgfSk7XG4gICAgbWljcm9zdGF0ZXMucHVzaChtaWNyb3N0YXRlKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBzdG9wIGV2ZW50XG4gIGlmIChldmVudC50eXBlID09PSBYU1RBVEVfU1RPUCkge1xuICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KHN0b3BDaGlsZHJlbihuZXh0U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSwge1xuICAgICAgc3RhdHVzOiAnc3RvcHBlZCdcbiAgICB9KTtcbiAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgZXZlbnQsIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICAgIG1pY3Jvc3RhdGVzXG4gICAgfTtcbiAgfVxuICBsZXQgbmV4dEV2ZW50ID0gZXZlbnQ7XG5cbiAgLy8gQXNzdW1lIHRoZSBzdGF0ZSBpcyBhdCByZXN0IChubyByYWlzZWQgZXZlbnRzKVxuICAvLyBEZXRlcm1pbmUgdGhlIG5leHQgc3RhdGUgYmFzZWQgb24gdGhlIG5leHQgbWljcm9zdGVwXG4gIGlmIChuZXh0RXZlbnQudHlwZSAhPT0gWFNUQVRFX0lOSVQpIHtcbiAgICBjb25zdCBjdXJyZW50RXZlbnQgPSBuZXh0RXZlbnQ7XG4gICAgY29uc3QgaXNFcnIgPSBpc0Vycm9yQWN0b3JFdmVudChjdXJyZW50RXZlbnQpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25zID0gc2VsZWN0VHJhbnNpdGlvbnMoY3VycmVudEV2ZW50LCBuZXh0U25hcHNob3QpO1xuICAgIGlmIChpc0VyciAmJiAhdHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbGlrZWx5IG9ubHkgYWxsb3cgdHJhbnNpdGlvbnMgc2VsZWN0ZWQgYnkgdmVyeSBleHBsaWNpdCBkZXNjcmlwdG9yc1xuICAgICAgLy8gYCpgIHNob3VsZG4ndCBiZSBtYXRjaGVkLCBsaWtlbHkgYHhzdGF0ZS5lcnJvci4qYCBzaG91bGRuJ3QgYmUgZWl0aGVyXG4gICAgICAvLyBzaW1pbGFybHkgYHhzdGF0ZS5lcnJvci5hY3Rvci4qYCBhbmQgYHhzdGF0ZS5lcnJvci5hY3Rvci50b2RvLipgIGhhdmUgdG8gYmUgY29uc2lkZXJlZCB0b29cbiAgICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3I6IGN1cnJlbnRFdmVudC5lcnJvclxuICAgICAgfSk7XG4gICAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgY3VycmVudEV2ZW50LCBbXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzbmFwc2hvdDogbmV4dFNuYXBzaG90LFxuICAgICAgICBtaWNyb3N0YXRlc1xuICAgICAgfTtcbiAgICB9XG4gICAgbmV4dFNuYXBzaG90ID0gbWljcm9zdGVwKHRyYW5zaXRpb25zLCBzbmFwc2hvdCwgYWN0b3JTY29wZSwgbmV4dEV2ZW50LCBmYWxzZSxcbiAgICAvLyBpc0luaXRpYWxcbiAgICBpbnRlcm5hbFF1ZXVlKTtcbiAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgY3VycmVudEV2ZW50LCB0cmFuc2l0aW9ucyk7XG4gIH1cbiAgbGV0IHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgd2hpbGUgKG5leHRTbmFwc2hvdC5zdGF0dXMgPT09ICdhY3RpdmUnKSB7XG4gICAgbGV0IGVuYWJsZWRUcmFuc2l0aW9ucyA9IHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID8gc2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMobmV4dFNuYXBzaG90LCBuZXh0RXZlbnQpIDogW107XG5cbiAgICAvLyBldmVudGxlc3MgdHJhbnNpdGlvbnMgc2hvdWxkIGFsd2F5cyBiZSBzZWxlY3RlZCBhZnRlciBzZWxlY3RpbmcgKnJlZ3VsYXIqIHRyYW5zaXRpb25zXG4gICAgLy8gYnkgYXNzaWduaW5nIGB1bmRlZmluZWRgIHRvIGBwcmV2aW91c1N0YXRlYCB3ZSBlbnN1cmUgdGhhdCBgc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnNgIGdldHMgYWx3YXlzIGNvbXB1dGVkIHRvIHRydWUgaW4gc3VjaCBhIGNhc2VcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gZW5hYmxlZFRyYW5zaXRpb25zLmxlbmd0aCA/IG5leHRTbmFwc2hvdCA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWVuYWJsZWRUcmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGlmICghaW50ZXJuYWxRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuZXh0RXZlbnQgPSBpbnRlcm5hbFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBlbmFibGVkVHJhbnNpdGlvbnMgPSBzZWxlY3RUcmFuc2l0aW9ucyhuZXh0RXZlbnQsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICAgIG5leHRTbmFwc2hvdCA9IG1pY3Jvc3RlcChlbmFibGVkVHJhbnNpdGlvbnMsIG5leHRTbmFwc2hvdCwgYWN0b3JTY29wZSwgbmV4dEV2ZW50LCBmYWxzZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMgPSBuZXh0U25hcHNob3QgIT09IHByZXZpb3VzU3RhdGU7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIG5leHRFdmVudCwgZW5hYmxlZFRyYW5zaXRpb25zKTtcbiAgfVxuICBpZiAobmV4dFNuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICBzdG9wQ2hpbGRyZW4obmV4dFNuYXBzaG90LCBuZXh0RXZlbnQsIGFjdG9yU2NvcGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICBtaWNyb3N0YXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc3RvcENoaWxkcmVuKG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUpIHtcbiAgcmV0dXJuIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBPYmplY3QudmFsdWVzKG5leHRTdGF0ZS5jaGlsZHJlbikubWFwKGNoaWxkID0+IHN0b3BDaGlsZChjaGlsZCkpLCBbXSwgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRyYW5zaXRpb25zKGV2ZW50LCBuZXh0U3RhdGUpIHtcbiAgcmV0dXJuIG5leHRTdGF0ZS5tYWNoaW5lLmdldFRyYW5zaXRpb25EYXRhKG5leHRTdGF0ZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gc2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMobmV4dFN0YXRlLCBldmVudCkge1xuICBjb25zdCBlbmFibGVkVHJhbnNpdGlvblNldCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgYXRvbWljU3RhdGVzID0gbmV4dFN0YXRlLl9ub2Rlcy5maWx0ZXIoaXNBdG9taWNTdGF0ZU5vZGUpO1xuICBmb3IgKGNvbnN0IHN0YXRlTm9kZSBvZiBhdG9taWNTdGF0ZXMpIHtcbiAgICBsb29wOiBmb3IgKGNvbnN0IHMgb2YgW3N0YXRlTm9kZV0uY29uY2F0KGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHVuZGVmaW5lZCkpKSB7XG4gICAgICBpZiAoIXMuYWx3YXlzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIHMuYWx3YXlzKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uLmd1YXJkID09PSB1bmRlZmluZWQgfHwgZXZhbHVhdGVHdWFyZCh0cmFuc2l0aW9uLmd1YXJkLCBuZXh0U3RhdGUuY29udGV4dCwgZXZlbnQsIG5leHRTdGF0ZSkpIHtcbiAgICAgICAgICBlbmFibGVkVHJhbnNpdGlvblNldC5hZGQodHJhbnNpdGlvbik7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVtb3ZlQ29uZmxpY3RpbmdUcmFuc2l0aW9ucyhBcnJheS5mcm9tKGVuYWJsZWRUcmFuc2l0aW9uU2V0KSwgbmV3IFNldChuZXh0U3RhdGUuX25vZGVzKSwgbmV4dFN0YXRlLmhpc3RvcnlWYWx1ZSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBwYXJ0aWFsIHN0YXRlIHZhbHVlIHdpdGggaXRzIGZ1bGwgcmVwcmVzZW50YXRpb24gaW4gdGhlIHN0YXRlXG4gKiBub2RlJ3MgbWFjaGluZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgcGFydGlhbCBzdGF0ZSB2YWx1ZSB0byByZXNvbHZlLlxuICovXG5mdW5jdGlvbiByZXNvbHZlU3RhdGVWYWx1ZShyb290Tm9kZSwgc3RhdGVWYWx1ZSkge1xuICBjb25zdCBhbGxTdGF0ZU5vZGVzID0gZ2V0QWxsU3RhdGVOb2RlcyhnZXRTdGF0ZU5vZGVzKHJvb3ROb2RlLCBzdGF0ZVZhbHVlKSk7XG4gIHJldHVybiBnZXRTdGF0ZVZhbHVlKHJvb3ROb2RlLCBbLi4uYWxsU3RhdGVOb2Rlc10pO1xufVxuXG5mdW5jdGlvbiBpc01hY2hpbmVTbmFwc2hvdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdtYWNoaW5lJyBpbiB2YWx1ZSAmJiAndmFsdWUnIGluIHZhbHVlO1xufVxuY29uc3QgbWFjaGluZVNuYXBzaG90TWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXModGVzdFZhbHVlKSB7XG4gIHJldHVybiBtYXRjaGVzU3RhdGUodGVzdFZhbHVlLCB0aGlzLnZhbHVlKTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RIYXNUYWcgPSBmdW5jdGlvbiBoYXNUYWcodGFnKSB7XG4gIHJldHVybiB0aGlzLnRhZ3MuaGFzKHRhZyk7XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90Q2FuID0gZnVuY3Rpb24gY2FuKGV2ZW50KSB7XG4gIGlmICghdGhpcy5tYWNoaW5lKSB7XG4gICAgY29uc29sZS53YXJuKGBzdGF0ZS5jYW4oLi4uKSB1c2VkIG91dHNpZGUgb2YgYSBtYWNoaW5lLWNyZWF0ZWQgU3RhdGUgb2JqZWN0OyB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5gKTtcbiAgfVxuICBjb25zdCB0cmFuc2l0aW9uRGF0YSA9IHRoaXMubWFjaGluZS5nZXRUcmFuc2l0aW9uRGF0YSh0aGlzLCBldmVudCk7XG4gIHJldHVybiAhIXRyYW5zaXRpb25EYXRhPy5sZW5ndGggJiZcbiAgLy8gQ2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdHJhbnNpdGlvbiBpcyBub3QgZm9yYmlkZGVuXG4gIHRyYW5zaXRpb25EYXRhLnNvbWUodCA9PiB0LnRhcmdldCAhPT0gdW5kZWZpbmVkIHx8IHQuYWN0aW9ucy5sZW5ndGgpO1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdFRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgY29uc3Qge1xuICAgIF9ub2Rlczogbm9kZXMsXG4gICAgdGFncyxcbiAgICBtYWNoaW5lLFxuICAgIGdldE1ldGEsXG4gICAgdG9KU09OLFxuICAgIGNhbixcbiAgICBoYXNUYWcsXG4gICAgbWF0Y2hlcyxcbiAgICAuLi5qc29uVmFsdWVzXG4gIH0gPSB0aGlzO1xuICByZXR1cm4ge1xuICAgIC4uLmpzb25WYWx1ZXMsXG4gICAgdGFnczogQXJyYXkuZnJvbSh0YWdzKVxuICB9O1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdEdldE1ldGEgPSBmdW5jdGlvbiBnZXRNZXRhKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMucmVkdWNlKChhY2MsIHN0YXRlTm9kZSkgPT4ge1xuICAgIGlmIChzdGF0ZU5vZGUubWV0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY2Nbc3RhdGVOb2RlLmlkXSA9IHN0YXRlTm9kZS5tZXRhO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlTWFjaGluZVNuYXBzaG90KGNvbmZpZywgbWFjaGluZSkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogY29uZmlnLnN0YXR1cyxcbiAgICBvdXRwdXQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgZXJyb3I6IGNvbmZpZy5lcnJvcixcbiAgICBtYWNoaW5lLFxuICAgIGNvbnRleHQ6IGNvbmZpZy5jb250ZXh0LFxuICAgIF9ub2RlczogY29uZmlnLl9ub2RlcyxcbiAgICB2YWx1ZTogZ2V0U3RhdGVWYWx1ZShtYWNoaW5lLnJvb3QsIGNvbmZpZy5fbm9kZXMpLFxuICAgIHRhZ3M6IG5ldyBTZXQoY29uZmlnLl9ub2Rlcy5mbGF0TWFwKHNuID0+IHNuLnRhZ3MpKSxcbiAgICBjaGlsZHJlbjogY29uZmlnLmNoaWxkcmVuLFxuICAgIGhpc3RvcnlWYWx1ZTogY29uZmlnLmhpc3RvcnlWYWx1ZSB8fCB7fSxcbiAgICBtYXRjaGVzOiBtYWNoaW5lU25hcHNob3RNYXRjaGVzLFxuICAgIGhhc1RhZzogbWFjaGluZVNuYXBzaG90SGFzVGFnLFxuICAgIGNhbjogbWFjaGluZVNuYXBzaG90Q2FuLFxuICAgIGdldE1ldGE6IG1hY2hpbmVTbmFwc2hvdEdldE1ldGEsXG4gICAgdG9KU09OOiBtYWNoaW5lU25hcHNob3RUb0pTT05cbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICAuLi5jb25maWdcbiAgfSwgc25hcHNob3QubWFjaGluZSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVIaXN0b3J5VmFsdWUoaGlzdG9yeVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaGlzdG9yeVZhbHVlICE9PSAnb2JqZWN0JyB8fCBoaXN0b3J5VmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGhpc3RvcnlWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gaGlzdG9yeVZhbHVlW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlLm1hcChpdGVtID0+ICh7XG4gICAgICAgIGlkOiBpdGVtLmlkXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgX25vZGVzOiBub2RlcyxcbiAgICB0YWdzLFxuICAgIG1hY2hpbmUsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjYW4sXG4gICAgaGFzVGFnLFxuICAgIG1hdGNoZXMsXG4gICAgZ2V0TWV0YSxcbiAgICB0b0pTT04sXG4gICAgLi4uanNvblZhbHVlc1xuICB9ID0gc25hcHNob3Q7XG4gIGNvbnN0IGNoaWxkcmVuSnNvbiA9IHt9O1xuICBmb3IgKGNvbnN0IGlkIGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpZF07XG4gICAgaWYgKHR5cGVvZiBjaGlsZC5zcmMgIT09ICdzdHJpbmcnICYmICghb3B0aW9ucyB8fCAhKCdfX3Vuc2FmZUFsbG93SW5saW5lQWN0b3JzJyBpbiBvcHRpb25zKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaW5saW5lIGNoaWxkIGFjdG9yIGNhbm5vdCBiZSBwZXJzaXN0ZWQuJyk7XG4gICAgfVxuICAgIGNoaWxkcmVuSnNvbltpZF0gPSB7XG4gICAgICBzbmFwc2hvdDogY2hpbGQuZ2V0UGVyc2lzdGVkU25hcHNob3Qob3B0aW9ucyksXG4gICAgICBzcmM6IGNoaWxkLnNyYyxcbiAgICAgIHN5c3RlbUlkOiBjaGlsZC5zeXN0ZW1JZCxcbiAgICAgIHN5bmNTbmFwc2hvdDogY2hpbGQuX3N5bmNTbmFwc2hvdFxuICAgIH07XG4gIH1cbiAgY29uc3QgcGVyc2lzdGVkID0ge1xuICAgIC4uLmpzb25WYWx1ZXMsXG4gICAgY29udGV4dDogcGVyc2lzdENvbnRleHQoY29udGV4dCksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuSnNvbixcbiAgICBoaXN0b3J5VmFsdWU6IHNlcmlhbGl6ZUhpc3RvcnlWYWx1ZShqc29uVmFsdWVzLmhpc3RvcnlWYWx1ZSlcbiAgfTtcbiAgcmV0dXJuIHBlcnNpc3RlZDtcbn1cbmZ1bmN0aW9uIHBlcnNpc3RDb250ZXh0KGNvbnRleHRQYXJ0KSB7XG4gIGxldCBjb3B5O1xuICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0UGFydCkge1xuICAgIGNvbnN0IHZhbHVlID0gY29udGV4dFBhcnRba2V5XTtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCdzZXNzaW9uSWQnIGluIHZhbHVlICYmICdzZW5kJyBpbiB2YWx1ZSAmJiAncmVmJyBpbiB2YWx1ZSkge1xuICAgICAgICBjb3B5ID8/PSBBcnJheS5pc0FycmF5KGNvbnRleHRQYXJ0KSA/IGNvbnRleHRQYXJ0LnNsaWNlKCkgOiB7XG4gICAgICAgICAgLi4uY29udGV4dFBhcnRcbiAgICAgICAgfTtcbiAgICAgICAgY29weVtrZXldID0ge1xuICAgICAgICAgIHhzdGF0ZSQkdHlwZTogJCRBQ1RPUl9UWVBFLFxuICAgICAgICAgIGlkOiB2YWx1ZS5pZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGVyc2lzdENvbnRleHQodmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGNvcHkgPz89IEFycmF5LmlzQXJyYXkoY29udGV4dFBhcnQpID8gY29udGV4dFBhcnQuc2xpY2UoKSA6IHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQYXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb3B5W2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcHkgPz8gY29udGV4dFBhcnQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSYWlzZShfLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGV2ZW50OiBldmVudE9yRXhwcixcbiAgaWQsXG4gIGRlbGF5XG59LCB7XG4gIGludGVybmFsUXVldWVcbn0pIHtcbiAgY29uc3QgZGVsYXlzTWFwID0gc25hcHNob3QubWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuZGVsYXlzO1xuICBpZiAodHlwZW9mIGV2ZW50T3JFeHByID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgYE9ubHkgZXZlbnQgb2JqZWN0cyBtYXkgYmUgdXNlZCB3aXRoIHJhaXNlOyB1c2UgcmFpc2UoeyB0eXBlOiBcIiR7ZXZlbnRPckV4cHJ9XCIgfSkgaW5zdGVhZGApO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkRXZlbnQgPSB0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdmdW5jdGlvbicgPyBldmVudE9yRXhwcihhcmdzLCBhY3Rpb25QYXJhbXMpIDogZXZlbnRPckV4cHI7XG4gIGxldCByZXNvbHZlZERlbGF5O1xuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNvbmZpZ0RlbGF5ID0gZGVsYXlzTWFwICYmIGRlbGF5c01hcFtkZWxheV07XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBjb25maWdEZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZ0RlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBjb25maWdEZWxheTtcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZERlbGF5ID0gdHlwZW9mIGRlbGF5ID09PSAnZnVuY3Rpb24nID8gZGVsYXkoYXJncywgYWN0aW9uUGFyYW1zKSA6IGRlbGF5O1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb2x2ZWREZWxheSAhPT0gJ251bWJlcicpIHtcbiAgICBpbnRlcm5hbFF1ZXVlLnB1c2gocmVzb2x2ZWRFdmVudCk7XG4gIH1cbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIGV2ZW50OiByZXNvbHZlZEV2ZW50LFxuICAgIGlkLFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlUmFpc2UoYWN0b3JTY29wZSwgcGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBldmVudCxcbiAgICBkZWxheSxcbiAgICBpZFxuICB9ID0gcGFyYW1zO1xuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZiA9IGFjdG9yU2NvcGUuc2VsZjtcbiAgICAgIGFjdG9yU2NvcGUuc3lzdGVtLnNjaGVkdWxlci5zY2hlZHVsZShzZWxmLCBzZWxmLCBldmVudCwgZGVsYXksIGlkKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbn1cbi8qKlxuICogUmFpc2VzIGFuIGV2ZW50LiBUaGlzIHBsYWNlcyB0aGUgZXZlbnQgaW4gdGhlIGludGVybmFsIGV2ZW50IHF1ZXVlLCBzbyB0aGF0XG4gKiB0aGUgZXZlbnQgaXMgaW1tZWRpYXRlbHkgY29uc3VtZWQgYnkgdGhlIG1hY2hpbmUgaW4gdGhlIGN1cnJlbnQgc3RlcC5cbiAqXG4gKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBldmVudCB0byByYWlzZS5cbiAqL1xuZnVuY3Rpb24gcmFpc2UoZXZlbnRPckV4cHIsIG9wdGlvbnMpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGByYWlzZSgpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiByYWlzZShfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgcmFpc2UudHlwZSA9ICd4c3RhdGUucmFpc2UnO1xuICByYWlzZS5ldmVudCA9IGV2ZW50T3JFeHByO1xuICByYWlzZS5pZCA9IG9wdGlvbnM/LmlkO1xuICByYWlzZS5kZWxheSA9IG9wdGlvbnM/LmRlbGF5O1xuICByYWlzZS5yZXNvbHZlID0gcmVzb2x2ZVJhaXNlO1xuICByYWlzZS5leGVjdXRlID0gZXhlY3V0ZVJhaXNlO1xuICByZXR1cm4gcmFpc2U7XG59XG5cbmV4cG9ydCB7ICQkQUNUT1JfVFlQRSBhcyAkLCBBY3RvciBhcyBBLCBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbiBhcyBCLCBnZXRDYW5kaWRhdGVzIGFzIEMsIHJlc29sdmVTdGF0ZVZhbHVlIGFzIEQsIGdldEFsbFN0YXRlTm9kZXMgYXMgRSwgY3JlYXRlTWFjaGluZVNuYXBzaG90IGFzIEYsIGlzSW5GaW5hbFN0YXRlIGFzIEcsIG1hY3Jvc3RlcCBhcyBILCB0cmFuc2l0aW9uTm9kZSBhcyBJLCByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQgYXMgSiwgY3JlYXRlSW5pdEV2ZW50IGFzIEssIG1pY3Jvc3RlcCBhcyBMLCBnZXRJbml0aWFsU3RhdGVOb2RlcyBhcyBNLCBOVUxMX0VWRU5UIGFzIE4sIHRvU3RhdGVQYXRoIGFzIE8sIGlzU3RhdGVJZCBhcyBQLCBnZXRTdGF0ZU5vZGVCeVBhdGggYXMgUSwgZ2V0UGVyc2lzdGVkU25hcHNob3QgYXMgUiwgU1RBVEVfREVMSU1JVEVSIGFzIFMsIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IgYXMgVCwgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uIGFzIFUsIFhTVEFURV9FUlJPUiBhcyBWLCBjcmVhdGVFcnJvckFjdG9yRXZlbnQgYXMgVywgWFNUQVRFX1NUT1AgYXMgWCwgUHJvY2Vzc2luZ1N0YXR1cyBhcyBZLCBjbG9uZU1hY2hpbmVTbmFwc2hvdCBhcyBaLCBjYW5jZWwgYXMgYSwgc3Bhd25DaGlsZCBhcyBiLCBjcmVhdGVBY3RvciBhcyBjLCBhbmQgYXMgZCwgc3RhdGVJbiBhcyBlLCBpc01hY2hpbmVTbmFwc2hvdCBhcyBmLCBnZXRTdGF0ZU5vZGVzIGFzIGcsIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMgYXMgaCwgaW50ZXJwcmV0IGFzIGksIG1hdGNoZXNTdGF0ZSBhcyBqLCB0b09ic2VydmVyIGFzIGssIHN0b3AgYXMgbCwgbWF0Y2hlc0V2ZW50RGVzY3JpcHRvciBhcyBtLCBub3QgYXMgbiwgb3IgYXMgbywgcGF0aFRvU3RhdGVWYWx1ZSBhcyBwLCBtYXBWYWx1ZXMgYXMgcSwgcmFpc2UgYXMgciwgc3RvcENoaWxkIGFzIHMsIHRvQXJyYXkgYXMgdCwgZm9ybWF0VHJhbnNpdGlvbnMgYXMgdSwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkgYXMgdiwgZm9ybWF0VHJhbnNpdGlvbiBhcyB3LCBldmFsdWF0ZUd1YXJkIGFzIHgsIGNyZWF0ZUludm9rZUlkIGFzIHksIGdldERlbGF5ZWRUcmFuc2l0aW9ucyBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/raise-13a60c49.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/xstate.development.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/xstate/dist/xstate.development.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actor: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A),\n/* harmony export */   SimulatedClock: () => (/* binding */ SimulatedClock),\n/* harmony export */   SpecialTargets: () => (/* reexport safe */ _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.S),\n/* harmony export */   StateMachine: () => (/* reexport safe */ _StateMachine_d0e98d09_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S),\n/* harmony export */   StateNode: () => (/* reexport safe */ _StateMachine_d0e98d09_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   __unsafe_getAllOwnEventDescriptors: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.h),\n/* harmony export */   and: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.d),\n/* harmony export */   assertEvent: () => (/* binding */ assertEvent),\n/* harmony export */   assign: () => (/* reexport safe */ _assign_541a432d_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.a),\n/* harmony export */   cancel: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a),\n/* harmony export */   createActor: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c),\n/* harmony export */   createEmptyActor: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.createEmptyActor),\n/* harmony export */   createMachine: () => (/* binding */ createMachine),\n/* harmony export */   emit: () => (/* reexport safe */ _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.a),\n/* harmony export */   enqueueActions: () => (/* reexport safe */ _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.e),\n/* harmony export */   forwardTo: () => (/* reexport safe */ _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.f),\n/* harmony export */   fromCallback: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromCallback),\n/* harmony export */   fromEventObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromEventObservable),\n/* harmony export */   fromObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromObservable),\n/* harmony export */   fromPromise: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromPromise),\n/* harmony export */   fromTransition: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromTransition),\n/* harmony export */   getInitialSnapshot: () => (/* binding */ getInitialSnapshot),\n/* harmony export */   getNextSnapshot: () => (/* binding */ getNextSnapshot),\n/* harmony export */   getStateNodes: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.g),\n/* harmony export */   initialTransition: () => (/* binding */ initialTransition),\n/* harmony export */   interpret: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i),\n/* harmony export */   isMachineSnapshot: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.f),\n/* harmony export */   log: () => (/* reexport safe */ _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.l),\n/* harmony export */   matchesState: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j),\n/* harmony export */   not: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n),\n/* harmony export */   or: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.o),\n/* harmony export */   pathToStateValue: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.p),\n/* harmony export */   raise: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r),\n/* harmony export */   sendParent: () => (/* reexport safe */ _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.b),\n/* harmony export */   sendTo: () => (/* reexport safe */ _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.s),\n/* harmony export */   setup: () => (/* binding */ setup),\n/* harmony export */   spawnChild: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b),\n/* harmony export */   stateIn: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.e),\n/* harmony export */   stop: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.l),\n/* harmony export */   stopChild: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s),\n/* harmony export */   toObserver: () => (/* reexport safe */ _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k),\n/* harmony export */   toPromise: () => (/* binding */ toPromise),\n/* harmony export */   transition: () => (/* binding */ transition),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actors/dist/xstate-actors.development.esm.js */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raise-13a60c49.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-13a60c49.development.esm.js\");\n/* harmony import */ var _StateMachine_d0e98d09_development_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateMachine-d0e98d09.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/StateMachine-d0e98d09.development.esm.js\");\n/* harmony import */ var _assign_541a432d_development_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assign-541a432d.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-541a432d.development.esm.js\");\n/* harmony import */ var _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./log-b8ca474e.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/log-b8ca474e.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */\nfunction assertEvent(event, type) {\n  const types = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(type);\n  const matches = types.some(descriptor => (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(event.type, descriptor));\n  if (!matches) {\n    const typesText = types.length === 1 ? `type matching \"${types[0]}\"` : `one of types matching \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\n\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */\nfunction createMachine(config, implementations) {\n  return new _StateMachine_d0e98d09_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = (0,_raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {},\n    actionExecutor: () => {}\n  };\n  return inertActorScope;\n}\n\n/** @deprecated Use `initialTransition(…)` instead. */\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\n\n// used to keep only StateSchema relevant keys\n// this helps with type serialization as it makes the inferred type much shorter when dealing with huge configs\n\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    assign: _assign_541a432d_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.a,\n    sendTo: _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.s,\n    raise: _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r,\n    log: _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.l,\n    cancel: _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a,\n    stopChild: _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s,\n    enqueueActions: _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.e,\n    emit: _log_b8ca474e_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.a,\n    spawnChild: _raise_13a60c49_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b,\n    createStateConfig: config => config,\n    createAction: fn => fn,\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    }),\n    extend: extended => setup({\n      schemas,\n      actors,\n      actions: {\n        ...actions,\n        ...extended.actions\n      },\n      guards: {\n        ...guards,\n        ...extended.guards\n      },\n      delays: {\n        ...delays,\n        ...extended.delays\n      }\n    })\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */\nfunction transition(logic, snapshot, event) {\n  const executableActions = [];\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = action => {\n    executableActions.push(action);\n  };\n  const nextSnapshot = logic.transition(snapshot, event, actorScope);\n  return [nextSnapshot, executableActions];\n}\n\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */\nfunction initialTransition(logic, ...[input]) {\n  const executableActions = [];\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = action => {\n    executableActions.push(action);\n  };\n  const nextSnapshot = logic.getInitialSnapshot(actorScope, input);\n  return [nextSnapshot, executableActions];\n}\n\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    const {\n      signal\n    } = resolvedOptions;\n    if (signal?.aborted) {\n      // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n      rej(signal.reason);\n      return;\n    }\n    let done = false;\n    if (resolvedOptions.timeout < 0) {\n      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');\n    }\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      dispose();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n      if (abortListener) {\n        signal.removeEventListener('abort', abortListener);\n      }\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */\n    let abortListener;\n    // eslint-disable-next-line prefer-const\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    // only define the `abortListener` if the `signal` option is provided\n    if (signal) {\n      abortListener = () => {\n        dispose();\n        // XState does not \"own\" the signal, so we should reject with its reason (if any)\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(signal.reason);\n      };\n      signal.addEventListener('abort', abortListener);\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QveHN0YXRlLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSztBQUNTO0FBQ3VMO0FBQ3BSO0FBQ2dCO0FBQzVCO0FBQ0E7QUFDdUM7QUFDc0Q7QUFDN0c7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxtQkFBbUI7QUFDbkIsSUFBSTtBQUNKO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLGFBQWEsZ0JBQWdCLGlCQUFpQjtBQUM5QyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFPO0FBQ3ZCLDJDQUEyQyxxRUFBc0I7QUFDakU7QUFDQSw2REFBNkQsU0FBUywrQkFBK0IsbUJBQW1CO0FBQ3hILHNDQUFzQyx1QkFBdUIsVUFBVSxVQUFVO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSyx5QkFBeUIsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdFQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFFQUFXO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVixTQUFTO0FBQ1QsT0FBTztBQUNQLFVBQVU7QUFDVixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFcUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdmVkaWFuLW5ld3Nyb29tLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L3hzdGF0ZS5kZXZlbG9wbWVudC5lc20uanM/NTA0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBjcmVhdGVFbXB0eUFjdG9yLCBmcm9tQ2FsbGJhY2ssIGZyb21FdmVudE9ic2VydmFibGUsIGZyb21PYnNlcnZhYmxlLCBmcm9tUHJvbWlzZSwgZnJvbVRyYW5zaXRpb24gfSBmcm9tICcuLi9hY3RvcnMvZGlzdC94c3RhdGUtYWN0b3JzLmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgeyBtIGFzIG1hdGNoZXNFdmVudERlc2NyaXB0b3IsIHQgYXMgdG9BcnJheSwgYyBhcyBjcmVhdGVBY3RvciwgciBhcyByYWlzZSwgYSBhcyBjYW5jZWwsIHMgYXMgc3RvcENoaWxkLCBiIGFzIHNwYXduQ2hpbGQgfSBmcm9tICcuL3JhaXNlLTEzYTYwYzQ5LmRldmVsb3BtZW50LmVzbS5qcyc7XG5leHBvcnQgeyBBIGFzIEFjdG9yLCBoIGFzIF9fdW5zYWZlX2dldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMsIGQgYXMgYW5kLCBhIGFzIGNhbmNlbCwgYyBhcyBjcmVhdGVBY3RvciwgZyBhcyBnZXRTdGF0ZU5vZGVzLCBpIGFzIGludGVycHJldCwgZiBhcyBpc01hY2hpbmVTbmFwc2hvdCwgaiBhcyBtYXRjaGVzU3RhdGUsIG4gYXMgbm90LCBvIGFzIG9yLCBwIGFzIHBhdGhUb1N0YXRlVmFsdWUsIHIgYXMgcmFpc2UsIGIgYXMgc3Bhd25DaGlsZCwgZSBhcyBzdGF0ZUluLCBsIGFzIHN0b3AsIHMgYXMgc3RvcENoaWxkLCBrIGFzIHRvT2JzZXJ2ZXIgfSBmcm9tICcuL3JhaXNlLTEzYTYwYzQ5LmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgeyBTIGFzIFN0YXRlTWFjaGluZSB9IGZyb20gJy4vU3RhdGVNYWNoaW5lLWQwZTk4ZDA5LmRldmVsb3BtZW50LmVzbS5qcyc7XG5leHBvcnQgeyBTIGFzIFN0YXRlTWFjaGluZSwgYSBhcyBTdGF0ZU5vZGUgfSBmcm9tICcuL1N0YXRlTWFjaGluZS1kMGU5OGQwOS5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuL2Fzc2lnbi01NDFhNDMyZC5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuL2Fzc2lnbi01NDFhNDMyZC5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgcyBhcyBzZW5kVG8sIGwgYXMgbG9nLCBlIGFzIGVucXVldWVBY3Rpb25zLCBhIGFzIGVtaXQgfSBmcm9tICcuL2xvZy1iOGNhNDc0ZS5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgUyBhcyBTcGVjaWFsVGFyZ2V0cywgYSBhcyBlbWl0LCBlIGFzIGVucXVldWVBY3Rpb25zLCBmIGFzIGZvcndhcmRUbywgbCBhcyBsb2csIGIgYXMgc2VuZFBhcmVudCwgcyBhcyBzZW5kVG8gfSBmcm9tICcuL2xvZy1iOGNhNDc0ZS5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0ICcuLi9kZXYvZGlzdC94c3RhdGUtZGV2LmRldmVsb3BtZW50LmVzbS5qcyc7XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBldmVudCBvYmplY3QgaXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9yIHR5cGVzLiBUaHJvd3NcbiAqIGFuIGVycm9yIGlmIHRoZSBldmVudCBvYmplY3QgaXMgbm90IG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogLy8gLi4uXG4gKiBlbnRyeTogKHsgZXZlbnQgfSkgPT4ge1xuICogICBhc3NlcnRFdmVudChldmVudCwgJ2RvTm90aGluZycpO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdkb05vdGhpbmcnIH1cbiAqIH0sXG4gKiAvLyAuLi5cbiAqIGV4aXQ6ICh7IGV2ZW50IH0pID0+IHtcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsICdncmVldCcpO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdncmVldCc7IG1lc3NhZ2U6IHN0cmluZyB9XG4gKlxuICogICBhc3NlcnRFdmVudChldmVudCwgWydncmVldCcsICdub3RpZnknXSk7XG4gKiAgIC8vIGV2ZW50IGlzIHsgdHlwZTogJ2dyZWV0JzsgbWVzc2FnZTogc3RyaW5nIH1cbiAqICAgLy8gb3IgeyB0eXBlOiAnbm90aWZ5JzsgbWVzc2FnZTogc3RyaW5nOyBsZXZlbDogJ2luZm8nIHwgJ2Vycm9yJyB9XG4gKiB9LFxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV2ZW50KGV2ZW50LCB0eXBlKSB7XG4gIGNvbnN0IHR5cGVzID0gdG9BcnJheSh0eXBlKTtcbiAgY29uc3QgbWF0Y2hlcyA9IHR5cGVzLnNvbWUoZGVzY3JpcHRvciA9PiBtYXRjaGVzRXZlbnREZXNjcmlwdG9yKGV2ZW50LnR5cGUsIGRlc2NyaXB0b3IpKTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgY29uc3QgdHlwZXNUZXh0ID0gdHlwZXMubGVuZ3RoID09PSAxID8gYHR5cGUgbWF0Y2hpbmcgXCIke3R5cGVzWzBdfVwiYCA6IGBvbmUgb2YgdHlwZXMgbWF0Y2hpbmcgXCIke3R5cGVzLmpvaW4oJ1wiLCBcIicpfVwiYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQpfSB0byBoYXZlICR7dHlwZXNUZXh0fWApO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YXRlIG1hY2hpbmUgKHN0YXRlY2hhcnQpIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVGhlIHN0YXRlIG1hY2hpbmUgcmVwcmVzZW50cyB0aGUgcHVyZSBsb2dpYyBvZiBhIHN0YXRlIG1hY2hpbmUgYWN0b3IuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlTWFjaGluZSB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbGlnaHRNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGlkOiAnbGlnaHQnLFxuICogICBpbml0aWFsOiAnZ3JlZW4nLFxuICogICBzdGF0ZXM6IHtcbiAqICAgICBncmVlbjoge1xuICogICAgICAgb246IHtcbiAqICAgICAgICAgVElNRVI6IHsgdGFyZ2V0OiAneWVsbG93JyB9XG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB5ZWxsb3c6IHtcbiAqICAgICAgIG9uOiB7XG4gKiAgICAgICAgIFRJTUVSOiB7IHRhcmdldDogJ3JlZCcgfVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgcmVkOiB7XG4gKiAgICAgICBvbjoge1xuICogICAgICAgICBUSU1FUjogeyB0YXJnZXQ6ICdncmVlbicgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKlxuICogY29uc3QgbGlnaHRBY3RvciA9IGNyZWF0ZUFjdG9yKGxpZ2h0TWFjaGluZSk7XG4gKiBsaWdodEFjdG9yLnN0YXJ0KCk7XG4gKlxuICogbGlnaHRBY3Rvci5zZW5kKHsgdHlwZTogJ1RJTUVSJyB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb25maWcgVGhlIHN0YXRlIG1hY2hpbmUgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSBvcHRpb25zIERFUFJFQ0FURUQ6IHVzZSBgc2V0dXAoeyAuLi4gfSlgIG9yIGBtYWNoaW5lLnByb3ZpZGUoeyAuLi4gfSlgXG4gKiAgIHRvIHByb3ZpZGUgbWFjaGluZSBpbXBsZW1lbnRhdGlvbnMgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFjaGluZShjb25maWcsIGltcGxlbWVudGF0aW9ucykge1xuICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZShjb25maWcsIGltcGxlbWVudGF0aW9ucyk7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZXJ0QWN0b3JTY29wZShhY3RvckxvZ2ljKSB7XG4gIGNvbnN0IHNlbGYgPSBjcmVhdGVBY3RvcihhY3RvckxvZ2ljKTtcbiAgY29uc3QgaW5lcnRBY3RvclNjb3BlID0ge1xuICAgIHNlbGYsXG4gICAgZGVmZXI6ICgpID0+IHt9LFxuICAgIGlkOiAnJyxcbiAgICBsb2dnZXI6ICgpID0+IHt9LFxuICAgIHNlc3Npb25JZDogJycsXG4gICAgc3RvcENoaWxkOiAoKSA9PiB7fSxcbiAgICBzeXN0ZW06IHNlbGYuc3lzdGVtLFxuICAgIGVtaXQ6ICgpID0+IHt9LFxuICAgIGFjdGlvbkV4ZWN1dG9yOiAoKSA9PiB7fVxuICB9O1xuICByZXR1cm4gaW5lcnRBY3RvclNjb3BlO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBpbml0aWFsVHJhbnNpdGlvbijigKYpYCBpbnN0ZWFkLiAqL1xuZnVuY3Rpb24gZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yTG9naWMsIC4uLltpbnB1dF0pIHtcbiAgY29uc3QgYWN0b3JTY29wZSA9IGNyZWF0ZUluZXJ0QWN0b3JTY29wZShhY3RvckxvZ2ljKTtcbiAgcmV0dXJuIGFjdG9yTG9naWMuZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yU2NvcGUsIGlucHV0KTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHNuYXBzaG90IGZvciB0aGUgZ2l2ZW4gYGFjdG9yTG9naWNgIGJhc2VkIG9uIHRoZSBnaXZlblxuICogYHNuYXBzaG90YCBhbmQgYGV2ZW50YC5cbiAqXG4gKiBJZiB0aGUgYHNuYXBzaG90YCBpcyBgdW5kZWZpbmVkYCwgdGhlIGluaXRpYWwgc25hcHNob3Qgb2YgdGhlIGBhY3RvckxvZ2ljYCBpc1xuICogdXNlZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHRyYW5zaXRpb24o4oCmKWAgaW5zdGVhZC5cbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGdldE5leHRTbmFwc2hvdCB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyB0cmFmZmljTGlnaHRNYWNoaW5lIH0gZnJvbSAnLi90cmFmZmljTGlnaHRNYWNoaW5lLnRzJztcbiAqXG4gKiBjb25zdCBuZXh0U25hcHNob3QgPSBnZXROZXh0U25hcHNob3QoXG4gKiAgIHRyYWZmaWNMaWdodE1hY2hpbmUsIC8vIGFjdG9yIGxvZ2ljXG4gKiAgIHVuZGVmaW5lZCwgLy8gc25hcHNob3QgKG9yIGluaXRpYWwgc3RhdGUgaWYgdW5kZWZpbmVkKVxuICogICB7IHR5cGU6ICdUSU1FUicgfVxuICogKTsgLy8gZXZlbnQgb2JqZWN0XG4gKlxuICogY29uc29sZS5sb2cobmV4dFNuYXBzaG90LnZhbHVlKTtcbiAqIC8vID0+ICd5ZWxsb3cnXG4gKlxuICogY29uc3QgbmV4dFNuYXBzaG90MiA9IGdldE5leHRTbmFwc2hvdChcbiAqICAgdHJhZmZpY0xpZ2h0TWFjaGluZSwgLy8gYWN0b3IgbG9naWNcbiAqICAgbmV4dFNuYXBzaG90LCAvLyBzbmFwc2hvdFxuICogICB7IHR5cGU6ICdUSU1FUicgfVxuICogKTsgLy8gZXZlbnQgb2JqZWN0XG4gKlxuICogY29uc29sZS5sb2cobmV4dFNuYXBzaG90Mi52YWx1ZSk7XG4gKiAvLyA9PidyZWQnXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dFNuYXBzaG90KGFjdG9yTG9naWMsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBpbmVydEFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYyk7XG4gIGluZXJ0QWN0b3JTY29wZS5zZWxmLl9zbmFwc2hvdCA9IHNuYXBzaG90O1xuICByZXR1cm4gYWN0b3JMb2dpYy50cmFuc2l0aW9uKHNuYXBzaG90LCBldmVudCwgaW5lcnRBY3RvclNjb3BlKTtcbn1cblxuLy8gYXQgdGhlIG1vbWVudCB3ZSBhbGxvdyBleHRyYSBhY3RvcnMgLSBvbmVzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgYnkgYGNoaWxkcmVuYFxuLy8gdGhpcyBjb3VsZCBiZSByZWNvbnNpZGVyZWQgaW4gdGhlIGZ1dHVyZVxuXG4vLyB1c2VkIHRvIGtlZXAgb25seSBTdGF0ZVNjaGVtYSByZWxldmFudCBrZXlzXG4vLyB0aGlzIGhlbHBzIHdpdGggdHlwZSBzZXJpYWxpemF0aW9uIGFzIGl0IG1ha2VzIHRoZSBpbmZlcnJlZCB0eXBlIG11Y2ggc2hvcnRlciB3aGVuIGRlYWxpbmcgd2l0aCBodWdlIGNvbmZpZ3NcblxuZnVuY3Rpb24gc2V0dXAoe1xuICBzY2hlbWFzLFxuICBhY3RvcnMsXG4gIGFjdGlvbnMsXG4gIGd1YXJkcyxcbiAgZGVsYXlzXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXNzaWduLFxuICAgIHNlbmRUbyxcbiAgICByYWlzZSxcbiAgICBsb2csXG4gICAgY2FuY2VsLFxuICAgIHN0b3BDaGlsZCxcbiAgICBlbnF1ZXVlQWN0aW9ucyxcbiAgICBlbWl0LFxuICAgIHNwYXduQ2hpbGQsXG4gICAgY3JlYXRlU3RhdGVDb25maWc6IGNvbmZpZyA9PiBjb25maWcsXG4gICAgY3JlYXRlQWN0aW9uOiBmbiA9PiBmbixcbiAgICBjcmVhdGVNYWNoaW5lOiBjb25maWcgPT4gY3JlYXRlTWFjaGluZSh7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBzY2hlbWFzXG4gICAgfSwge1xuICAgICAgYWN0b3JzLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGd1YXJkcyxcbiAgICAgIGRlbGF5c1xuICAgIH0pLFxuICAgIGV4dGVuZDogZXh0ZW5kZWQgPT4gc2V0dXAoe1xuICAgICAgc2NoZW1hcyxcbiAgICAgIGFjdG9ycyxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgLi4uYWN0aW9ucyxcbiAgICAgICAgLi4uZXh0ZW5kZWQuYWN0aW9uc1xuICAgICAgfSxcbiAgICAgIGd1YXJkczoge1xuICAgICAgICAuLi5ndWFyZHMsXG4gICAgICAgIC4uLmV4dGVuZGVkLmd1YXJkc1xuICAgICAgfSxcbiAgICAgIGRlbGF5czoge1xuICAgICAgICAuLi5kZWxheXMsXG4gICAgICAgIC4uLmV4dGVuZGVkLmRlbGF5c1xuICAgICAgfVxuICAgIH0pXG4gIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZ1xuY2xhc3MgU2ltdWxhdGVkQ2xvY2sge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRpbWVvdXRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX25vdyA9IDA7XG4gICAgdGhpcy5faWQgPSAwO1xuICAgIHRoaXMuX2ZsdXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICB9XG4gIG5vdygpIHtcbiAgICByZXR1cm4gdGhpcy5fbm93O1xuICB9XG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZCsrO1xuICB9XG4gIHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcbiAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gdGhpcy5fZmx1c2hpbmc7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldElkKCk7XG4gICAgdGhpcy50aW1lb3V0cy5zZXQoaWQsIHtcbiAgICAgIHN0YXJ0OiB0aGlzLm5vdygpLFxuICAgICAgdGltZW91dCxcbiAgICAgIGZuXG4gICAgfSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGNsZWFyVGltZW91dChpZCkge1xuICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSB0aGlzLl9mbHVzaGluZztcbiAgICB0aGlzLnRpbWVvdXRzLmRlbGV0ZShpZCk7XG4gIH1cbiAgc2V0KHRpbWUpIHtcbiAgICBpZiAodGhpcy5fbm93ID4gdGltZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gdHJhdmVsIGJhY2sgaW4gdGltZScpO1xuICAgIH1cbiAgICB0aGlzLl9ub3cgPSB0aW1lO1xuICAgIHRoaXMuZmx1c2hUaW1lb3V0cygpO1xuICB9XG4gIGZsdXNoVGltZW91dHMoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoaW5nKSB7XG4gICAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZmx1c2hpbmcgPSB0cnVlO1xuICAgIGNvbnN0IHNvcnRlZCA9IFsuLi50aGlzLnRpbWVvdXRzXS5zb3J0KChbX2lkQSwgdGltZW91dEFdLCBbX2lkQiwgdGltZW91dEJdKSA9PiB7XG4gICAgICBjb25zdCBlbmRBID0gdGltZW91dEEuc3RhcnQgKyB0aW1lb3V0QS50aW1lb3V0O1xuICAgICAgY29uc3QgZW5kQiA9IHRpbWVvdXRCLnN0YXJ0ICsgdGltZW91dEIudGltZW91dDtcbiAgICAgIHJldHVybiBlbmRCID4gZW5kQSA/IC0xIDogMTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgdGltZW91dF0gb2Ygc29ydGVkKSB7XG4gICAgICBpZiAodGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCkge1xuICAgICAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmx1c2hUaW1lb3V0cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ub3coKSAtIHRpbWVvdXQuc3RhcnQgPj0gdGltZW91dC50aW1lb3V0KSB7XG4gICAgICAgIHRoaXMudGltZW91dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgdGltZW91dC5mbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICB9XG4gIGluY3JlbWVudChtcykge1xuICAgIHRoaXMuX25vdyArPSBtcztcbiAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGBvdXRwdXRgIG9mIHRoZSBhY3RvciB3aGVuIGl0IGlzIGRvbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb3V0cHV0OiB7XG4gKiAgICAgY291bnQ6IDQyXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSk7XG4gKlxuICogYWN0b3Iuc3RhcnQoKTtcbiAqXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCB0b1Byb21pc2UoYWN0b3IpO1xuICpcbiAqIGNvbnNvbGUubG9nKG91dHB1dCk7XG4gKiAvLyBsb2dzIHsgY291bnQ6IDQyIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB0b1Byb21pc2UoYWN0b3IpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhY3Rvci5zdWJzY3JpYmUoe1xuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShhY3Rvci5nZXRTbmFwc2hvdCgpLm91dHB1dCk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IHJlamVjdFxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhY3RvciBgbG9naWNgLCBhIGBzbmFwc2hvdGAsIGFuZCBhbiBgZXZlbnRgLCByZXR1cm5zIGEgdHVwbGUgb2YgdGhlXG4gKiBgbmV4dFNuYXBzaG90YCBhbmQgYGFjdGlvbnNgIHRvIGV4ZWN1dGUuXG4gKlxuICogVGhpcyBpcyBhIHB1cmUgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdCBleGVjdXRlIGBhY3Rpb25zYC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNpdGlvbihsb2dpYywgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IGV4ZWN1dGFibGVBY3Rpb25zID0gW107XG4gIGNvbnN0IGFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUobG9naWMpO1xuICBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yID0gYWN0aW9uID0+IHtcbiAgICBleGVjdXRhYmxlQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH07XG4gIGNvbnN0IG5leHRTbmFwc2hvdCA9IGxvZ2ljLnRyYW5zaXRpb24oc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKTtcbiAgcmV0dXJuIFtuZXh0U25hcHNob3QsIGV4ZWN1dGFibGVBY3Rpb25zXTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhY3RvciBgbG9naWNgIGFuZCBvcHRpb25hbCBgaW5wdXRgLCByZXR1cm5zIGEgdHVwbGUgb2YgdGhlXG4gKiBgbmV4dFNuYXBzaG90YCBhbmQgYGFjdGlvbnNgIHRvIGV4ZWN1dGUgZnJvbSB0aGUgaW5pdGlhbCB0cmFuc2l0aW9uIChub1xuICogcHJldmlvdXMgc3RhdGUpLlxuICpcbiAqIFRoaXMgaXMgYSBwdXJlIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgZXhlY3V0ZSBgYWN0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxUcmFuc2l0aW9uKGxvZ2ljLCAuLi5baW5wdXRdKSB7XG4gIGNvbnN0IGV4ZWN1dGFibGVBY3Rpb25zID0gW107XG4gIGNvbnN0IGFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUobG9naWMpO1xuICBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yID0gYWN0aW9uID0+IHtcbiAgICBleGVjdXRhYmxlQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH07XG4gIGNvbnN0IG5leHRTbmFwc2hvdCA9IGxvZ2ljLmdldEluaXRpYWxTbmFwc2hvdChhY3RvclNjb3BlLCBpbnB1dCk7XG4gIHJldHVybiBbbmV4dFNuYXBzaG90LCBleGVjdXRhYmxlQWN0aW9uc107XG59XG5cbmNvbnN0IGRlZmF1bHRXYWl0Rm9yT3B0aW9ucyA9IHtcbiAgdGltZW91dDogSW5maW5pdHkgLy8gbXVjaCBtb3JlIHRoYW4gMTAgc2Vjb25kc1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVzIHRvIGFuIGFjdG9yIHJlZiBhbmQgd2FpdHMgZm9yIGl0cyBlbWl0dGVkIHZhbHVlIHRvIHNhdGlzZnkgYVxuICogcHJlZGljYXRlLCBhbmQgdGhlbiByZXNvbHZlcyB3aXRoIHRoYXQgdmFsdWUuIFdpbGwgdGhyb3cgaWYgdGhlIGRlc2lyZWQgc3RhdGVcbiAqIGlzIG5vdCByZWFjaGVkIGFmdGVyIGFuIG9wdGlvbmFsIHRpbWVvdXQuIChkZWZhdWx0cyB0byBJbmZpbml0eSkuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgc3RhdGUgPSBhd2FpdCB3YWl0Rm9yKHNvbWVTZXJ2aWNlLCAoc3RhdGUpID0+IHtcbiAqICAgcmV0dXJuIHN0YXRlLmhhc1RhZygnbG9hZGVkJyk7XG4gKiB9KTtcbiAqXG4gKiBzdGF0ZS5oYXNUYWcoJ2xvYWRlZCcpOyAvLyB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWN0b3JSZWYgVGhlIGFjdG9yIHJlZiB0byBzdWJzY3JpYmUgdG9cbiAqIEBwYXJhbSBwcmVkaWNhdGUgRGV0ZXJtaW5lcyBpZiBhIHZhbHVlIG1hdGNoZXMgdGhlIGNvbmRpdGlvbiB0byB3YWl0IGZvclxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IGV2ZW50dWFsbHkgcmVzb2x2ZXMgdG8gdGhlIGVtaXR0ZWQgdmFsdWUgdGhhdCBtYXRjaGVzXG4gKiAgIHRoZSBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gd2FpdEZvcihhY3RvclJlZiwgcHJlZGljYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0V2FpdEZvck9wdGlvbnMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHJlc29sdmVkT3B0aW9ucztcbiAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcbiAgICAgIHJlaihzaWduYWwucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBpZiAocmVzb2x2ZWRPcHRpb25zLnRpbWVvdXQgPCAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdgdGltZW91dGAgcGFzc2VkIHRvIGB3YWl0Rm9yYCBpcyBuZWdhdGl2ZSBhbmQgaXQgd2lsbCByZWplY3QgaXRzIGludGVybmFsIHByb21pc2UgaW1tZWRpYXRlbHkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZSA9IHJlc29sdmVkT3B0aW9ucy50aW1lb3V0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZGlzcG9zZSgpO1xuICAgICAgcmVqKG5ldyBFcnJvcihgVGltZW91dCBvZiAke3Jlc29sdmVkT3B0aW9ucy50aW1lb3V0fSBtcyBleGNlZWRlZGApKTtcbiAgICB9LCByZXNvbHZlZE9wdGlvbnMudGltZW91dCk7XG4gICAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBzdWI/LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoYWJvcnRMaXN0ZW5lcikge1xuICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNoZWNrRW1pdHRlZChlbWl0dGVkKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVtaXR0ZWQpKSB7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgcmVzKGVtaXR0ZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBgc2lnbmFsYCBvcHRpb24gaXMgcHJvdmlkZWQsIHRoaXMgd2lsbCBiZSB0aGUgbGlzdGVuZXIgZm9yIGl0c1xuICAgICAqIGBhYm9ydGAgZXZlbnRcbiAgICAgKi9cbiAgICBsZXQgYWJvcnRMaXN0ZW5lcjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHN1YjsgLy8gYXZvaWQgVERaIHdoZW4gZGlzcG9zaW5nIHN5bmNocm9ub3VzbHlcblxuICAgIC8vIFNlZSBpZiB0aGUgY3VycmVudCBzbmFwc2hvdCBhbHJlYWR5IG1hdGNoZXMgdGhlIHByZWRpY2F0ZVxuICAgIGNoZWNrRW1pdHRlZChhY3RvclJlZi5nZXRTbmFwc2hvdCgpKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG9ubHkgZGVmaW5lIHRoZSBgYWJvcnRMaXN0ZW5lcmAgaWYgdGhlIGBzaWduYWxgIG9wdGlvbiBpcyBwcm92aWRlZFxuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGFib3J0TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgLy8gWFN0YXRlIGRvZXMgbm90IFwib3duXCIgdGhlIHNpZ25hbCwgc28gd2Ugc2hvdWxkIHJlamVjdCB3aXRoIGl0cyByZWFzb24gKGlmIGFueSlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICAgIHJlaihzaWduYWwucmVhc29uKTtcbiAgICAgIH07XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydExpc3RlbmVyKTtcbiAgICB9XG4gICAgc3ViID0gYWN0b3JSZWYuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IGNoZWNrRW1pdHRlZCxcbiAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXByb21pc2UtcmVqZWN0LWVycm9yc1xuICAgICAgICByZWooZXJyKTtcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIHJlaihuZXcgRXJyb3IoYEFjdG9yIHRlcm1pbmF0ZWQgd2l0aG91dCBzYXRpc2Z5aW5nIHByZWRpY2F0ZWApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgU2ltdWxhdGVkQ2xvY2ssIGFzc2VydEV2ZW50LCBjcmVhdGVNYWNoaW5lLCBnZXRJbml0aWFsU25hcHNob3QsIGdldE5leHRTbmFwc2hvdCwgaW5pdGlhbFRyYW5zaXRpb24sIHNldHVwLCB0b1Byb21pc2UsIHRyYW5zaXRpb24sIHdhaXRGb3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\n");

/***/ })

};
;